[["index.html", "R para los científicos 1 Preámbulo 1.1 Agradecimientos 1.2 Licencia", " R para los científicos François Rebaudo 2021-02-05 1 Preámbulo 1.1 Agradecimientos Agradezco a todos los colaboradores que ayudaron a mejorar este libro con sus consejos, sugerencias de cambios y correcciones (en orden alfabético): Camila BF, Marc G, Susi LH, y Estefania QH. Las versiones de gitbook, html y epub de este libro usan los iconos de fuente abierta de Font Awesome (https://fontawesome.com). La versión en PDF utiliza los iconos del proyecto Tango disponibles en openclipart (https://openclipart.org/). Este libro fue escrito con el paquete R bookdown (https://bookdown.org/). El código fuente está disponible en GitHub (https://github.com/frareb/myRBook_SP). La versión en línea se aloja y actualiza a través de Netlify (http://netlify.com/). Este libro también está disponible en francés en versión imprimida (http://myrbookfr.netlify.app/). Más allá de este libro, puede acceder a las diapositivas del último curso de R realizado en marzo de 2019 en Quito, Ecuador. 1.2 Licencia Licencia Reconocimiento-NoComercial-SinObraDerivada 3.0 España (CC BY-NC-ND 3.0 ES ; https://creativecommons.org/licenses/by-nc-nd/3.0/es/) Esto es un resumen inteligible para humanos (y no un sustituto) de la licencia. Usted es libre de: Compartir  copiar y redistribuir el material en cualquier medio o formato. El licenciador no puede revocar estas libertades mientras cumpla con los términos de la licencia. Bajo las condiciones siguientes: Reconocimiento  Debe reconocer adecuadamente la autoría, proporcionar un enlace a la licencia e indicar si se han realizado cambios&lt;. Puede hacerlo de cualquier manera razonable, pero no de una manera que sugiera que tiene el apoyo del licenciador o lo recibe por el uso que hace. NoComercial  No puede utilizar el material para una finalidad comercial. SinObraDerivada  Si remezcla, transforma o crea a partir del material, no puede difundir el material modificado. No hay restricciones adicionales  No puede aplicar términos legales o medidas tecnológicas que legalmente restrinjan realizar aquello que la licencia permite. Avisos: No tiene que cumplir con la licencia para aquellos elementos del material en el dominio público o cuando su utilización esté permitida por la aplicación de una excepción o un límite. No se dan garantías. La licencia puede no ofrecer todos los permisos necesarios para la utilización prevista. Por ejemplo, otros derechos como los de publicidad, privacidad, o los derechos morales pueden limitar el uso del material. "],["intro.html", " 2 Introducción 2.1 ¿Por qué aprender R? 2.2 Este libro 2.3 Lectura adicional en español", " 2 Introducción 2.1 ¿Por qué aprender R? Porque R se ha convertido en una herramienta esencial para el análisis y la gestión de datos científicos, y en este contexto se vuelve esencial dominar al menos los conceptos básicos. El éxito de R no es una coincidencia: R es un software que todos pueden obtener libremente garantizando la transparencia y la reproducibilidad de los resultados científicos (sujeto a cumplir con algunas reglas que abordará este libro). R también se basa en una comunidad muy activa con varios miles de módulos adicionales (paquetes) para realizar el análisis estadístico más avanzado. 2.2 Este libro El propósito de este libro es proporcionar a los estudiantes y aquellos que deseen aprender sobre R una base sólida para luego implementar sus propios proyectos científicos y la valoración de sus resultados. Hay muchos libros dedicados a R, pero ninguno cubre los elementos básicos de este lenguaje con el fin de hacer que los resultados científicos sean publicables y reproducibles. En general, este libro está dirigido a toda la comunidad científica y en particular a aquellos interesados en las ciencias de la vida, y los ejemplos en este libro se basarán en estudios de biología. Este libro nació de la solicitud de los estudiantes de las universidades que colaboran con el IRD en América del Sur. Por lo tanto, su primera versión está escrita en español (hay pocos documentos de calidad en R en español). Comencé su traducción al francés en 2018 y hoy ambas versiones coevolucionan con contenido que puede variar (por ejemplo, para estudios de casos). 2.3 Lectura adicional en español R para Principiantes, Emmanuel Paradis (https://cran.r-project.org/doc/contrib/rdebuts_es.pdf) "],["premiersPas.html", " 3 Primeros pasos 3.1 Instalar R 3.2 R como calculadora 3.3 El concepto de objeto 3.4 Los scripts 3.5 Conclusión", " 3 Primeros pasos 3.1 Instalar R El programa para instalar el software R se puede descargar desde el sitio web de R: https://www.r-project.org/. En el sitio web de R, primero es necesario elegir un espejo CRAN (servidor desde el cual se debe descargar R, y desde el más cercano a su ubicación geográfica), luego descargue el archivo base. Los usuarios de Linux pueden preferir un sudo apt-get install r-base. El software R se puede descargar de muchos servidores CRAN (Comprehensive R Archive Network) de todo el mundo. Estos servidores se llaman espejos. La elección del espejo es manual. 3.2 R como calculadora Una vez que se inicia el programa, aparece una ventana cuya apariencia puede variar dependiendo de su sistema operativo (Figura 3.1). Esta ventana se llama consola. Figure 3.1: Captura de pantalla de la consola R en Windows. La consola corresponde a la interfaz donde se interpretará el código, es decir, donde el código será transformado en lenguaje de máquina, ejecutado por la computadora y retransmitido en forma legible por humanos. Esto es análogo a lo que sucede en una calculadora (Figura 3.2). Así es como se usará R más adelante en esta sección. A lo largo de este libro, los ejemplos del código R aparecerán sobre un fondo gris. Se pueden copiar y pegar directamente en la consola, aunque es mejor reproducir los ejemplos escribiéndolos en la consola (o más adelante en los scripts) para una mejor comprensión del manejo del programa R. El resultado de lo que se envía en la consola también aparecerá en un fondo gris con ## delante del código para hacer la distinción entre el código y el resultado del código. Figure 3.2: Captura de pantalla de la consola R al lado de la calculadora de Windows. 3.2.1 Los operadores aritméticos 5 + 5 ## [1] 10 Si escribimos 5 + 5 en la consola y luego Enter, el resultado aparece precedido por el número [1] entre corchetes. Este número corresponde al número del resultado (en nuestro caso, solo hay un resultado, volveremos a este aspecto más adelante). También podemos observar en este ejemplo el uso de espacios antes y después del signo +. Estos espacios no son necesarios, pero permiten que el código sea más legible para los humanos (es decir, más agradable de leer tanto para nosotros como para las personas con las que queremos compartir nuestro código). Los operadores aritméticos disponibles en R se resumen en la tabla 3.1. Table 3.1: Operadores aritméticos. Label Operador adición + resta - multiplicación * división / potencia ^ módulo %% cociente decimal %/% Clásicamente, las multiplicaciones y divisiones tienen prioridad sobre las adiciones y sustracciones. Si es necesario, podemos usar paréntesis. 5 + 5 * 2 ## [1] 15 (5 + 5) * 2 ## [1] 20 (5 + 5) * (2 + 2) ## [1] 40 (5 + 5) * ((2 + 2) / 3)^2 ## [1] 17.77778 El operador módulo corresponde al resto de la división euclidiana. Se usa en ciencias de la computación, por ejemplo, para saber si un número es par o impar (un número módulo 2 devolverá 1 si es impar y 0 si es par). 451 %% 2 ## [1] 1 288 %% 2 ## [1] 0 (5 + 5 * 2) %% 2 ## [1] 1 ((5 + 5) * 2) %% 2 ## [1] 0 R también incorpora algunas constantes que incluyen pi. Además, el signo infinito está representado por Inf. pi ## [1] 3.141593 pi * 5^2 ## [1] 78.53982 1/0 ## [1] Inf El estilo del código es importante porque el código está destinado a ser leído por nosotros y por otras personas. Para tener un estilo legible, se recomienda colocar espacios antes y después de los operadores aritméticos, excepto *, / y ^, aunque a veces es útil agregarlos como es el caso en nuestro ejemplos. 3.2.2 Los operadores comparativos Sin embargo, R es mucho más que una simple calculadora porque permite otro tipo de operadores: operadores de comparación, para comparar los valores (Table 3.2). Table 3.2: Operadores de comparación. Label Operador más pequeño que &lt; mayor que &gt; más pequeño o igual a &lt;= más grande o igual a &gt;= igual a == diferente de != Por ejemplo, si queremos saber si un numero es más grande que otro, podemos escribir: 5 &gt; 3 ## [1] TRUE R devuelve TRUE si la comparación es verdadera y FALSE si la comparación es falsa. 5 &gt; 3 ## [1] TRUE 2 &lt; 1.5 ## [1] FALSE 2 &lt;= 2 ## [1] TRUE 3.2 &gt;= 1.5 ## [1] TRUE Podemos combinar operadores aritméticos con operadores de comparación. (5 + 8) &gt; (3 * 45/2) ## [1] FALSE En la comparación (5 + 8) &gt; (3 * 45/2) no se necesitan paréntesis, pero permiten que el código sea más fácil de leer. Un operador de comparación particular es igual a. Veremos en la siguiente sección que el signo = está reservado para otro uso: permite asignar un valor a un objeto. El operador de comparación igual a debe ser diferente, por eso R usa ==. 42 == 53 ## [1] FALSE 58 == 58 ## [1] TRUE Otro operador particular es diferente de. Se usa con un signo de admiración seguido de igual, !=. Este operador permite obtener la respuesta opuesta a ==. 42 == 53 ## [1] FALSE 42 != 53 ## [1] TRUE (3 + 2) != 5 ## [1] FALSE 10/2 == 5 ## [1] TRUE R usa TRUE y FALSE, que también son valores que se pueden probar con operadores de comparación. Pero R también asigna un valor a TRUE y FALSE: TRUE == TRUE ## [1] TRUE TRUE &gt; FALSE ## [1] TRUE 1 == TRUE ## [1] TRUE 0 == FALSE ## [1] TRUE TRUE + 1 ## [1] 2 FALSE + 1 ## [1] 1 (FALSE + 1) == TRUE ## [1] TRUE El valor de TRUE es 1 y el valor de FALSE es 0. Veremos más adelante cómo usar esta información en los próximos capítulos. R es también un lenguaje relativamente permisivo, significa que admite cierta flexibilidad en la forma de escribir el código. Debatir sobre la idoneidad de esta flexibilidad está fuera del alcance de este libro, pero podemos encontrar en el código R en Internet o en otras obras el atajo T para TRUE y F for FALSE. T == TRUE ## [1] TRUE F == FALSE ## [1] TRUE T == 1 ## [1] TRUE F == 0 ## [1] TRUE (F + 1) == TRUE ## [1] TRUE Aunque esta forma de referirse a TRUE y FALSE por T y F está bastante extendida, en este libro siempre usaremos TRUE y FALSE para que el código sea más fácil de leer. Como mencionado anterioramente, el objetivo de un código no solo es ser funcional sino también fácil de leer y volver a leer. 3.2.3 Los operadores lógicos Hay un último tipo de operador, los operadores lógicos. Estos son útiles para combinar operadores de comparación (Table 3.3). Table 3.3: Operadores lógicos. Label Operador no es ! y &amp; o | o exclusivo xor() !TRUE ## [1] FALSE !FALSE ## [1] TRUE ((3 + 2) == 5) &amp; ((3 + 3) == 5) ## [1] FALSE ((3 + 2) == 5) &amp; ((3 + 3) == 6) ## [1] TRUE (3 &lt; 5) &amp; (5 &lt; 5) ## [1] FALSE (3 &lt; 5) &amp; (5 &lt;= 5) ## [1] TRUE El operador lógico xor() es o exclusivo. Es decir, uno de los dos argumentos de la función xor() debe ser verdadero, pero no ambos. Más adelante volveremos a las funciones y sus argumentos, pero recuerde que identificamos una función por sus paréntesis que contienen argumentos separados por comas. xor((3 + 2) == 5, (3 + 3) == 6) ## [1] FALSE xor((3 + 2) == 5, (3 + 2) == 6) ## [1] TRUE xor((3 + 3) == 5, (3 + 2) == 6) ## [1] FALSE xor((3 + 3) == 5, (3 + 3) == 6) ## [1] TRUE Se recomienda que las comas , sean seguidas de un espacio para que el código sea más agradable de leer. 3.2.4 Ayuda a los operadores El archivo de ayuda en inglés sobre operadores aritméticos se puede obtener con el comando ?'+'. El de los operadores de comparación con el comando ?'==' y el de los operadores lógicos con el comando ?'&amp;'. 3.3 El concepto de objeto Un aspecto importante de la programación con R, pero también la programación en general es la noción de objeto. Como se indica en la página web de wikipedia (https://ia.wikipedia.org/wiki/Objecto_(informatica)), en ciencias de la computación, un objeto es un contenedor, es decir, algo que contendrá información. La información contenida en un objeto puede ser muy diversa, pero por el momento contendremos en un objeto el número 5. Para hacer esto (y para reutilizarlo más adelante), debemos darle un nombre a nuestro objeto. En R, los nombres de los objetos no deben contener caracteres especiales como ^ $ ? | + () [] {}, entre otros. No deben comenzar con un número ni contener espacios. El nombre del objeto debe ser representativo de lo que contiene, sin ser demasiado corto ni demasiado largo. Imagine que nuestro número 5 corresponde al número de repeticiones de un experimento. Nos gustaría darle un nombre que se refiera a numero y repeticiones, que podríamos reducir a nbr y rep, respectivamente (nbr para number en ingles). Hay varias posibilidades que son bastante comunes bajo R: la separación mediante guión bajo (underscore): nbr_rep la separación mediante el carácter punto: nbr.rep el uso de letras minúsculas: nbrrep el estilo lowerCamelCase que consiste en una primera palabra en minúscula y la primera letra de las siguientes palabras con una letra mayúscula: nbrRep el estilo UpperCamelCase donde cada palabra comienza con una letra mayúscula: NbrRep Todas estas formas de nombrar un objeto son equivalentes. En este libro usaremos el estilo lowerCamelCase. En general, debemos evitar los nombres que son demasiado largos, como miNumeroDeRepeticionesDeMiExperimento o demasiado cortos como nR, y los nombres que no permiten identificar los contenidos como miVariable o miNumero, asi que nombres como a o b. El objetivo es de tener una idea de lo que hay en cada objeto en base a su nombre. Hay diferentes maneras de definir un nombre para los objetos que crearemos con R. En este libro, utilizamos el estilo lowerCamelCase. Lo importante no es la elección del estilo, sino la consistencia en su elección. El objetivo es tener un código funcional, pero también un código que sea fácil y agradable de leer para nosotros y para los demás. Ahora que hemos elegido un nombre para nuestro objeto, debemos crearlo y hacer que R entienda que nuestro objeto debe contener el número 5. Hay tres maneras de crear un objeto bajo R: con &lt;- con = o con -&gt; nbrRep &lt;- 5 nbrRep = 5 5 -&gt; nbrRep En este libro siempre usaremos la forma &lt;- para coherencia y también porque es la forma más común. nbrRep &lt;- 5 Acabamos de crear un objeto nbrRep y establecerlo con el valor 5. Este objeto ahora está disponible en nuestro entorno de computación y puede ser utilizado. Algunos ejemplos : nbrRep + 2 ## [1] 7 nbrRep * 5 - 45/56 ## [1] 24.19643 pi * nbrRep^2 ## [1] 78.53982 El valor asociado con nuestro objeto nbrRep se puede modificar de la misma manera que cuando se creó: nbrRep &lt;- 5 nbrRep + 2 ## [1] 7 nbrRep &lt;- 10 nbrRep + 2 ## [1] 12 nbrRep &lt;- 5 * 2 + 7/3 nbrRep + 2 ## [1] 14.33333 El uso de objetos tiene sentido cuando tenemos operaciones complejas para realizar y hace que el código sea más agradable de leer y entender. (5 + 9^2 - 1/18) / (32 * 45/8 + 3) ## [1] 0.4696418 termino01 &lt;- 5 + 9^2 - 1/18 termino02 &lt;- 32 * 45/8 + 3 termino01 / termino02 ## [1] 0.4696418 3.4 Los scripts R es un lenguaje de programación denominado lenguaje de scripting. Esto se refiere al hecho de que la mayoría de los usuarios escribirán pequeñas piezas de código en lugar de programas completos. R se puede usar como una simple calculadora, y en este caso no será necesario mantener un historial de las operaciones que se han realizado. Pero si las operaciones a implementar son largas y complejas, puede ser necesario e interesante guardar lo que se ha hecho para poder continuar más adelante. El archivo en el que se almacenarán las operaciones es lo que comúnmente se llama el script. Un script, por lo tanto, es un archivo que contiene una sucesión de información comprensible por R y que es posible ejecutar. 3.4.1 Crear un script y documentarlo Para crear un nuevo script basta con abrir un documento vacío de texto, que será editado por un editor de texto como el bloc de notas en Windows o Mac OSX, o Gedit o incluso nano en Linux. Por convención, este archivo toma la extensión .r o .R (lo mas comun). Esta última convención se usará en este libro (miArchivo.R). Desde la interfaz gráfica de R, es posible crear un nuevo script en Mac OS y Windows a través de file, luego new script y save as. Al igual que el nombre de los objetos, el nombre del script es importante para que podamos identificar fácilmente su contenido. Por ejemplo, podríamos crear un archivo formRConceptsBase.R que contenga los objetos que acabamos de crear y los cálculos que hicimos. Pero incluso con nombres de objetos y archivos bien definidos, será difícil recordar el significado de este archivo sin la documentación que acompaña a este script. Para documentar un script utilizaremos comentarios. Los comentarios son elementos que R identificará como tales y no se ejecutarán. Para especificar a R que vamos a hacer un comentario, debemos usar el carácter octothorpe (corsé o numeral) #. Los comentarios se pueden insertar en una nueva línea o al final de la línea. # creación objeto número de repeticiones nbrRep &lt;- 5 # Comentario de fin de línea Todo lo que hay despues del simbolo numeral # no sera ejecutado. Significa que podriamos usar comentarios como ### o #comentario, aun que se recomienda hacer comentarios con un solo simbolo numeral seguido por un espacio y despues su comentario: # mi comentario. Los comentarios también se pueden usar para hacer que una línea ya no se ejecute. En este caso no queremos ejecutar la secunda linea: nbrRep &lt;- 5 # nbrRep + 5 Para volver a la documentación del script, se recomienda comenzar cada uno de nuestros scripts con una breve descripción de su contenido, luego cuando el script sea extenso, estructurarlo en diferentes partes para facilitar su lectura. # ------------------------------------------------------------ # Aquí hay un script para adquirir los conceptos básicos # con R # fecha de creación : 27/06/2018 # autor : François Rebaudo # ------------------------------------------------------------ # [1] creación del objeto número de repeticiones # ------------------------------------------------------------ nbrRep &lt;- 5 # [2] cálculos simples # ------------------------------------------------------------ pi * nbrRep^2 ## [1] 78.53982 Para ir más allá en el estilo del código, una guía completa de recomendaciones está disponible en línea en el sitio web tidyverse (en ingles ; http://style.tidyverse.org/). 3.4.2 Ejecutar un script Como tenemos un script, no trabajamos directamente en la consola. Pero solo la consola puede entender el código R y devolvernos los resultados que queremos obtener. Por ahora, la técnica más simple es copiar y pegar las líneas que queremos ejecutar desde nuestro script hasta la consola. A partir de ahora, ya no utilizaremos editores de texto como bloc de notas, sino editores especializados para la creación de scripts R. Sera es el objetivo del siguiente capítulo. 3.5 Conclusión Felicitaciones, hemos llegado al final de este primer capítulo sobre la base de R. Sabemos: Instalar R Usar R como una calculadora Crear objetos y utilisarlos para los calculos aritméticos, comparativos y logicos Elejir nombres pertinentes para los objetos Crear un nuevo script Elejir un nombre pertinente para el archivo del script Ejecutar el codigo de un script Documentar los scripts con comentarios Usar un estilo de código para que sea agradable de leer y facil de entender "],["IDE.html", " 4 Elegir un entorno de desarrollo 4.1 Editores de texto y entorno de desarrollo 4.2 RStudio 4.3 Notepad++ avec Npp2R 4.4 Geany 4.5 Otras soluciones 4.6 Conclusión", " 4 Elegir un entorno de desarrollo 4.1 Editores de texto y entorno de desarrollo Hay muchos editores de texto, el capítulo anterior permitió introducir algunos de los más simples como el bloc de notas de Windows. Sin embargo, los límites de estos editores han hecho tediosa la tarea de escribir un script. De hecho, incluso estructurando su script con comentarios, sigue siendo difícil entenderlo. Aquí es donde entran los editores de texto especializados para facilitar la escritura y la lectura de scripts. El editor de texto para R más común es Rstudio, pero hay muchos más. Hacer una lista exhaustiva de todas las soluciones disponibles está más allá del alcance de este libro, por lo que nos centraremos en las tres soluciones que utilizo a diario: Notepad++, Rstudio y Geany. No necesita instalar más de un editor de texto. Aquí recomendamos RStudio para principiantes a R. 4.2 RStudio Figure 4.1: Logo RStudio. 4.2.1 Instalar RStudio El programa para instalar el software RStudio se encuentra en la parte Products del sitio web de RStudio (https://www.rstudio.com/). Instalaremos RStudio para uso local (en nuestra computadora), por lo que la versión que nos interesa es Desktop. Usaremos la versión Open Source que es gratuita. Luego, seleccionamos la versión que corresponde a nuestro sistema operativo (Windows, Mac OS, Linux), descargamos el archivo correspondiente y lo ejecutamos para comenzar la instalación. Podemos mantener las opciones predeterminadas durante la instalación. 4.2.2 Un script con RStudio Podemos abrir RStudio. En la primera apertura, la interfaz se divide en dos con la consola R a la izquierda que vimos en el capítulo anterior (Figura 4.2). Para abrir un nuevo script, vamos al menú Archivo (o File), Nuevo archivo (o New File), R script. Por defecto, este archivo tiene el nombre Untitled1. Hemos visto en el capítulo anterior la importancia de dar un nombre pertinente a nuestros scripts, por lo que lo cambiaremos de nombre a selecEnvDev.R, en el menú Archivo (o File), con la opción Guardar como  (o Save As). Podemos notar que el lado izquierdo de RStudio ahora está dividido en dos, con la consola en la parte inferior de la pantalla y el script en la parte superior. Figure 4.2: Captura de pantalla de RStudio en Windows: pantalla por defecto. Luego podemos comenzar a escribir nuestro script con los comentarios que describan lo que vamos a encontrar allí, y agregar un cálculo simple. Una vez que hayamos copiado o escrito un código, podemos guardar nuestro script con el comando CTRL + S o yendo a Archivo (o File, luego Guardar (o Save). # ------------------------------------------------------------ # Un script para seleccionar su entorno de desarrollo # fecha de creación : 27/06/2018 # autor : François Rebaudo # ------------------------------------------------------------ # [1] cálculos simples # ------------------------------------------------------------ nbrRep &lt;- 5 pi * nbrRep^2 ## [1] 78.53982 Para ejecutar nuestro script, simplemente seleccionamos las líneas que deseamos ejecutar y usamos la combinación de teclas CTRL + ENTER. El resultado aparece en la consola (Figura 4.3). Figure 4.3: Captura de pantalla de RStudio en Windows: ejecutar nuestro script con CTRL + ENTER. Podemos ver que, de forma predeterminada, en la parte del script, los comentarios aparecen en verde, los números en azul y el resto del código en negro. En la parte de la consola, lo que se ejecutó aparece en azul y los resultados de la ejecución en negro. También podemos observar que en la parte del código cada línea tiene un número correspondiente al número de línea a la izquierda sobre un fondo gris. Este es el resaltado de preferencias de sintaxis predeterminado con RStudio. Estas preferencias de sintaxis pueden modificarse yendo al menú Herramientas (o Tools), Opciones globales  (o Global Options), Aspecto (o Appearance), y luego seleccionando otro tema del Editor de tema: (o Editor theme:). Elegiremos el tema Cobalt, luego OK (Figura 4.4). Figure 4.4: Captura de pantalla de RStudio en Windows: cambiar preferencias de sintaxis. Sabemos cómo crear un nuevo script, guardarlo, ejecutar su contenido y cambiar la apariencia de RStudio. Veremos los muchos otros beneficios de RStudio a lo largo de este libro, ya que es el entorno de desarrollo que se utilizará. Sin embargo, seremos especialmente cuidadosos de que todos los scripts desarrollados a lo largo de este libro se ejecuten de la misma manera, independientemente del entorno de desarrollo utilizado. 4.3 Notepad++ avec Npp2R Figure 4.5: Logo Notepad++ 4.3.1 Instalar Notepad++ (solamente para Windows) El programa para instalar Notepad ++ se puede encontrar en la pestaña Downloads (https://notepad-plus-plus.org/download/). Podemos elegir entre la versión de 32-bit y la de 64-bit (64-bit si no sabe qué versión elegir). Notepad++ es suficiente para escribir un script, pero es aún más poderoso con Notepad++ to R (Npp2R) que permite ejecutar automáticamente nuestros scripts en una consola localmente en nuestra computadora o remotamente en un servidor. 4.3.2 Instalar Npp2R El programa para instalar Npp2R está alojado en el sitio de Sourceforge (https://sourceforge.net/projects/npptor/). Npp2R debe instalarse después de Notepad++. 4.3.3 Un script con Notepad++ Al abrir por primera vez, Notepad++ muestra un archivo vacío new 1 (Figura 4.6). Figure 4.6: Captura de pantalla de Notepad++ en Windows: pantalla por defecto. Como ya hemos creado un script para probarlo con RStudio, lo abriremos de nuevo con Notepad++. En Archivo, seleccionamos Abrir  luego elijemos el script selecEnvDev.R creado previamente. Una vez que el script está abierto, vamos a Idioma, luego R, y de nuevo R. Aparece el resaltado de sintaxis (Figura 4.7). Figure 4.7: Captura de pantalla de Notepad++ en Windows: ejecutar nuestro script con F8. La ejecución del script solo se puede realizar si se está ejecutando Npp2R. Para hacerlo, es necesario ejecutar el programa Npp2R desde el prompt de Windows. Un icono debe aparecer en la parte inferior de su pantalla demostrando que Npp2R está prendido. La ejecución automática del código de Notepad++ se realiza seleccionando el código para ejecutar y luego usando el comando F8. Si el comando no funciona, puede ser necesario reiniciar la computadora. Si el comando funciona, se abrirá una nueva ventana con una consola que ejecuta las líneas deseadas (Figura 4.8). Figure 4.8: Captura de pantalla de Notepad++ en Windows: la consola con F8. Al igual que con RStudio, el resaltado de sintaxis se puede cambiar desde el menú Configuración, y se puede seleccionar un nuevo tema (por ejemplo, Solarized en la Figura 4.9) Figure 4.9: Captura de pantalla de Notepad++ en Windows con el tema Solarized. Comparado con otros editores de texto, Notepad++ tiene la ventaja de ser muy liviano, rapido y ofrece una amplia gama de opciones para personalizar la escritura de códigos. 4.4 Geany Figure 4.10: Logo Geany 4.4.1 Instalar Geany (para Linux, Mac OSX y Windows) El programa para instalar Geany se puede encontrar en la pestaña Downloads en el menú de la izquierda Releases de la página web (https://www.geany.org/). Luego solo descargamos el ejecutable para Windows o el dmg para Mac OSX. Los usuarios de Linux preferirán un sudo apt-get install geany. 4.4.2 Un script con Geany Al abrir por primera vez, como para RStudio y Notepad++, se crea un archivo vacío (Figura 4.11). Figure 4.11: Captura de pantalla de Geany en Windows: pantalla por defecto. Podemos abrir nuestro script con Archivo, Abrir (Figura 4.12). Figure 4.12: Captura de pantalla de Geany en Windows: abrir un script. Para ejecutar nuestro script, la versión de Geany para Windows no tiene un terminal incorporado, lo que hace que su uso sea limitado bajo este sistema operativo. La ejecución de un script se puede hacer abriendo R en una ventana separada y copiando y pegando las líneas que se ejecutarán. En Linux y Mac OSX, podemos abrir R en el terminal en la parte inferior de la ventana de Geany con el comando R. Podemos configurar Geany para una combinación de teclas para ejecutar el código seleccionado (por ejemplo CTRL + R). Para esto hay que permitir el envío de selección al terminal (send_selection_unsafe = true) in archivo geany.conf y elegir el comando para enviar al terminal (en Editar, Preferencias, Combinaciones). Para cambiar el tema de Geany, hay una colección de temas disponibles en GitHub (https://github.com/geany/geany-themes/). El tema se puede cambiar a través del menú Ver, cambiar Esquema del color  (un ejemplo con el tema Solarized Figura @ref(Fig: screenCapGeany03)). Figure 4.13: Captura de pantalla de Geany en Windows: cambiar esquema de color. 4.5 Otras soluciones Hay muchas otras soluciones, algunas especializadas para R como Tinn-R (https://sourceforge.net/projects/tinn-r/), y otras más generales para programación como Atom (https://atom.io/), Sublime Text (https://www.sublimetext.com/), Vim (https://www.vim.org/), Gedit (https://wiki.gnome.org/Apps/Gedit), GNU Emacs (https://www.gnu.org/software/emacs/), Jupyter (http://jupyter.org), o Brackets (http://brackets.io/) y Eclipse (http://www.eclipse.org/). 4.6 Conclusión Felicitaciones, llegamos al final de este capítulo sobre el entorno de desarrollo para el uso de R. Hasta ahora sabemos: Instalar RStudio, Geany o Notepad++ Reconocer y elegir nuestro entorno de preferencia A partir de acá podremos concentrarnos en el lenguaje de programación R en un ambiente, facilitando el trabajo de lectura y de escritura del código. Esto ya es un gran paso para manejar R. "],["dataType1.html", " 5 Tipos de datos 5.1 El tipo numeric 5.2 El tipo character 5.3 El tipo factor 5.4 El tipo logical 5.5 Acerca de NA 5.6 Conclusión", " 5 Tipos de datos Vimos anteriormente cómo crear un objeto. Un objeto es como una caja en la que almacenaremos información. Hasta ahora solo hemos almacenado números, pero en este capítulo veremos que es posible almacenar otra información y nos detendremos en los tipos más comunes. En este capítulo utilizaremos funciones sobre las cuales volveremos más adelante. 5.1 El tipo numeric El tipo numeric es lo que hemos hecho hasta ahora, almacenando números. Hay dos tipos principales de números en R: enteros (integer) y números decimales (double). Por defecto, R considera todos los números como números decimales y asigna el tipo double. Para verificar el tipo de datos utilizaremos la función typeof() que toma como argumento un objeto (o directamente la información que queremos probar). También podemos usar la función is.double() que devolverá TRUE si el número está en formato double y FALSE en caso contrario. La función genérica is.numeric() devolverá TRUE si el objeto está en formato numeric y FALSE en caso contrario. nbrRep &lt;- 5 typeof(nbrRep) ## [1] &quot;double&quot; typeof(5.32) ## [1] &quot;double&quot; is.numeric(5) ## [1] TRUE is.double(5) ## [1] TRUE Si queremos decirle a R que vamos a trabajar con un entero, entonces necesitamos convertir nuestro número decimal en un entero con la función as.integer(). También podemos usar la función is.integer() que devolverá TRUE si el número está en formato integer y FALSE en caso contrario. nbrRep &lt;- as.integer(5) typeof(nbrRep) ## [1] &quot;integer&quot; typeof(5.32) ## [1] &quot;double&quot; typeof(as.integer(5.32)) ## [1] &quot;integer&quot; as.integer(5.32) ## [1] 5 as.integer(5.99) ## [1] 5 is.numeric(nbrRep) ## [1] TRUE Vemos aquí que convertir un número como 5.99 a integer solo devolverá la parte entera, 5. is.integer(5) ## [1] FALSE is.numeric(5) ## [1] TRUE is.integer(as.integer(5)) ## [1] TRUE is.numeric(as.integer(5)) ## [1] TRUE La suma de un número entero integer y un número decimal double devuelve un número decimal. sumIntDou &lt;- as.integer(5) + 5.2 typeof(sumIntDou) ## [1] &quot;double&quot; sumIntInt &lt;- as.integer(5) + as.integer(5) typeof(sumIntInt) ## [1] &quot;integer&quot; Para resumir, el tipo numeric contiene dos subtipos, los tipos integer para enteros y el tipo double para los números decimales. Por defecto, R asigna el tipo double a los números. Tenga cuidado, hay una trampa para usar la función is.integer(). No nos dice si el número es un número entero, pero si es de tipo integer. De hecho, uno puede almacenar un entero en una variable de tipo double. Los números almacenados en una variable de tipo integer son codificados en 32 bits y, por lo tanto, pueden tomar valores entre 0 y 2^32-1 = 4294967295. Hay otra forma de decirle a R que un número es un número entero, usando el sufijo L. Por ejemplo, 5L es lo mismo que as.integer(5). El origen del sufijo L, que se remonta a una época en que las computadoras usaban palabras de 16 bits y 32 bits, era un tipo Long. ¡Ahora las computadoras usan palabras de 64 bits y 32 bits es bastante corto! No podemos dejar esta sección sin mencionar las funciones round() ceiling() trunc() o floor() que devuelven la parte entera de un número, pero déjelo en el tipo double. Para obtener más información, podemos usar la ayuda de R con ?round. roundDou &lt;- round (5.2) typeof (roundDou) ## [1] &quot;double&quot; 5.2 El tipo character El tipo character es texto. De hecho, R permite trabajar con texto. Para especificar a R que la información contenida en un objeto está en formato de texto (o generalmente para todos los textos), usamos las comillas dobles (\") o las comillas simples ('). myText &lt;- &quot;azerty&quot; myText2 &lt;- &#39;azerty&#39; myText3 &lt;- &#39;azerty uiop qsdfg hjklm&#39; typeof(myText3) ## [1] &quot;character&quot; Tanto las comillas dobles y simples son útiles en nuestro texto. También podemos escapar un carácter especial como comillas gracias al signo de barra invertida \\. myText &lt;- &quot;a &#39;ze&#39; &#39;rt&#39; y&quot; print(myText) ## [1] &quot;a &#39;ze&#39; &#39;rt&#39; y&quot; myText2 &lt;- &#39;a &quot;zert&quot; y&#39; print(myText2) ## [1] &quot;a \\&quot;zert\\&quot; y&quot; myText3 &lt;- &#39;azerty uiop qsdfg hjklm&#39; print(myText3) ## [1] &quot;azerty uiop qsdfg hjklm&quot; myText4 &lt;- &quot;qwerty \\&quot; azerty &quot; print(myText4) ## [1] &quot;qwerty \\&quot; azerty &quot; myText5 &lt;- &quot;qwerty \\\\ azerty &quot; print(myText5) ## [1] &quot;qwerty \\\\ azerty &quot; De forma predeterminada, cuando creamos un objeto, su contenido no es devuelto por la consola. En Internet o en muchos libros podemos encontrar el nombre del objeto en una línea para devolver sus contenidos: myText &lt;- &quot;a &#39;ze&#39; &#39;rt&#39; y&quot; myText ## [1] &quot;a &#39;ze&#39; &#39;rt&#39; y&quot; En este libro, no lo usaremos de esta manera y preferiremos el uso de la función print(), que permite mostrar en la consola el contenido de un objeto. El resultado es el mismo, pero el código es más fácil de leer y más explícito sobre lo que hace. myText &lt;- &quot;a &#39;ze&#39; &#39;rt&#39; y&quot; print(myText) ## [1] &quot;a &#39;ze&#39; &#39;rt&#39; y&quot; nbrRep &lt;- 5 print(nbrRep) ## [1] 5 También podemos poner números en formato de texto, pero no debemos olvidar poner comillas para especificar el tipo character o usar la funciónas.character(). Una operación entre un texto y un número devuelve un error. Por ejemplo, si agregamos 10 a 5, R nos dice que un argumento de la función + no es un tipo numeric y que, por lo tanto, la operación no es posible. Tampoco podemos agregar texto a texto, pero veremos más adelante cómo concatenar dos cadenas de texto. myText &lt;- &quot;qwerty&quot; typeof(myText) ## [1] &quot;character&quot; myText2 &lt;- 5 typeof(myText2) ## [1] &quot;double&quot; myText3 &lt;- &quot;5&quot; typeof(myText3) ## [1] &quot;character&quot; myText2 + 10 ## [1] 15 as.character(5) ## [1] &quot;5&quot; # myText3 + 10 # Error in myText3 + 10 : non-numeric argument to binary operator # &quot;a&quot; + &quot;b&quot; # Error in &quot;a&quot; + &quot;b&quot; : non-numeric argument to binary operator Para resumir, el tipo character permite el ingreso de texto, podemos reconocerlo con comillas simples o dobles. 5.3 El tipo factor El tipo factor corresponde a los factores. Los factores son una elección dentro de una lista finita de posibilidades. Por ejemplo, los países son factores porque existe una lista finita de países en el mundo en un momento dado. Un factor puede definirse con la función factor() o transformarse utilizando la función as.factor(). Al igual que con otros tipos de datos, podemos usar la función is.factor() para verificar el tipo de datos. Para obtener una lista de todas las posibilidades, existe la función levels() (esta función tendrá más sentido cuando nos acerquemos a los tipos de contenedores de información). factor01 &lt;- factor(&quot;aaa&quot;) print(factor01) ## [1] aaa ## Levels: aaa typeof(factor01) ## [1] &quot;integer&quot; is.factor(factor01) ## [1] TRUE levels(factor01) ## [1] &quot;aaa&quot; Un factor se puede transformar en texto con la función as.character() pero también en número con as.numeric(). Al cambiar al tipo numeric, cada factor toma el valor de su posición en la lista de posibilidades. En nuestro caso, solo hay una posibilidad, por lo que la función as.numeric() devolverá 1: factor01 &lt;- factor(&quot;aaa&quot;) as.character(factor01) ## [1] &quot;aaa&quot; as.numeric(factor01) ## [1] 1 5.4 El tipo logical El tipo logical corresponde a los valores TRUE y FALSE (y NA) que ya hemos visto con los operadores de comparación. aLogic &lt;- TRUE print(aLogic) ## [1] TRUE typeof(aLogic) ## [1] &quot;logical&quot; is.logical(aLogic) ## [1] TRUE aLogic + 1 ## [1] 2 as.numeric(aLogic) ## [1] 1 as.character(aLogic) ## [1] &quot;TRUE&quot; 5.5 Acerca de NA El valor NA se puede usar para especificar que no hay datos o datos faltantes. Por defecto, NA es logical, pero se puede usar para texto o números. print(NA) ## [1] NA typeof(NA) ## [1] &quot;logical&quot; typeof(as.integer(NA)) ## [1] &quot;integer&quot; typeof(as.character(NA)) ## [1] &quot;character&quot; NA == TRUE ## [1] NA NA == FALSE ## [1] NA NA &gt; 1 ## [1] NA NA + 1 ## [1] NA 5.6 Conclusión Felicitaciones, hemos llegado al final de este capítulo sobre los tipos de datos. Ahora sabemos: Reconocer y hacer objetos en los principales tipos de datos Transformar tipos de datos de un tipo a otro Este capítulo es la base para el próximo capítulo sobre contenedores de datos. "],["dataType2.html", " 6 Contenedores de datos 6.1 El contenedor vector 6.2 El contenedor list 6.3 El contenedor data.frame 6.4 El contenedor matrix 6.5 El contenedor array 6.6 Conclusión", " 6 Contenedores de datos Hasta ahora hemos creado objetos simples que contienen solo un valor. Sin embargo, pudimos ver que un objeto tenía atributos diferentes, como su valor, pero también el tipo de datos contenidos (e.g., numeric, character). Ahora vamos a ver que hay diferentes tipos de contenedores para almacenar datos múltiples. 6.1 El contenedor vector En R, un vector es una combinación de datos con la particularidad de que todos los datos contenidos en un vector son del mismo tipo. Podemos almacenar por ejemplo múltiples elementos del tipo character o numeric en un vector, pero no ambos. El contenedor vector es importante porque es el elemento básico de R. 6.1.1 Crear un vector Para crear un vector utilizaremos la función c() que permite combinar elementos en un vector. Los elementos para combinar deben estar separados por comas. miVec01 &lt;- c(1, 2, 3, 4) # un vector de 4 elementos de tipo numeric ; double print(miVec01) ## [1] 1 2 3 4 typeof(miVec01) ## [1] &quot;double&quot; is.vector(miVec01) ## [1] TRUE La funcion is.vector() permite verificar el tipo de contenedor. miVec02 &lt;- c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;) print(miVec02) ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; typeof(miVec02) ## [1] &quot;character&quot; is.vector(miVec02) ## [1] TRUE miVec03 &lt;- c(TRUE, FALSE, FALSE, TRUE) print(miVec03) ## [1] TRUE FALSE FALSE TRUE typeof(miVec03) ## [1] &quot;logical&quot; is.vector(miVec03) ## [1] TRUE miVecNA &lt;- c(1, NA, 3, NA, 5) print(miVecNA) ## [1] 1 NA 3 NA 5 typeof(miVecNA) ## [1] &quot;double&quot; is.vector(miVecNA) ## [1] TRUE miVec04 &lt;- c(1, &quot;a&quot;) print(miVec04) ## [1] &quot;1&quot; &quot;a&quot; typeof(miVec04) ## [1] &quot;character&quot; is.vector(miVec04) ## [1] TRUE Si combinamos diferentes tipos de datos, R intentará transformar los elementos en un tipo de forma predeterminada. Si como aquí en el objeto miVec03 tenemos los tipos character y numeric, R convertirá todos los elementos en character. miVec05 &lt;- c(factor(&quot;abc&quot;), &quot;def&quot;) print(miVec05) ## [1] &quot;1&quot; &quot;def&quot; typeof(miVec05) ## [1] &quot;character&quot; miVec06 &lt;- c(TRUE, &quot;def&quot;) print(miVec06) ## [1] &quot;TRUE&quot; &quot;def&quot; typeof(miVec06) ## [1] &quot;character&quot; miVec07 &lt;- c(factor(&quot;abc&quot;), 55) print(miVec07) ## [1] 1 55 typeof(miVec07) ## [1] &quot;double&quot; miVec08 &lt;- c(TRUE, 55) print(miVec08) ## [1] 1 55 typeof(miVec08) ## [1] &quot;double&quot; También podemos combinar objetos existentes dentro de un vector. miVec09 &lt;- c(miVec02, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;) print(miVec09) ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; miVec10 &lt;- c(&quot;aaa&quot;, &quot;aa&quot;, miVec09, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;) print(miVec10) ## [1] &quot;aaa&quot; &quot;aa&quot; &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; miVec11 &lt;- c(789, miVec01 , 564) print(miVec11) ## [1] 789 1 2 3 4 564 6.1.2 Hacer operaciones con un vector También podemos realizar operaciones en un vector. print(miVec01) ## [1] 1 2 3 4 miVec01 + 1 ## [1] 2 3 4 5 miVec01 - 1 ## [1] 0 1 2 3 miVec01 * 2 ## [1] 2 4 6 8 miVec01 /10 ## [1] 0.1 0.2 0.3 0.4 Las operaciones de un vector a otro también son posibles, pero se debe tener cuidado para asegurar que el número de elementos en un vector sea el mismo que el otro, de lo contrario R realizará el cálculo comenzando desde el inicio del vector mas pequeño. Aquí hay un ejemplo para ilustrar lo que R hace: miVec12 &lt;- c(1, 1, 1, 1, 1, 1, 1, 1, 1) print(miVec12) ## [1] 1 1 1 1 1 1 1 1 1 miVec13 &lt;- c(10, 20, 30) print(miVec13) ## [1] 10 20 30 miVec12 + miVec13 # vectores de diferentes tamaños: atención al resultado ## [1] 11 21 31 11 21 31 11 21 31 miVec14 &lt;- c(10, 20, 30, 40, 50, 60, 70, 80, 90) print(miVec14) ## [1] 10 20 30 40 50 60 70 80 90 miVec12 + miVec14 # los vectores tienen el mismo tamaño ## [1] 11 21 31 41 51 61 71 81 91 miVec15 &lt;- c(1, 1, 1, 1) print(miVec15) ## [1] 1 1 1 1 miVec15 + miVec13 # vectores de diferentes tamaños y no múltiples ## Warning in miVec15 + miVec13: la taille d&#39;un objet plus long n&#39;est pas multiple ## de la taille d&#39;un objet plus court ## [1] 11 21 31 11 6.1.3 Acceder a los valores de un vector Suele pasar que sea necesario poder acceder a los valores de un vector, es decir, recuperar un valor o un grupo de valores dentro de un vector. Para acceder a un elemento de un vector usamos los corchetes []. Entre los corchetes, podemos usar un número correspondiente al número del elemento en el vector. miVec20 &lt;- c(10, 20, 30, 40, 50, 60, 70, 80, 90) miVec21 &lt;- c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;, &quot;g&quot;, &quot;h&quot;, &quot;i&quot;) print(miVec20) ## [1] 10 20 30 40 50 60 70 80 90 print(miVec21) ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; &quot;i&quot; print(miVec20[1]) ## [1] 10 print(miVec21[3]) ## [1] &quot;c&quot; También podemos usar la combinación de diferentes elementos (otro vector). print(miVec20[c(1, 5, 9)]) ## [1] 10 50 90 print(miVec21[c(4, 3, 1)]) ## [1] &quot;d&quot; &quot;c&quot; &quot;a&quot; print(miVec21[c(4, 4, 3, 4, 3, 2, 5)]) ## [1] &quot;d&quot; &quot;d&quot; &quot;c&quot; &quot;d&quot; &quot;c&quot; &quot;b&quot; &quot;e&quot; También podemos seleccionar elementos usando un operador de comparación o un operador lógico. print(miVec20[miVec20 &gt;= 50]) ## [1] 50 60 70 80 90 print(miVec20[(miVec20 &gt;= 50) &amp; ((miVec20 &lt; 80))]) ## [1] 50 60 70 print(miVec20[miVec20 != 50]) ## [1] 10 20 30 40 60 70 80 90 print(miVec20[miVec20 == 30]) ## [1] 30 print(miVec20[(miVec20 == 30) | (miVec20 == 50)]) ## [1] 30 50 print(miVec21[miVec21 == &quot;a&quot;]) ## [1] &quot;a&quot; Otra característica interesante es la posibilidad de condicionar los elementos a seleccionar en base a otro vector. print(miVec21[miVec20 &gt;= 50]) ## [1] &quot;e&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; &quot;i&quot; print(miVec21[(miVec20 &gt;= 50) &amp; ((miVec20 &lt; 80))]) ## [1] &quot;e&quot; &quot;f&quot; &quot;g&quot; print(miVec21[miVec20 != 50]) ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; &quot;i&quot; print(miVec21[miVec20 == 30]) ## [1] &quot;c&quot; print(miVec21[(miVec20 == 30) | (miVec20 == 50)]) ## [1] &quot;c&quot; &quot;e&quot; print(miVec21[(miVec20 == 30) | (miVec21 == &quot;h&quot;)]) ## [1] &quot;c&quot; &quot;h&quot; También es posible excluir ciertos elementos en lugar de seleccionarlos. print(miVec20[-1]) ## [1] 20 30 40 50 60 70 80 90 print(miVec21[-5]) ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; &quot;i&quot; print(miVec20[-c(1, 2, 5)]) ## [1] 30 40 60 70 80 90 print(miVec21[-c(1, 2, 5)]) ## [1] &quot;c&quot; &quot;d&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; &quot;i&quot; Los elementos de un vector también se pueden seleccionar sobre la base de un vector tipo logical. En este caso, solo se seleccionarán elementos con un valor TRUE. miVec22 &lt;- c(TRUE, TRUE, FALSE, TRUE, FALSE, TRUE, FALSE, TRUE, TRUE) print(miVec21[miVec22]) ## [1] &quot;a&quot; &quot;b&quot; &quot;d&quot; &quot;f&quot; &quot;h&quot; &quot;i&quot; 6.1.4 Dar nombres a los elementos de un vector Los elementos de un vector se pueden nombrar para referenciarlos y luego selectionarlos. La función names() recupera los nombres de los elementos de un vector. miVec23 &lt;- c(aaa = 10, bbb = 20, ccc = 30, ddd = 40, eee = 50) print(miVec23) ## aaa bbb ccc ddd eee ## 10 20 30 40 50 print(miVec23[&quot;bbb&quot;]) ## bbb ## 20 print(miVec23[c(&quot;bbb&quot;, &quot;ccc&quot;, &quot;bbb&quot;)]) ## bbb ccc bbb ## 20 30 20 names(miVec23) ## [1] &quot;aaa&quot; &quot;bbb&quot; &quot;ccc&quot; &quot;ddd&quot; &quot;eee&quot; 6.1.5 Editar los elementos de un vector Para modificar un vector, operamos de la misma manera que para modificar un objeto simple, con el signo &lt;- y el elemento o los elementos a modificar entre corchetes. print(miVec21) ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; &quot;i&quot; miVec21[3] &lt;- &quot;zzz&quot; print(miVec21) ## [1] &quot;a&quot; &quot;b&quot; &quot;zzz&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; &quot;i&quot; miVec21[(miVec20 &gt;= 50) &amp; ((miVec20 &lt; 80))] &lt;- &quot;qwerty&quot; print(miVec21) ## [1] &quot;a&quot; &quot;b&quot; &quot;zzz&quot; &quot;d&quot; &quot;qwerty&quot; &quot;qwerty&quot; &quot;qwerty&quot; &quot;h&quot; ## [9] &quot;i&quot; print(miVec23) ## aaa bbb ccc ddd eee ## 10 20 30 40 50 miVec23[&quot;ccc&quot;] &lt;- miVec23[&quot;ccc&quot;] + 100 print(miVec23) ## aaa bbb ccc ddd eee ## 10 20 130 40 50 También podemos cambiar los nombres asociados con los elementos de un vector. print(miVec23) ## aaa bbb ccc ddd eee ## 10 20 130 40 50 names(miVec23)[2] &lt;- &quot;bb_bb&quot; print(miVec23) ## aaa bb_bb ccc ddd eee ## 10 20 130 40 50 Podemos hacer mucho más con un vector y volveremos a su manejo y operaciones posibles en el capítulo sobre funciones. 6.2 El contenedor list El segundo tipo de contenedor que vamos a presentar es el contenedor list, que es también el segundo contenedor después del tipovector debido a su importancia en la programación con R. El contenedor de tipo list le permite almacenar listas de elementos. Contrariamente a lo que vimos antes con el tipo vector, los elementos del tipo list pueden ser diferentes (por ejemplo, un vector de tipo numeric, luego un vector de tipo character). Los elementos del tipo list también pueden ser contenedores diferentes (por ejemplo, un vector, luego una list). El tipo de contenedor list tendrá mas sentido cuando hayamos estudiado los bucles y funciones de la familia apply. 6.2.1 Crear una list Para crear una list usaremos la función list(), que toma elementos (objetos) como argumentos. miList01 &lt;- list() print(miList01) ## list() miList02 &lt;- list(5, &quot;qwerty&quot;, c(4, 5, 6), c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)) print(miList02) ## [[1]] ## [1] 5 ## ## [[2]] ## [1] &quot;qwerty&quot; ## ## [[3]] ## [1] 4 5 6 ## ## [[4]] ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; miList03 &lt;- list(5, &quot;qwerty&quot;, list(c(4, 5, 6), c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;))) print(miList03) ## [[1]] ## [1] 5 ## ## [[2]] ## [1] &quot;qwerty&quot; ## ## [[3]] ## [[3]][[1]] ## [1] 4 5 6 ## ## [[3]][[2]] ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; La función is.list() se usa para probar si hemos creado un objeto de tipo list. is.list(miList02) ## [1] TRUE typeof(miList02) ## [1] &quot;list&quot; 6.2.2 Acceder a los valores de una list Los elementos del contenedor list son identificables por los corchetes dobles [[ ]]. print(miList02) ## [[1]] ## [1] 5 ## ## [[2]] ## [1] &quot;qwerty&quot; ## ## [[3]] ## [1] 4 5 6 ## ## [[4]] ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; En el objeto de tipo list miList02, hay cuatro elementos identificables con [[1]], [[2]], [[3]] y [[4]]. Cada uno de los elementos es de tipo vector. El primer elemento tiene un tamaño de 1 con elementos del tipo double, el segundo elemento tiene un tamaño de 1 con elementos del tipo character, el tercero elemento tiene un tamaño de 3 con elementos del tipo double, y el cuarto elemento tiene un tamaño de 3 con elementos del tipo character. typeof(miList02) ## [1] &quot;list&quot; print(miList02[[1]]) ## [1] 5 typeof(miList02[[1]]) ## [1] &quot;double&quot; print(miList02[[2]]) ## [1] &quot;qwerty&quot; typeof(miList02[[2]]) ## [1] &quot;character&quot; print(miList02[[3]]) ## [1] 4 5 6 typeof(miList02[[3]]) ## [1] &quot;double&quot; print(miList02[[4]]) ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; typeof(miList02[[4]]) ## [1] &quot;character&quot; El acceso al segundo elemento del vector ubicado en la cuarta posición de la list se hace con miList02[[4]][2]. Usamos doble corchetes para el cuarto elemento de la list, luego corchetes simples para el segundo elemento del vector. print(miList02[[4]][2]) ## [1] &quot;b&quot; Como una list puede contener una o más list, podemos acceder a la información buscada combinando corchetes dobles. El objeto miList04 es una list de dos elementos: la list miList02 y la list miList03. El objeto miList03 en sí contiene una list como tercer elemento. Para acceder al primer elemento del vector en la primera posición del elemento en la tercera posición del segundo elemento del list miList04, podemos usar miList04[[2]][[3]][[1]][1]. No hay límite en cuanto a la profundidad de list pero en la práctica raramente hay necesidad de hacer list de list de list. miList04 &lt;- list(miList02, miList03) print(miList04) ## [[1]] ## [[1]][[1]] ## [1] 5 ## ## [[1]][[2]] ## [1] &quot;qwerty&quot; ## ## [[1]][[3]] ## [1] 4 5 6 ## ## [[1]][[4]] ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; ## ## ## [[2]] ## [[2]][[1]] ## [1] 5 ## ## [[2]][[2]] ## [1] &quot;qwerty&quot; ## ## [[2]][[3]] ## [[2]][[3]][[1]] ## [1] 4 5 6 ## ## [[2]][[3]][[2]] ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; print(miList04[[2]][[3]][[1]][1]) ## [1] 4 Para concretar el ejemplo anterior, podemos imaginar especies de barrenadores del maíz (Sesamia nonagrioides y Ostrinia nubilalis), muestreados en diferentes sitios, con diferentes abundancias en cuatro fechas. Aquí daremos nombres a los elementos de las list. bddInsect &lt;- list(Snonagrioides = list(site01 = c(12, 5, 8, 7), site02 = c(5, 23, 4, 41), site03 = c(12, 0, 0, 0)), Onubilalis = list(site01 = c(12, 1, 2, 3), site02 = c(0, 0, 0, 1), site03 = c(1, 1, 2, 3))) print(bddInsect) ## $Snonagrioides ## $Snonagrioides$site01 ## [1] 12 5 8 7 ## ## $Snonagrioides$site02 ## [1] 5 23 4 41 ## ## $Snonagrioides$site03 ## [1] 12 0 0 0 ## ## ## $Onubilalis ## $Onubilalis$site01 ## [1] 12 1 2 3 ## ## $Onubilalis$site02 ## [1] 0 0 0 1 ## ## $Onubilalis$site03 ## [1] 1 1 2 3 Leer una larga línea de código como la línea para crear el objeto bddInsect resulta difícil porque la profundidad de los elementos solo se puede deducir de los paréntesis. Es por eso que vamos a reorganizar el código para que sea más legible mediante el margen adicional. El margen adicional implica poner información en diferentes niveles para que podamos identificar rápidamente los diferentes niveles de un código. Para aplicar el margen adicional se presiona la tecla de tabulación. Volveremos al margen adicional con más detalles en el capítulo sobre bucles. Recordemos por el momento que si una línea de código es demasiado larga, podemos saltar de línea y usar el margen adicional. R leerá todo como una sola línea de código. bddInsect &lt;- list( Snonagrioides = list( site01 = c(12, 5, 8, 7), site02 = c(5, 23, 4, 41), site03 = c(12, 0, 0, 0) ), Onubilalis = list( site01 = c(12, 1, 2, 3), site02 = c(0, 0, 0, 1), site03 = c(1, 1, 2, 3) ) ) Podemos seleccionar los datos de abundancia del segundo sitio de la primera especie como previamente bddInsect[[1]][[2]], o alternativamente usando los nombres de los elementos bddInsect$Snonagrioides$site02. Para hacer esto usamos el signo $, o como alternativa el nombre de los elementos con comillas simples o dobles bddInsect[['Snonagrioides']][['sitio02']]. print(bddInsect[[1]][[2]]) ## [1] 5 23 4 41 print(bddInsect$Snonagrioides$site02) ## [1] 5 23 4 41 print(bddInsect[[&#39;Snonagrioides&#39;]][[&#39;site02&#39;]]) ## [1] 5 23 4 41 En cuanto a los vectores, podemos recuperar los nombres de los elementos con la función names(). names(bddInsect) ## [1] &quot;Snonagrioides&quot; &quot;Onubilalis&quot; names(bddInsect[[1]]) ## [1] &quot;site01&quot; &quot;site02&quot; &quot;site03&quot; Cuando usamos los corchetes dobles [[]] o el signo $, R devuelve el contenido del elemento seleccionado. En nuestro ejemplo, los datos de abundancia están contenidos como un vector, por lo que R devuelve un elemento del tipo vector. Si queremos seleccionar un elemento de una list pero manteniendo el formato list, entonces podemos usar corchetes simples []. print(bddInsect[[1]][[2]]) ## [1] 5 23 4 41 typeof(bddInsect[[1]][[2]]) ## [1] &quot;double&quot; is.list(bddInsect[[1]][[2]]) ## [1] FALSE print(bddInsect[[1]][2]) ## $site02 ## [1] 5 23 4 41 typeof(bddInsect[[1]][2]) ## [1] &quot;list&quot; is.list(bddInsect[[1]][2]) ## [1] TRUE El uso de corchetes simples [] es útil cuando queremos recuperar varios elementos de una list. Por ejemplo, para seleccionar las abundancias de insectos de los primeros dos sitios de la primera especie, usaremos bddInsect [[1]][c(1, 2)] o alternativamente bddInsect[[1]][c(\"site01\", \"sitio02\")]. print(bddInsect[[1]][c(1, 2)]) ## $site01 ## [1] 12 5 8 7 ## ## $site02 ## [1] 5 23 4 41 print(bddInsect[[1]][c(&quot;site01&quot;, &quot;site02&quot;)]) ## $site01 ## [1] 12 5 8 7 ## ## $site02 ## [1] 5 23 4 41 6.2.3 Editar una list Una list se puede modificar de la misma manera que para el contenedor vector, es decir, haciendo referencia con corchetes al elemento que queremos modificar. print(miList02) ## [[1]] ## [1] 5 ## ## [[2]] ## [1] &quot;qwerty&quot; ## ## [[3]] ## [1] 4 5 6 ## ## [[4]] ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; miList02[[1]] &lt;- 12 print(miList02) ## [[1]] ## [1] 12 ## ## [[2]] ## [1] &quot;qwerty&quot; ## ## [[3]] ## [1] 4 5 6 ## ## [[4]] ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; miList02[[4]] &lt;- c(&quot;d&quot;, &quot;e&quot;, &quot;f&quot;) print(miList02) ## [[1]] ## [1] 12 ## ## [[2]] ## [1] &quot;qwerty&quot; ## ## [[3]] ## [1] 4 5 6 ## ## [[4]] ## [1] &quot;d&quot; &quot;e&quot; &quot;f&quot; miList02[[4]] &lt;- c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, miList02[[4]], &quot;g&quot;, &quot;h&quot;, &quot;i&quot;) print(miList02) ## [[1]] ## [1] 12 ## ## [[2]] ## [1] &quot;qwerty&quot; ## ## [[3]] ## [1] 4 5 6 ## ## [[4]] ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; &quot;i&quot; miList02[[4]][5] &lt;- &quot;eee&quot; print(miList02) ## [[1]] ## [1] 12 ## ## [[2]] ## [1] &quot;qwerty&quot; ## ## [[3]] ## [1] 4 5 6 ## ## [[4]] ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;eee&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; &quot;i&quot; miList02[[3]] &lt;- miList02[[3]] * 10 - 1 print(miList02) ## [[1]] ## [1] 12 ## ## [[2]] ## [1] &quot;qwerty&quot; ## ## [[3]] ## [1] 39 49 59 ## ## [[4]] ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;eee&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; &quot;i&quot; miList02[[3]][2] &lt;- miList02[[1]] * 100 print(miList02) ## [[1]] ## [1] 12 ## ## [[2]] ## [1] &quot;qwerty&quot; ## ## [[3]] ## [1] 39 1200 59 ## ## [[4]] ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;eee&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; &quot;i&quot; print(bddInsect) ## $Snonagrioides ## $Snonagrioides$site01 ## [1] 12 5 8 7 ## ## $Snonagrioides$site02 ## [1] 5 23 4 41 ## ## $Snonagrioides$site03 ## [1] 12 0 0 0 ## ## ## $Onubilalis ## $Onubilalis$site01 ## [1] 12 1 2 3 ## ## $Onubilalis$site02 ## [1] 0 0 0 1 ## ## $Onubilalis$site03 ## [1] 1 1 2 3 bddInsect[[&#39;Snonagrioides&#39;]][[&#39;site02&#39;]] &lt;- c(2, 4, 6, 8) print(bddInsect) ## $Snonagrioides ## $Snonagrioides$site01 ## [1] 12 5 8 7 ## ## $Snonagrioides$site02 ## [1] 2 4 6 8 ## ## $Snonagrioides$site03 ## [1] 12 0 0 0 ## ## ## $Onubilalis ## $Onubilalis$site01 ## [1] 12 1 2 3 ## ## $Onubilalis$site02 ## [1] 0 0 0 1 ## ## $Onubilalis$site03 ## [1] 1 1 2 3 Para combinar dos list, simplemente usamos la función c() que hemos usado para crear un vector. miList0203 &lt;- c(miList02, miList03) print(miList0203) ## [[1]] ## [1] 12 ## ## [[2]] ## [1] &quot;qwerty&quot; ## ## [[3]] ## [1] 39 1200 59 ## ## [[4]] ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;eee&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; &quot;i&quot; ## ## [[5]] ## [1] 5 ## ## [[6]] ## [1] &quot;qwerty&quot; ## ## [[7]] ## [[7]][[1]] ## [1] 4 5 6 ## ## [[7]][[2]] ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; Un objeto de tipo list se puede transformar en vector con la función unlist() si el formato de los elementos de la lista lo permite (un vector solo puede contener elementos del mismo tipo). miList05 &lt;- list(&quot;a&quot;, c(&quot;b&quot;, &quot;c&quot;), &quot;d&quot;) print(miList05) ## [[1]] ## [1] &quot;a&quot; ## ## [[2]] ## [1] &quot;b&quot; &quot;c&quot; ## ## [[3]] ## [1] &quot;d&quot; miVec24 &lt;- unlist(miList05) print(miVec24) ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; miList06 &lt;- list(c(1, 2, 3), c(4, 5, 6, 7), 8, 9, c(10, 11)) print(miList06) ## [[1]] ## [1] 1 2 3 ## ## [[2]] ## [1] 4 5 6 7 ## ## [[3]] ## [1] 8 ## ## [[4]] ## [1] 9 ## ## [[5]] ## [1] 10 11 miVec25 &lt;- unlist(miList06) print(miVec25) ## [1] 1 2 3 4 5 6 7 8 9 10 11 Para agregar un elemento a una list, podemos usar la función c() o los corchetes dobles [[ ]]. print(miList05) ## [[1]] ## [1] &quot;a&quot; ## ## [[2]] ## [1] &quot;b&quot; &quot;c&quot; ## ## [[3]] ## [1] &quot;d&quot; miList05 &lt;- c(miList05, &quot;e&quot;) print(miList05) ## [[1]] ## [1] &quot;a&quot; ## ## [[2]] ## [1] &quot;b&quot; &quot;c&quot; ## ## [[3]] ## [1] &quot;d&quot; ## ## [[4]] ## [1] &quot;e&quot; miList05[[5]] &lt;- c(&quot;fgh&quot;, &quot;ijk&quot;) print(miList05) ## [[1]] ## [1] &quot;a&quot; ## ## [[2]] ## [1] &quot;b&quot; &quot;c&quot; ## ## [[3]] ## [1] &quot;d&quot; ## ## [[4]] ## [1] &quot;e&quot; ## ## [[5]] ## [1] &quot;fgh&quot; &quot;ijk&quot; Para eliminar un elemento de una list, la técnica más rápida es establecer NULL en el elemento que deseamos eliminar. print(miList05) ## [[1]] ## [1] &quot;a&quot; ## ## [[2]] ## [1] &quot;b&quot; &quot;c&quot; ## ## [[3]] ## [1] &quot;d&quot; ## ## [[4]] ## [1] &quot;e&quot; ## ## [[5]] ## [1] &quot;fgh&quot; &quot;ijk&quot; miList05[[2]] &lt;- NULL print(miList05) ## [[1]] ## [1] &quot;a&quot; ## ## [[2]] ## [1] &quot;d&quot; ## ## [[3]] ## [1] &quot;e&quot; ## ## [[4]] ## [1] &quot;fgh&quot; &quot;ijk&quot; 6.3 El contenedor data.frame El contenedor data.frame se puede comparar a una tabla. Este es en realidad un caso especial de list donde todos los elementos de la list tienen el mismo tamaño. 6.3.1 Crear un data.frame Para crear un data.frame usamos la función data.frame() que toma como argumentos los elementos de la tabla que queremos crear. Los elementos son del tipo vector y son todos del mismo tamaño. Podemos dar un nombre a cada columna (vector) de nuestra tabla (data.frame). # crear un data.frame miDf01 &lt;- data.frame( numbers = c(1, 2, 3, 4), logicals = c(TRUE, TRUE, FALSE, TRUE), characters = c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;) ) print(miDf01) ## numbers logicals characters ## 1 1 TRUE a ## 2 2 TRUE b ## 3 3 FALSE c ## 4 4 TRUE d # crear vectores, y el data.frame numbers &lt;- c(1, 2, 3, 4) logicals &lt;- c(TRUE, TRUE, FALSE, TRUE) characters &lt;- c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;) miDf01 &lt;- data.frame(numbers, logicals, characters) print(miDf01) ## numbers logicals characters ## 1 1 TRUE a ## 2 2 TRUE b ## 3 3 FALSE c ## 4 4 TRUE d 6.3.2 Acceder a los elementos de un data.frame El acceso a los diferentes valores de un data.frame se puede hacer de la misma manera que para un contenedor de tipo list. print(miDf01$numbers) # vector ## [1] 1 2 3 4 print(miDf01[[1]]) # vector ## [1] 1 2 3 4 print(miDf01[1]) # list ## numbers ## 1 1 ## 2 2 ## 3 3 ## 4 4 print(miDf01[&quot;numbers&quot;]) # list ## numbers ## 1 1 ## 2 2 ## 3 3 ## 4 4 print(miDf01[[&quot;numbers&quot;]]) # vector ## [1] 1 2 3 4 También podemos usar otra forma que consiste en especificar la línea o las líneas seguidas de una coma (con un espacio después de la coma), y luego la columna o columnas entre corchetes. Si se omite la información de línea o columna, R mostrará todas las líneas o columnas. Nuevamente podemos usar el número correspondiente a un elemento o el nombre del elemento que queremos seleccionar. myRow &lt;- 2 myCol &lt;- 1 print(miDf01[myRow, myCol]) ## [1] 2 print(miDf01[myRow, ]) ## numbers logicals characters ## 2 2 TRUE b print(miDf01[, myCol]) ## [1] 1 2 3 4 myCol &lt;- &quot;numbers&quot; print(miDf01[, myCol]) ## [1] 1 2 3 4 Es posible seleccionar múltiples líneas o columnas. print(miDf01[, c(1, 2)]) ## numbers logicals ## 1 1 TRUE ## 2 2 TRUE ## 3 3 FALSE ## 4 4 TRUE print(miDf01[c(2, 1), ]) ## numbers logicals characters ## 2 2 TRUE b ## 1 1 TRUE a Como cada columna está en formato vector, también podemos hacer una selección que depende del contenido con operadores de comparación y operadores lógicos. miDfSub01 &lt;- miDf01[miDf01$numbers &gt; 2, ] print(miDfSub01) ## numbers logicals characters ## 3 3 FALSE c ## 4 4 TRUE d miDfSub02 &lt;- miDf01[(miDf01$logicals == TRUE) &amp; (miDf01$numbers &lt; 2), ] print(miDfSub02) ## numbers logicals characters ## 1 1 TRUE a miDfSub03 &lt;- miDf01[(miDf01$numbers %% 2) == 0, ] print(miDfSub03) ## numbers logicals characters ## 2 2 TRUE b ## 4 4 TRUE d miDfSub04 &lt;- miDf01[((miDf01$numbers %% 2) == 0) | (miDf01$logicals == TRUE), ] print(miDfSub04) ## numbers logicals characters ## 1 1 TRUE a ## 2 2 TRUE b ## 4 4 TRUE d 6.3.3 Modificar un data.frame Para agregar un elemento a un data.frame, procedemos como para un contenedor de tipo list. Es necesario asegurarse de que el nuevo elemento sea del mismo tamaño que los otros elementos de nuestro data.frame. Por defecto, un nuevo elemento en data.frame toma el nombre de la letra V seguido del número de la columna. Podemos cambiar los nombres de las columnas con la función colnames(). Podemos nombrar las líneas con la función rownames(). newVec &lt;- c(4, 5, 6, 7) miDf01[[4]] &lt;- newVec print(miDf01) ## numbers logicals characters V4 ## 1 1 TRUE a 4 ## 2 2 TRUE b 5 ## 3 3 FALSE c 6 ## 4 4 TRUE d 7 print(colnames(miDf01)) ## [1] &quot;numbers&quot; &quot;logicals&quot; &quot;characters&quot; &quot;V4&quot; colnames(miDf01)[4] &lt;- &quot;newVec&quot; print(miDf01) ## numbers logicals characters newVec ## 1 1 TRUE a 4 ## 2 2 TRUE b 5 ## 3 3 FALSE c 6 ## 4 4 TRUE d 7 print(rownames(miDf01)) ## [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; rownames(miDf01) &lt;- c(&quot;row1&quot;, &quot;row2&quot;, &quot;row3&quot;, &quot;row4&quot;) print(miDf01) ## numbers logicals characters newVec ## row1 1 TRUE a 4 ## row2 2 TRUE b 5 ## row3 3 FALSE c 6 ## row4 4 TRUE d 7 newVec2 &lt;- c(40, 50, 60, 70) miDf01$newVec2 &lt;- newVec2 print(miDf01) ## numbers logicals characters newVec newVec2 ## row1 1 TRUE a 4 40 ## row2 2 TRUE b 5 50 ## row3 3 FALSE c 6 60 ## row4 4 TRUE d 7 70 Como el contenedor de tipo data.frame es un caso especial de list, la selección y modificación se realiza como un contenedor de tipo list. Dado que los elementos de un data.frame son del tipo vector, la selección y la modificación de los elementos de un data.frame se hace como para un contenedor vector. miDf01$newVec2 &lt;- miDf01$newVec2 * 2 print(miDf01) ## numbers logicals characters newVec newVec2 ## row1 1 TRUE a 4 80 ## row2 2 TRUE b 5 100 ## row3 3 FALSE c 6 120 ## row4 4 TRUE d 7 140 miDf01$newVec2 + miDf01$newVec ## [1] 84 105 126 147 miDf01$newVec2[2] &lt;- 0 print(miDf01) ## numbers logicals characters newVec newVec2 ## row1 1 TRUE a 4 80 ## row2 2 TRUE b 5 0 ## row3 3 FALSE c 6 120 ## row4 4 TRUE d 7 140 Un vector se puede transformar en data.frame con la función as.data.frame(). print(newVec2) ## [1] 40 50 60 70 print(as.data.frame(newVec2)) ## newVec2 ## 1 40 ## 2 50 ## 3 60 ## 4 70 is.data.frame(newVec2) ## [1] FALSE is.data.frame(as.data.frame(newVec2)) ## [1] TRUE 6.4 El contenedor matrix El contenedor matrix se puede ver como un vector de dos dimensiones: líneas y columnas. Corresponde a una matriz en matemáticas, y puede contener solo un tipo de datos (logical, numeric, character, ). 6.4.1 Crear una matrix Para crear una matrix primero creamos un vector, luego especificamos el número deseado de líneas y columnas en la función matrix(). vecForMatrix &lt;- c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12) miMat &lt;- matrix(vecForMatrix, nrow = 3, ncol = 4) print(miMat) ## [,1] [,2] [,3] [,4] ## [1,] 1 4 7 10 ## [2,] 2 5 8 11 ## [3,] 3 6 9 12 No tenemos que especificar el número de líneas nrow y el número de columnas ncol. Si usamos uno u otro de estos argumentos, R calculará automáticamente el número correspondiente. miMat &lt;- matrix(vecForMatrix, nrow = 3) print(miMat) ## [,1] [,2] [,3] [,4] ## [1,] 1 4 7 10 ## [2,] 2 5 8 11 ## [3,] 3 6 9 12 miMat &lt;- matrix(vecForMatrix, ncol = 4) print(miMat) ## [,1] [,2] [,3] [,4] ## [1,] 1 4 7 10 ## [2,] 2 5 8 11 ## [3,] 3 6 9 12 Observamos que los diferentes elementos del vector inicial aparecen por columna. Si queremos llenar la matrix empezando por línea, entonces tenemos que dar como valor TRUE al argumento byrow. miMat &lt;- matrix(vecForMatrix, nrow = 3, byrow = TRUE) print(miMat) ## [,1] [,2] [,3] [,4] ## [1,] 1 2 3 4 ## [2,] 5 6 7 8 ## [3,] 9 10 11 12 También podemos dar un nombre a las líneas y columnas de nuestra matrix cuando se crea con el argumento dimnames que toma como valor una list de dos elementos: el nombre de las líneas y luego el nombre de las columnas. También podemos cambiar el nombre de las líneas y columnas a posteriori con las funciones rownames() y colnames(). miMat &lt;- matrix( vecForMatrix, nrow = 3, byrow = TRUE, dimnames = list(c(&quot;r1&quot;, &quot;r2&quot;, &quot;r3&quot;), c(&quot;c1&quot;, &quot;c2&quot;, &quot;c3&quot;, &quot;c4&quot;)) ) print(miMat) ## c1 c2 c3 c4 ## r1 1 2 3 4 ## r2 5 6 7 8 ## r3 9 10 11 12 colnames(miMat) &lt;- c(&quot;col1&quot;, &quot;col2&quot;, &quot;col3&quot;, &quot;col4&quot;) rownames(miMat) &lt;- c(&quot;row1&quot;, &quot;row2&quot;, &quot;row3&quot;) print(miMat) ## col1 col2 col3 col4 ## row1 1 2 3 4 ## row2 5 6 7 8 ## row3 9 10 11 12 Es posible crear una matrix desde un data.frame con la función as.matrix(). Tenemos que verificar que nuestra data.frame contenga solo elementos del mismo tipo (por ejemplo, elementos de tipo numeric). vecForMat01 &lt;- c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12) vecForMat02 &lt;- vecForMat01 * 10 vecForMat03 &lt;- vecForMat01 / 10 dfForMat &lt;- data.frame(vecForMat01, vecForMat02, vecForMat03) print(dfForMat) ## vecForMat01 vecForMat02 vecForMat03 ## 1 1 10 0.1 ## 2 2 20 0.2 ## 3 3 30 0.3 ## 4 4 40 0.4 ## 5 5 50 0.5 ## 6 6 60 0.6 ## 7 7 70 0.7 ## 8 8 80 0.8 ## 9 9 90 0.9 ## 10 10 100 1.0 ## 11 11 110 1.1 ## 12 12 120 1.2 is.matrix(dfForMat) ## [1] FALSE as.matrix(dfForMat) ## vecForMat01 vecForMat02 vecForMat03 ## [1,] 1 10 0.1 ## [2,] 2 20 0.2 ## [3,] 3 30 0.3 ## [4,] 4 40 0.4 ## [5,] 5 50 0.5 ## [6,] 6 60 0.6 ## [7,] 7 70 0.7 ## [8,] 8 80 0.8 ## [9,] 9 90 0.9 ## [10,] 10 100 1.0 ## [11,] 11 110 1.1 ## [12,] 12 120 1.2 is.matrix(as.matrix(dfForMat)) ## [1] TRUE También podemos crear una matrix desde un vector con la función as.matrix() (matriz de una sola columna). as.matrix(vecForMat01) ## [,1] ## [1,] 1 ## [2,] 2 ## [3,] 3 ## [4,] 4 ## [5,] 5 ## [6,] 6 ## [7,] 7 ## [8,] 8 ## [9,] 9 ## [10,] 10 ## [11,] 11 ## [12,] 12 6.4.2 Manipular y hacer operaciones en una matrix Todas las operaciones término a término son posibles con una matrix. # operaciones término a término miMat01 &lt;- matrix(vecForMat01, ncol = 3) miVecOp &lt;- c(1, 10, 100, 1000) miMat01 * miVecOp ## [,1] [,2] [,3] ## [1,] 1 5 9 ## [2,] 20 60 100 ## [3,] 300 700 1100 ## [4,] 4000 8000 12000 miMat01 + miVecOp ## [,1] [,2] [,3] ## [1,] 2 6 10 ## [2,] 12 16 20 ## [3,] 103 107 111 ## [4,] 1004 1008 1012 miMat01 / miMat01 ## [,1] [,2] [,3] ## [1,] 1 1 1 ## [2,] 1 1 1 ## [3,] 1 1 1 ## [4,] 1 1 1 miMat01 - 10 ## [,1] [,2] [,3] ## [1,] -9 -5 -1 ## [2,] -8 -4 0 ## [3,] -7 -3 1 ## [4,] -6 -2 2 Para realizar operaciones algebraicas, podemos usar la función %*%. # operaciones algebraicas miVecConf &lt;- c(1, 10, 100) miMat01 %*% miVecConf ## [,1] ## [1,] 951 ## [2,] 1062 ## [3,] 1173 ## [4,] 1284 miMat02 &lt;- matrix(c(1, 2, 3, 4, 5, 6, 7, 8, 9), ncol = 3) print(miMat02) ## [,1] [,2] [,3] ## [1,] 1 4 7 ## [2,] 2 5 8 ## [3,] 3 6 9 miMat02 %*% miMat02 ## [,1] [,2] [,3] ## [1,] 30 66 102 ## [2,] 36 81 126 ## [3,] 42 96 150 La diagonal de una matrix se puede obtener con la función diag() y el determinante de una matrix con la función det(). print(miMat02) ## [,1] [,2] [,3] ## [1,] 1 4 7 ## [2,] 2 5 8 ## [3,] 3 6 9 diag(miMat02) ## [1] 1 5 9 det(miMat02) ## [1] 0 Suele ser útil poder hacer una transposición de matrix (columnas en líneas o líneas en columnas). Para eso, están las funciones aperm() o t(). la función t() es más genérica y también funciona con data.frame. aperm(miMat01) ## [,1] [,2] [,3] [,4] ## [1,] 1 2 3 4 ## [2,] 5 6 7 8 ## [3,] 9 10 11 12 t(miMat01) ## [,1] [,2] [,3] [,4] ## [1,] 1 2 3 4 ## [2,] 5 6 7 8 ## [3,] 9 10 11 12 6.4.3 Acceder a los elementos de una matrix Tal como hemos hecho con los data.frame, podemos acceder a los elementos de una matrix especificando un número de línea y un número de columna entre corchetes simples [ ], y separados por una coma. Si i es el número de línea y j es el número de columna, entonces miMat01[i, j] devuelve el elemento en la línea i y en la columnaj. miMat01[i,] devuelve todos los elementos de la línea i, y miMat01[, j] todos los elementos de la columna j. Múltiples selecciones son posibles. También podemos acceder a un elemento de acuerdo con su posición en la matrix entre corchetes simples [ ] contando por columna y luego por línea. En nuestro ejemplo, el valor del décimo elemento es 10. i &lt;- 2 j &lt;- 1 print(miMat01[i, j]) ## [1] 2 print(miMat01[i, ]) ## [1] 2 6 10 print(miMat01[, j]) ## [1] 1 2 3 4 print(miMat01[c(1, 2), c(2, 3)]) ## [,1] [,2] ## [1,] 5 9 ## [2,] 6 10 print(miMat01[10]) ## [1] 10 6.5 El contenedor array El contenedor array es una generalización del contenedor de tipo matrix. Donde el tipo matrix tiene dos dimensiones (líneas y columnas), el tipo array tiene un número indefinido de dimensiones. Podemos saber el número de dimensiones de un array (y por lo tanto una matrix) con la función dim(). dim(miMat01) ## [1] 4 3 6.5.1 Crear un array La creación de una array es similar a la de una matrix con una dimensión extra. miVecArr &lt;- c(1, 2, 3, 4, 5, 6, 7, 8, 9) miArray &lt;- array(miVecArr, dim = c(3, 3, 2)) print(miArray) ## , , 1 ## ## [,1] [,2] [,3] ## [1,] 1 4 7 ## [2,] 2 5 8 ## [3,] 3 6 9 ## ## , , 2 ## ## [,1] [,2] [,3] ## [1,] 1 4 7 ## [2,] 2 5 8 ## [3,] 3 6 9 dim(miArray) ## [1] 3 3 2 is.array(miArray) ## [1] TRUE miVecArr02 &lt;- 10 * miVecArr miArray02 &lt;- array(c(miVecArr, miVecArr02), dim = c(3, 3, 2)) print(miArray02) ## , , 1 ## ## [,1] [,2] [,3] ## [1,] 1 4 7 ## [2,] 2 5 8 ## [3,] 3 6 9 ## ## , , 2 ## ## [,1] [,2] [,3] ## [1,] 10 40 70 ## [2,] 20 50 80 ## [3,] 30 60 90 dim(miArray02) ## [1] 3 3 2 is.array(miArray02) ## [1] TRUE Podemos dar nombres a líneas y columnas, pero también a elementos. miArray02 &lt;- array( c(miVecArr, miVecArr02), dim = c(3, 3, 2), dimnames = list( c(&quot;r1&quot;, &quot;r2&quot;, &quot;r3&quot;), c(&quot;c1&quot;, &quot;c2&quot;, &quot;c3&quot;), c(&quot;matrix1&quot;, &quot;matrix2&quot;) ) ) print(miArray02) ## , , matrix1 ## ## c1 c2 c3 ## r1 1 4 7 ## r2 2 5 8 ## r3 3 6 9 ## ## , , matrix2 ## ## c1 c2 c3 ## r1 10 40 70 ## r2 20 50 80 ## r3 30 60 90 6.5.2 Manipular un array La manipulación de un array se hace de la misma manera que para una matrix. Para acceder a los diferentes elementos de un array, simplemente hay que especificar la línea i, la columna j, y la matrix k. i &lt;- 2 j &lt;- 1 k &lt;- 1 print(miArray02[i, j, k]) ## [1] 2 print(miArray02[, j, k]) ## r1 r2 r3 ## 1 2 3 print(miArray02[i, , k]) ## c1 c2 c3 ## 2 5 8 print(miArray02[i, j, ]) ## matrix1 matrix2 ## 2 20 6.6 Conclusión Felicitaciones! Ahora conocemos los principales tipos de objetos que usaremos con R. Un objeto se caracteriza por sus atributos: el tipo de contenedor (vector, data.frame, matrix, array) el tipo de contenido de cada elemento (numeric, logical, character, ) el valor de cada uno de los elementos (5, qwerty, TRUE, ) Todos estos objetos se almacenan temporalmente en el entorno global de R (en la memoria RAM de nuestra computadora). El siguiente capítulo tratará las funciones y resaltará uno de los aspectos que hace que R sea tan poderoso para analizar y administrar nuestros datos. "],["fonctions.html", " 7 Las funciones 7.1 ¿Qué es una función? 7.2 Las funciones más comunes 7.3 Otras funciones útiles 7.4 Algunos ejercicios para practicar 7.5 Escribir una función 7.6 Otras funciones desarrolladas por la comunidad de usuarios: los packages 7.7 Conclusión", " 7 Las funciones 7.1 ¿Qué es una función? Con este capítulo vamos a echar un primer vistazo al poder de R a través de las funciones. Una función es un conjunto de líneas de código para realizar una tarea en particular. Hemos visto muchas funciones en capítulos anteriores, unas simples como la función + para añadir números, o otras más complejas como c() o data.frame() que permiten crear un vector o data.frame. En cualquier caso, se puede reconocer una función gracias a los paréntesis que la siguen en los cuales vamos a ingresar argumentos. Los argumentos corresponden a la información que queremos transmitir a nuestra función para que realice la tarea que queremos lograr. Para funciones simples como +, los paréntesis han sido eliminados para que el código sea más fácil de leer, pero es una función que puede usarse con paréntesis si usamos el signo + entre comillas. Los argumentos son los números que queremos agregar. 5 + 2 ## [1] 7 &#39;+&#39;(5, 2) ## [1] 7 En este capítulo nos enfocaremos en las funciones más comunes. No se trata de aprender todo de memoria, sino de saber que existen estas funciones y de poder consultar más adelante este capítulo como referencia. ¡Con tiempo y práctica eventualmente los sabremos de memoria! Hay más de 1000 funciones en la versión básica de R, y más de 10000 paquetes adicionales que se pueden instalar, cada uno con docenas de funciones. Antes de comenzar a escribir una nueva función, siempre debemos verificar que ya no exista. 7.2 Las funciones más comunes Para trabajar con las funciones, vamos a usar los datos iris que están incluidos con la versión básica de R y que corresponden a la longitud y el ancho de los sépalos y pétalos de diferentes especies de iris. Los datos iris estan en una data.frame de 5 columnas y 150 líneas. Para obtener más información sobre los datos iris, podemos consultar la documentación R con la función help(iris). El acceso a la documentación es el tema de la siguiente sección. 7.2.1 El acceso a la documentación 7.2.1.1 help() La función esencial de R es acceder a la documentación (en ingles). Todas las funciones R tienen documentación. Podemos acceder a la documentación con la función help() o usando el atajo ?. help(matrix) # equivalente a ?matrix La documentación siempre está estructurada de la misma manera. Primero tenemos el nombre de la función buscada matrix, seguida entre llaves por el nombre del paquete R cuya función depende. Veremos cómo instalar paquetes adicionales más adelante. Por ahora tenemos los que vienen con la versión básica de R. Aquí podemos ver que la función matrix() depende del paquete base. Podemos ver la etiqueta de la función (Matrices), seguida de los parafos Description, Usage, y Arguments. Algunas veces se agregan los párrafos Details, Note, References y See also. El último párrafo es Ejemplos. La última línea de la documentación permite volver al índice del paquete del que depende la función consultada. Al copiar help(matrix) en nuestra consola R, podemos ver que el párrafo Description indica lo que hace la función. En el caso de help(matrix), hay tres funciones: matrix(), as.matrix() y is.matrix(). # Description # matrix creates a matrix from the given set of values. # as.matrix attempts to turn its argument into a matrix. # is.matrix tests if its argument is a (strict) matrix. El párrafo Usage explica cómo usar la función y cuáles son los valores predeterminados para cada parámetro. # Usage # matrix(data = NA, nrow = 1, ncol = 1, byrow = FALSE, # dimnames = NULL) La función matrix() puede tomar 5 argumentos: data, nrow, ncol, byrow, y dimnames. Podemos ver que por defecto una matrix consistirá de una sola línea y una sola columna, y que la información se completará por columna. El párrafo Arguments detalla los valores y el tipo de contenedor de cada argumento de nuestra función. Por ejemplo, podemos ver que el argumento dimnames debe ser del tipo list. Es por eso que hemos usado este formato en la sección matrix. # Arguments # data an optional data vector (including a list or expression vector). # Non-atomic classed R objects are coerced by as.vector and all # attributes discarded. # nrow the desired number of rows. # ncol the desired number of columns. # byrow logical. If FALSE (the default) the matrix is filled by columns, # otherwise the matrix is filled by rows. # dimnames A dimnames attribute for the matrix: NULL or a list of length 2 # giving the row and column names respectively. An empty list is # treated as NULL, and a list of length one as row names. The # list can be named, and the list names will be used as names for # the dimensions. El párrafo Details proporciona elementos adicionales en la función. El párrafo Examples proporciona ejemplos reproducibles en la consola. ## Example of setting row and column names mdat &lt;- matrix(c(1,2,3, 11,12,13), nrow = 2, ncol = 3, byrow = TRUE, dimnames = list(c(&quot;row1&quot;, &quot;row2&quot;), c(&quot;C.1&quot;, &quot;C.2&quot;, &quot;C.3&quot;))) mdat ## C.1 C.2 C.3 ## row1 1 2 3 ## row2 11 12 13 El nombre de los argumentos no es necesario para que una función sea interpretada correctamente por R. Sin embargo, es mejor usar explicitamente el nombre de los argumentos seguidos por el signo = para que el código sea más legible. # buen ejemplo mdat &lt;- matrix(c(1, 2, 3, 11, 12, 13), nrow = 2, ncol = 3, byrow = TRUE) # mal ejemplo mdat &lt;- matrix(c(1, 2, 3, 11, 12, 13), 2, 3, TRUE) 7.2.1.2 help.search() La función help.search() o ?? permite buscar una expresión en toda la documentación. Es útil cuando buscamos una función sin saber el nombre exacto de la función en R. help.search(&quot;average&quot;) La función help.search() devuelve una página que contiene la lista de páginas donde se encontró la expresión en la forma package-name::function-name. 7.2.2 Ver los datos 7.2.2.1 str() La función str() permite visualizar la estructura interna de un objeto, como se indica en la documentación que podemos consultar con help(str). str(iris) ## &#39;data.frame&#39;: 150 obs. of 5 variables: ## $ Sepal.Length: num 5.1 4.9 4.7 4.6 5 5.4 4.6 5 4.4 4.9 ... ## $ Sepal.Width : num 3.5 3 3.2 3.1 3.6 3.9 3.4 3.4 2.9 3.1 ... ## $ Petal.Length: num 1.4 1.4 1.3 1.5 1.4 1.7 1.4 1.5 1.4 1.5 ... ## $ Petal.Width : num 0.2 0.2 0.2 0.2 0.2 0.4 0.3 0.2 0.2 0.1 ... ## $ Species : Factor w/ 3 levels &quot;setosa&quot;,&quot;versicolor&quot;,..: 1 1 1 1 1 1 1 1 1 1 ... La función str() devuelve el tipo de objeto (data.frame), el número de observaciones (150), el número de variables (5), el nombre de cada variable (Sepal.Length , Sepal.Width, Petal.Length, Petal.Width, y Species), el tipo de cada variable (num,Factor), y los primeros valores de cada una de las variables. Es una función útil para echar un vistazo a un conjunto de datos, pero también para verificar que los datos sean del tipo requirido antes de realizar un análisis estadístico. 7.2.2.2 head() y tail() La función head() devuelve los primeros valores de un objeto, y la función tail() devuelve los últimos valores de un objeto. Por defecto, se devuelven seis valores, el argumento n controla el número de valores a devolver. head(iris) ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 1 5.1 3.5 1.4 0.2 setosa ## 2 4.9 3.0 1.4 0.2 setosa ## 3 4.7 3.2 1.3 0.2 setosa ## 4 4.6 3.1 1.5 0.2 setosa ## 5 5.0 3.6 1.4 0.2 setosa ## 6 5.4 3.9 1.7 0.4 setosa tail(iris) ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 145 6.7 3.3 5.7 2.5 virginica ## 146 6.7 3.0 5.2 2.3 virginica ## 147 6.3 2.5 5.0 1.9 virginica ## 148 6.5 3.0 5.2 2.0 virginica ## 149 6.2 3.4 5.4 2.3 virginica ## 150 5.9 3.0 5.1 1.8 virginica head(iris, n = 2) ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 1 5.1 3.5 1.4 0.2 setosa ## 2 4.9 3.0 1.4 0.2 setosa 7.2.2.3 names() Ya hemos visto la función names(), que permite conocer los nombres de los elementos de un objeto, pero también asignar nombres a los elementos de un objeto como a un matrix, a una list o a un data.frame. names(iris) ## [1] &quot;Sepal.Length&quot; &quot;Sepal.Width&quot; &quot;Petal.Length&quot; &quot;Petal.Width&quot; &quot;Species&quot; irisCopy &lt;- iris names(irisCopy) &lt;- c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;) names(irisCopy) ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; 7.2.2.4 cat() y print() La función cat() se usa para mostrar el contenido de un objeto mientras que la función print() devuelve el valor de un objeto con la capacidad de realizar conversiones. cat(names(iris)) ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species print(names(iris)) ## [1] &quot;Sepal.Length&quot; &quot;Sepal.Width&quot; &quot;Petal.Length&quot; &quot;Petal.Width&quot; &quot;Species&quot; cat(iris[1, 1]) ## 5.1 print(iris[1, 1]) ## [1] 5.1 print(iris[1, 1], digits = 0) ## [1] 5 7.2.3 Manipular los datos 7.2.3.1 rank() La función rank() devuelve el número de la posición ordenada de cada elemento de un conjunto de elementos. En el caso de elementos del mismo valor, el argumento ties.method hace posible hacer una elección sobre la clasificación. Como con todas las funciones, los detalles están presentes en la documentación. vecManip &lt;- c(10, 20, 30, 70, 60, 50, 40) rank(vecManip) ## [1] 1 2 3 7 6 5 4 vecManip2 &lt;- c(10, 20, 30, 10, 50, 10, 40) rank(vecManip2) ## [1] 2 4 5 2 7 2 6 rank(vecManip2, ties.method = &quot;first&quot;) ## [1] 1 4 5 2 7 3 6 rank(vecManip2, ties.method = &quot;min&quot;) ## [1] 1 4 5 1 7 1 6 print(iris[, 1]) ## [1] 5.1 4.9 4.7 4.6 5.0 5.4 4.6 5.0 4.4 4.9 5.4 4.8 4.8 4.3 5.8 5.7 5.4 5.1 ## [19] 5.7 5.1 5.4 5.1 4.6 5.1 4.8 5.0 5.0 5.2 5.2 4.7 4.8 5.4 5.2 5.5 4.9 5.0 ## [37] 5.5 4.9 4.4 5.1 5.0 4.5 4.4 5.0 5.1 4.8 5.1 4.6 5.3 5.0 7.0 6.4 6.9 5.5 ## [55] 6.5 5.7 6.3 4.9 6.6 5.2 5.0 5.9 6.0 6.1 5.6 6.7 5.6 5.8 6.2 5.6 5.9 6.1 ## [73] 6.3 6.1 6.4 6.6 6.8 6.7 6.0 5.7 5.5 5.5 5.8 6.0 5.4 6.0 6.7 6.3 5.6 5.5 ## [91] 5.5 6.1 5.8 5.0 5.6 5.7 5.7 6.2 5.1 5.7 6.3 5.8 7.1 6.3 6.5 7.6 4.9 7.3 ## [109] 6.7 7.2 6.5 6.4 6.8 5.7 5.8 6.4 6.5 7.7 7.7 6.0 6.9 5.6 7.7 6.3 6.7 7.2 ## [127] 6.2 6.1 6.4 7.2 7.4 7.9 6.4 6.3 6.1 7.7 6.3 6.4 6.0 6.9 6.7 6.9 5.8 6.8 ## [145] 6.7 6.7 6.3 6.5 6.2 5.9 rank(iris[, 1], ties.method = &quot;average&quot;) ## [1] 37.0 19.5 10.5 7.5 27.5 49.5 7.5 27.5 3.0 19.5 49.5 14.0 ## [13] 14.0 1.0 77.0 69.5 49.5 37.0 69.5 37.0 49.5 37.0 7.5 37.0 ## [25] 14.0 27.5 27.5 43.5 43.5 10.5 14.0 49.5 43.5 56.0 19.5 27.5 ## [37] 56.0 19.5 3.0 37.0 27.5 5.0 3.0 27.5 37.0 14.0 37.0 7.5 ## [49] 46.0 27.5 138.0 112.0 135.5 56.0 118.0 69.5 104.0 19.5 121.5 43.5 ## [61] 27.5 82.0 86.5 92.5 62.5 126.5 62.5 77.0 97.5 62.5 82.0 92.5 ## [73] 104.0 92.5 112.0 121.5 132.0 126.5 86.5 69.5 56.0 56.0 77.0 86.5 ## [85] 49.5 86.5 126.5 104.0 62.5 56.0 56.0 92.5 77.0 27.5 62.5 69.5 ## [97] 69.5 97.5 37.0 69.5 104.0 77.0 139.0 104.0 118.0 145.0 19.5 143.0 ## [109] 126.5 141.0 118.0 112.0 132.0 69.5 77.0 112.0 118.0 147.5 147.5 86.5 ## [121] 135.5 62.5 147.5 104.0 126.5 141.0 97.5 92.5 112.0 141.0 144.0 150.0 ## [133] 112.0 104.0 92.5 147.5 104.0 112.0 86.5 135.5 126.5 135.5 77.0 132.0 ## [145] 126.5 126.5 104.0 118.0 97.5 82.0 # help(rank) # ... # Usage # rank(x, na.last = TRUE, # ties.method = c(&quot;average&quot;, &quot;first&quot;, &quot;last&quot;, # &quot;random&quot;, &quot;max&quot;, &quot;min&quot;)) 7.2.3.2 order() La función order() devuelve el número de la reorganización de los elementos en función de su posición. Es muy útil, por ejemplo, para ordenar un data.frame en función de una columna. print(vecManip2) ## [1] 10 20 30 10 50 10 40 rank(vecManip2) ## [1] 2 4 5 2 7 2 6 order(vecManip2) ## [1] 1 4 6 2 3 7 5 print(iris[, 1]) ## [1] 5.1 4.9 4.7 4.6 5.0 5.4 4.6 5.0 4.4 4.9 5.4 4.8 4.8 4.3 5.8 5.7 5.4 5.1 ## [19] 5.7 5.1 5.4 5.1 4.6 5.1 4.8 5.0 5.0 5.2 5.2 4.7 4.8 5.4 5.2 5.5 4.9 5.0 ## [37] 5.5 4.9 4.4 5.1 5.0 4.5 4.4 5.0 5.1 4.8 5.1 4.6 5.3 5.0 7.0 6.4 6.9 5.5 ## [55] 6.5 5.7 6.3 4.9 6.6 5.2 5.0 5.9 6.0 6.1 5.6 6.7 5.6 5.8 6.2 5.6 5.9 6.1 ## [73] 6.3 6.1 6.4 6.6 6.8 6.7 6.0 5.7 5.5 5.5 5.8 6.0 5.4 6.0 6.7 6.3 5.6 5.5 ## [91] 5.5 6.1 5.8 5.0 5.6 5.7 5.7 6.2 5.1 5.7 6.3 5.8 7.1 6.3 6.5 7.6 4.9 7.3 ## [109] 6.7 7.2 6.5 6.4 6.8 5.7 5.8 6.4 6.5 7.7 7.7 6.0 6.9 5.6 7.7 6.3 6.7 7.2 ## [127] 6.2 6.1 6.4 7.2 7.4 7.9 6.4 6.3 6.1 7.7 6.3 6.4 6.0 6.9 6.7 6.9 5.8 6.8 ## [145] 6.7 6.7 6.3 6.5 6.2 5.9 rank(iris[, 1]) ## [1] 37.0 19.5 10.5 7.5 27.5 49.5 7.5 27.5 3.0 19.5 49.5 14.0 ## [13] 14.0 1.0 77.0 69.5 49.5 37.0 69.5 37.0 49.5 37.0 7.5 37.0 ## [25] 14.0 27.5 27.5 43.5 43.5 10.5 14.0 49.5 43.5 56.0 19.5 27.5 ## [37] 56.0 19.5 3.0 37.0 27.5 5.0 3.0 27.5 37.0 14.0 37.0 7.5 ## [49] 46.0 27.5 138.0 112.0 135.5 56.0 118.0 69.5 104.0 19.5 121.5 43.5 ## [61] 27.5 82.0 86.5 92.5 62.5 126.5 62.5 77.0 97.5 62.5 82.0 92.5 ## [73] 104.0 92.5 112.0 121.5 132.0 126.5 86.5 69.5 56.0 56.0 77.0 86.5 ## [85] 49.5 86.5 126.5 104.0 62.5 56.0 56.0 92.5 77.0 27.5 62.5 69.5 ## [97] 69.5 97.5 37.0 69.5 104.0 77.0 139.0 104.0 118.0 145.0 19.5 143.0 ## [109] 126.5 141.0 118.0 112.0 132.0 69.5 77.0 112.0 118.0 147.5 147.5 86.5 ## [121] 135.5 62.5 147.5 104.0 126.5 141.0 97.5 92.5 112.0 141.0 144.0 150.0 ## [133] 112.0 104.0 92.5 147.5 104.0 112.0 86.5 135.5 126.5 135.5 77.0 132.0 ## [145] 126.5 126.5 104.0 118.0 97.5 82.0 order(iris[, 1]) ## [1] 14 9 39 43 42 4 7 23 48 3 30 12 13 25 31 46 2 10 ## [19] 35 38 58 107 5 8 26 27 36 41 44 50 61 94 1 18 20 22 ## [37] 24 40 45 47 99 28 29 33 60 49 6 11 17 21 32 85 34 37 ## [55] 54 81 82 90 91 65 67 70 89 95 122 16 19 56 80 96 97 100 ## [73] 114 15 68 83 93 102 115 143 62 71 150 63 79 84 86 120 139 64 ## [91] 72 74 92 128 135 69 98 127 149 57 73 88 101 104 124 134 137 147 ## [109] 52 75 112 116 129 133 138 55 105 111 117 148 59 76 66 78 87 109 ## [127] 125 141 145 146 77 113 144 53 121 140 142 51 103 110 126 130 108 131 ## [145] 106 118 119 123 136 132 head(iris[order(iris[, 1]),], n = 10) ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 14 4.3 3.0 1.1 0.1 setosa ## 9 4.4 2.9 1.4 0.2 setosa ## 39 4.4 3.0 1.3 0.2 setosa ## 43 4.4 3.2 1.3 0.2 setosa ## 42 4.5 2.3 1.3 0.3 setosa ## 4 4.6 3.1 1.5 0.2 setosa ## 7 4.6 3.4 1.4 0.3 setosa ## 23 4.6 3.6 1.0 0.2 setosa ## 48 4.6 3.2 1.4 0.2 setosa ## 3 4.7 3.2 1.3 0.2 setosa 7.2.3.3 sort() La función sort() se usa para ordenar los elementos de un objeto. No permite la clasificación por más de una variable, como es el caso de order(). print(vecManip2) ## [1] 10 20 30 10 50 10 40 sort(vecManip2) ## [1] 10 10 10 20 30 40 50 print(iris[, 1]) ## [1] 5.1 4.9 4.7 4.6 5.0 5.4 4.6 5.0 4.4 4.9 5.4 4.8 4.8 4.3 5.8 5.7 5.4 5.1 ## [19] 5.7 5.1 5.4 5.1 4.6 5.1 4.8 5.0 5.0 5.2 5.2 4.7 4.8 5.4 5.2 5.5 4.9 5.0 ## [37] 5.5 4.9 4.4 5.1 5.0 4.5 4.4 5.0 5.1 4.8 5.1 4.6 5.3 5.0 7.0 6.4 6.9 5.5 ## [55] 6.5 5.7 6.3 4.9 6.6 5.2 5.0 5.9 6.0 6.1 5.6 6.7 5.6 5.8 6.2 5.6 5.9 6.1 ## [73] 6.3 6.1 6.4 6.6 6.8 6.7 6.0 5.7 5.5 5.5 5.8 6.0 5.4 6.0 6.7 6.3 5.6 5.5 ## [91] 5.5 6.1 5.8 5.0 5.6 5.7 5.7 6.2 5.1 5.7 6.3 5.8 7.1 6.3 6.5 7.6 4.9 7.3 ## [109] 6.7 7.2 6.5 6.4 6.8 5.7 5.8 6.4 6.5 7.7 7.7 6.0 6.9 5.6 7.7 6.3 6.7 7.2 ## [127] 6.2 6.1 6.4 7.2 7.4 7.9 6.4 6.3 6.1 7.7 6.3 6.4 6.0 6.9 6.7 6.9 5.8 6.8 ## [145] 6.7 6.7 6.3 6.5 6.2 5.9 sort(iris[, 1]) ## [1] 4.3 4.4 4.4 4.4 4.5 4.6 4.6 4.6 4.6 4.7 4.7 4.8 4.8 4.8 4.8 4.8 4.9 4.9 ## [19] 4.9 4.9 4.9 4.9 5.0 5.0 5.0 5.0 5.0 5.0 5.0 5.0 5.0 5.0 5.1 5.1 5.1 5.1 ## [37] 5.1 5.1 5.1 5.1 5.1 5.2 5.2 5.2 5.2 5.3 5.4 5.4 5.4 5.4 5.4 5.4 5.5 5.5 ## [55] 5.5 5.5 5.5 5.5 5.5 5.6 5.6 5.6 5.6 5.6 5.6 5.7 5.7 5.7 5.7 5.7 5.7 5.7 ## [73] 5.7 5.8 5.8 5.8 5.8 5.8 5.8 5.8 5.9 5.9 5.9 6.0 6.0 6.0 6.0 6.0 6.0 6.1 ## [91] 6.1 6.1 6.1 6.1 6.1 6.2 6.2 6.2 6.2 6.3 6.3 6.3 6.3 6.3 6.3 6.3 6.3 6.3 ## [109] 6.4 6.4 6.4 6.4 6.4 6.4 6.4 6.5 6.5 6.5 6.5 6.5 6.6 6.6 6.7 6.7 6.7 6.7 ## [127] 6.7 6.7 6.7 6.7 6.8 6.8 6.8 6.9 6.9 6.9 6.9 7.0 7.1 7.2 7.2 7.2 7.3 7.4 ## [145] 7.6 7.7 7.7 7.7 7.7 7.9 7.2.3.4 append() Esta función se usa para agregar un elemento a un vector en una posición determinada por el argumento after. Esta función también es más rápida que su alternativa c(). print(vecManip2) ## [1] 10 20 30 10 50 10 40 append(vecManip2, 5) ## [1] 10 20 30 10 50 10 40 5 append(vecManip2, 5, after = 2) ## [1] 10 20 5 30 10 50 10 40 7.2.3.5 cbind() y rbind() Las funciones cbind() y rbind() permiten combinar elementos por columna o por línea. cbind(vecManip2, vecManip2) ## vecManip2 vecManip2 ## [1,] 10 10 ## [2,] 20 20 ## [3,] 30 30 ## [4,] 10 10 ## [5,] 50 50 ## [6,] 10 10 ## [7,] 40 40 rbind(vecManip2, vecManip2) ## [,1] [,2] [,3] [,4] [,5] [,6] [,7] ## vecManip2 10 20 30 10 50 10 40 ## vecManip2 10 20 30 10 50 10 40 7.2.3.6 paste() y paste0() Estas son dos funciones que usaremos mucho a partir de ahora. Las funciones paste() y paste0() se usan para concatenar cadenas de texto. La función paste0() es equivalente a paste() sin proponer un separador entre los elementos a concatenar. La función paste0() también es más rápida. paste(1, &quot;a&quot;) ## [1] &quot;1 a&quot; paste0(1, &quot;a&quot;) ## [1] &quot;1a&quot; paste(1, &quot;a&quot;, sep = &quot;_&quot;) ## [1] &quot;1_a&quot; paste0(&quot;prefix_&quot;, vecManip2, &quot;_suffix&quot;) ## [1] &quot;prefix_10_suffix&quot; &quot;prefix_20_suffix&quot; &quot;prefix_30_suffix&quot; &quot;prefix_10_suffix&quot; ## [5] &quot;prefix_50_suffix&quot; &quot;prefix_10_suffix&quot; &quot;prefix_40_suffix&quot; paste(vecManip2, rank(vecManip2), sep = &quot;_&quot;) ## [1] &quot;10_2&quot; &quot;20_4&quot; &quot;30_5&quot; &quot;10_2&quot; &quot;50_7&quot; &quot;10_2&quot; &quot;40_6&quot; 7.2.3.7 rev() La función rev () devuelve los elementos de un objeto en orden inverso. print(vecManip2) ## [1] 10 20 30 10 50 10 40 rev(vecManip2) ## [1] 40 10 50 10 30 20 10 7.2.3.8 %in%() La función %in%() se puede comparar con un operador de comparación. Esta función toma dos objetos como argumentos y devuelve TRUE o FALSE para cada elemento del primer objeto de acuerdo con su presencia o ausencia en el segundo objeto. Para acceder a la documentación de la función, use help('%in%') (con comillas simples). print(vecManip) ## [1] 10 20 30 70 60 50 40 print(vecManip2) ## [1] 10 20 30 10 50 10 40 vecManip %in% vecManip2 ## [1] TRUE TRUE TRUE FALSE FALSE TRUE TRUE vecManip2 %in% vecManip ## [1] TRUE TRUE TRUE TRUE TRUE TRUE TRUE 7.2.4 Funciones matemáticas Ya hemos visto las funciones +, -, *, /, ^, %% y otros operadores aritméticos. R también tiene funciones matemáticas básicas como exponencial exp(), raíz cuadrada sqrt(), valor absoluto abs(), sinus sin(), coseno cos(), tangente tan(), logaritmo log(), logaritmo base 10 log10(), arco coseno acos(), arco sinus asin(), y arco tangente atan(). print(vecManip2) ## [1] 10 20 30 10 50 10 40 exp(vecManip2) ## [1] 2.202647e+04 4.851652e+08 1.068647e+13 2.202647e+04 5.184706e+21 ## [6] 2.202647e+04 2.353853e+17 sqrt(vecManip2) ## [1] 3.162278 4.472136 5.477226 3.162278 7.071068 3.162278 6.324555 abs(-vecManip2) ## [1] 10 20 30 10 50 10 40 sin(vecManip2) ## [1] -0.5440211 0.9129453 -0.9880316 -0.5440211 -0.2623749 -0.5440211 0.7451132 cos(vecManip2) ## [1] -0.8390715 0.4080821 0.1542514 -0.8390715 0.9649660 -0.8390715 -0.6669381 tan(vecManip2) ## [1] 0.6483608 2.2371609 -6.4053312 0.6483608 -0.2719006 0.6483608 -1.1172149 log(vecManip2) ## [1] 2.302585 2.995732 3.401197 2.302585 3.912023 2.302585 3.688879 log10(vecManip2) ## [1] 1.000000 1.301030 1.477121 1.000000 1.698970 1.000000 1.602060 acos(vecManip2/100) ## [1] 1.470629 1.369438 1.266104 1.470629 1.047198 1.470629 1.159279 asin(vecManip2/100) ## [1] 0.1001674 0.2013579 0.3046927 0.1001674 0.5235988 0.1001674 0.4115168 atan(vecManip2/100) ## [1] 0.09966865 0.19739556 0.29145679 0.09966865 0.46364761 0.09966865 0.38050638 7.2.5 Estadísticas descriptivas También podemos realizar estadísticas descriptivas de forma muy simple a partir de un conjunto de datos. 7.2.5.1 mean() La función mean() devuelve la media. Para ignorar los valores faltantes NA, hay que afectar el valor TRUE al argumento na.rm(). mean(iris[, 1]) ## [1] 5.843333 vecManip3 &lt;- c(1, 5, 6, 8, NA, 45, NA, 14) mean(vecManip3) ## [1] NA mean(vecManip3, na.rm = TRUE) ## [1] 13.16667 7.2.5.2 sd() La función sd() devuelve la desviación estándar. sd(iris[, 1]) ## [1] 0.8280661 print(vecManip3) ## [1] 1 5 6 8 NA 45 NA 14 sd(vecManip3) ## [1] NA sd(vecManip3, na.rm = TRUE) ## [1] 16.16684 7.2.5.3 max() y min() La función max() devuelve el valor máximo y min() el valor mínimo. max(iris[, 1]) ## [1] 7.9 print(vecManip3) ## [1] 1 5 6 8 NA 45 NA 14 max(vecManip3) ## [1] NA max(vecManip3, na.rm = TRUE) ## [1] 45 min(iris[, 1]) ## [1] 4.3 min(vecManip3) ## [1] NA min(vecManip3, na.rm = TRUE) ## [1] 1 7.2.5.4 quantile() La función quantile() devuelve el cuantil definido por el argumento probs. quantile(iris[, 1]) ## 0% 25% 50% 75% 100% ## 4.3 5.1 5.8 6.4 7.9 quantile(iris[, 1], probs = c(0, 0.25, 0.5, 0.75, 1)) ## 0% 25% 50% 75% 100% ## 4.3 5.1 5.8 6.4 7.9 quantile(iris[, 1], probs = c(0, 0.1, 0.5, 0.9, 1)) ## 0% 10% 50% 90% 100% ## 4.3 4.8 5.8 6.9 7.9 7.2.5.5 summary() La función summary() devuelve un resumen con el mínimo, primer cuartil, mediana, promedio, tercer cuartil y máximo. summary(iris[, 1]) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 4.300 5.100 5.800 5.843 6.400 7.900 7.2.5.6 median() La función median() devuelve la mediana. median(iris[, 1]) ## [1] 5.8 print(vecManip3) ## [1] 1 5 6 8 NA 45 NA 14 median(vecManip3) ## [1] NA median(vecManip3, na.rm = TRUE) ## [1] 7 7.2.5.7 length() La función length() devuelve el tamaño de un objeto (número de elementos). length(iris[, 1]) ## [1] 150 print(vecManip3) ## [1] 1 5 6 8 NA 45 NA 14 length(vecManip3) ## [1] 8 7.2.5.8 nrow() et ncol() La función nrow() devuelve el número de líneas y la función ncol() el número de columnas en un objeto. nrow(iris) ## [1] 150 ncol(iris) ## [1] 5 7.2.5.9 round(), ceiling(), floor(), et trunc() La función round() le permite seleccionar una cierta cantidad de decimales (0 por defecto) round(5.56874258564) ## [1] 6 round(5.56874258564, digits = 2) ## [1] 5.57 La función ceiling() devuelve el entero más pequeño que no es inferior al valor especificado. ceiling(5.9999) ## [1] 6 ceiling(5.0001) ## [1] 6 La función floor() devuelve el entero más grande que no excede el valor especificado. floor(5.9999) ## [1] 5 floor(5.0001) ## [1] 5 La función trunc() devuelve la parte entera del valor especificado. trunc(5.9999) ## [1] 5 trunc(5.0001) ## [1] 5 7.2.5.10 rowSums() et colSums() Las funciones rowSums() y colSums() calculan la suma de filas y columnas. rowSums(iris[, c(1, 2, 3, 4)]) ## [1] 10.2 9.5 9.4 9.4 10.2 11.4 9.7 10.1 8.9 9.6 10.8 10.0 9.3 8.5 11.2 ## [16] 12.0 11.0 10.3 11.5 10.7 10.7 10.7 9.4 10.6 10.3 9.8 10.4 10.4 10.2 9.7 ## [31] 9.7 10.7 10.9 11.3 9.7 9.6 10.5 10.0 8.9 10.2 10.1 8.4 9.1 10.7 11.2 ## [46] 9.5 10.7 9.4 10.7 9.9 16.3 15.6 16.4 13.1 15.4 14.3 15.9 11.6 15.4 13.2 ## [61] 11.5 14.6 13.2 15.1 13.4 15.6 14.6 13.6 14.4 13.1 15.7 14.2 15.2 14.8 14.9 ## [76] 15.4 15.8 16.4 14.9 12.8 12.8 12.6 13.6 15.4 14.4 15.5 16.0 14.3 14.0 13.3 ## [91] 13.7 15.1 13.6 11.6 13.8 14.1 14.1 14.7 11.7 13.9 18.1 15.5 18.1 16.6 17.5 ## [106] 19.3 13.6 18.3 16.8 19.4 16.8 16.3 17.4 15.2 16.1 17.2 16.8 20.4 19.5 14.7 ## [121] 18.1 15.3 19.2 15.7 17.8 18.2 15.6 15.8 16.9 17.6 18.2 20.1 17.0 15.7 15.7 ## [136] 19.1 17.7 16.8 15.6 17.5 17.8 17.4 15.5 18.2 18.2 17.2 15.7 16.7 17.3 15.8 colSums(iris[, c(1, 2, 3, 4)]) ## Sepal.Length Sepal.Width Petal.Length Petal.Width ## 876.5 458.6 563.7 179.9 7.2.5.11 rowMeans() et colMeans() Las funciones rowMeans() y colMeans() calculan el promedio de filas y columnas. rowMeans(iris[, c(1, 2, 3, 4)]) ## [1] 2.550 2.375 2.350 2.350 2.550 2.850 2.425 2.525 2.225 2.400 2.700 2.500 ## [13] 2.325 2.125 2.800 3.000 2.750 2.575 2.875 2.675 2.675 2.675 2.350 2.650 ## [25] 2.575 2.450 2.600 2.600 2.550 2.425 2.425 2.675 2.725 2.825 2.425 2.400 ## [37] 2.625 2.500 2.225 2.550 2.525 2.100 2.275 2.675 2.800 2.375 2.675 2.350 ## [49] 2.675 2.475 4.075 3.900 4.100 3.275 3.850 3.575 3.975 2.900 3.850 3.300 ## [61] 2.875 3.650 3.300 3.775 3.350 3.900 3.650 3.400 3.600 3.275 3.925 3.550 ## [73] 3.800 3.700 3.725 3.850 3.950 4.100 3.725 3.200 3.200 3.150 3.400 3.850 ## [85] 3.600 3.875 4.000 3.575 3.500 3.325 3.425 3.775 3.400 2.900 3.450 3.525 ## [97] 3.525 3.675 2.925 3.475 4.525 3.875 4.525 4.150 4.375 4.825 3.400 4.575 ## [109] 4.200 4.850 4.200 4.075 4.350 3.800 4.025 4.300 4.200 5.100 4.875 3.675 ## [121] 4.525 3.825 4.800 3.925 4.450 4.550 3.900 3.950 4.225 4.400 4.550 5.025 ## [133] 4.250 3.925 3.925 4.775 4.425 4.200 3.900 4.375 4.450 4.350 3.875 4.550 ## [145] 4.550 4.300 3.925 4.175 4.325 3.950 colMeans(iris[, c(1, 2, 3, 4)]) ## Sepal.Length Sepal.Width Petal.Length Petal.Width ## 5.843333 3.057333 3.758000 1.199333 7.2.5.12 aggregate() La función aggregate() permite agrupar los elementos de un objeto de acuerdo con un valor. El argumento by define el elemento sobre el que se realiza la agrupación. Debe ser del tipo list. aggregate(iris[, c(1, 2, 3, 4)], by = list(iris$Species), FUN = mean) ## Group.1 Sepal.Length Sepal.Width Petal.Length Petal.Width ## 1 setosa 5.006 3.428 1.462 0.246 ## 2 versicolor 5.936 2.770 4.260 1.326 ## 3 virginica 6.588 2.974 5.552 2.026 aggregate(iris[, c(1, 2)], by = list(iris$Species), FUN = summary) ## Group.1 Sepal.Length.Min. Sepal.Length.1st Qu. Sepal.Length.Median ## 1 setosa 4.300 4.800 5.000 ## 2 versicolor 4.900 5.600 5.900 ## 3 virginica 4.900 6.225 6.500 ## Sepal.Length.Mean Sepal.Length.3rd Qu. Sepal.Length.Max. Sepal.Width.Min. ## 1 5.006 5.200 5.800 2.300 ## 2 5.936 6.300 7.000 2.000 ## 3 6.588 6.900 7.900 2.200 ## Sepal.Width.1st Qu. Sepal.Width.Median Sepal.Width.Mean Sepal.Width.3rd Qu. ## 1 3.200 3.400 3.428 3.675 ## 2 2.525 2.800 2.770 3.000 ## 3 2.800 3.000 2.974 3.175 ## Sepal.Width.Max. ## 1 4.400 ## 2 3.400 ## 3 3.800 7.2.5.13 range() La función range() devuelve el mínimo y el máximo. range(iris[, 1]) ## [1] 4.3 7.9 print(vecManip3) ## [1] 1 5 6 8 NA 45 NA 14 range(vecManip3) ## [1] NA NA range(vecManip3, na.rm = TRUE) ## [1] 1 45 7.2.5.14 unique() La función unique() devuelve los valores únicos de un objeto (sin duplicados). unique(iris[, 1]) ## [1] 5.1 4.9 4.7 4.6 5.0 5.4 4.4 4.8 4.3 5.8 5.7 5.2 5.5 4.5 5.3 7.0 6.4 6.9 6.5 ## [20] 6.3 6.6 5.9 6.0 6.1 5.6 6.7 6.2 6.8 7.1 7.6 7.3 7.2 7.7 7.4 7.9 print(vecManip3) ## [1] 1 5 6 8 NA 45 NA 14 unique(vecManip3) ## [1] 1 5 6 8 NA 45 14 7.3 Otras funciones útiles No podemos abordar todas las funciones útiles, aquí solo abordaremos ciertas funciones. A lo largo de este libro, se usarán nuevas funciones. Cuando se utiliza una nueva función, nuestro reflejo siempre debe ser el mismo: consultar la documentación con la función help(). 7.3.1 seq_along() La función seq_along() se usa para crear un vector del tamaño del objeto rellenado y tomando como valores los números de 1 a N (N corresponde al número de elementos del objeto). Esta función nos servirá mucho en el capítulo sobre bucles. print(vecManip3) ## [1] 1 5 6 8 NA 45 NA 14 seq_along(vecManip3) ## [1] 1 2 3 4 5 6 7 8 7.3.2 : La función : permite crear una secuencia desde a hacia b por pasos de 1. Ha sido difícil escribir los capítulos anteriores sin usarlo ya que esta función es muy útil. Aquí estan algunos ejemplos. 5:10 ## [1] 5 6 7 8 9 10 head(iris[, c(1, 2, 3, 4)]) ## Sepal.Length Sepal.Width Petal.Length Petal.Width ## 1 5.1 3.5 1.4 0.2 ## 2 4.9 3.0 1.4 0.2 ## 3 4.7 3.2 1.3 0.2 ## 4 4.6 3.1 1.5 0.2 ## 5 5.0 3.6 1.4 0.2 ## 6 5.4 3.9 1.7 0.4 head(iris[, 1:4]) # ;-) ## Sepal.Length Sepal.Width Petal.Length Petal.Width ## 1 5.1 3.5 1.4 0.2 ## 2 4.9 3.0 1.4 0.2 ## 3 4.7 3.2 1.3 0.2 ## 4 4.6 3.1 1.5 0.2 ## 5 5.0 3.6 1.4 0.2 ## 6 5.4 3.9 1.7 0.4 miVec01 &lt;- c(1, 2, 3, 4) miVec01 &lt;- 1:4 # ;-) -10:12 ## [1] -10 -9 -8 -7 -6 -5 -4 -3 -2 -1 0 1 2 3 4 5 6 7 8 ## [20] 9 10 11 12 5:-5 ## [1] 5 4 3 2 1 0 -1 -2 -3 -4 -5 paste(&quot;X&quot;, 1:10, sep = &quot;_&quot;) ## [1] &quot;X_1&quot; &quot;X_2&quot; &quot;X_3&quot; &quot;X_4&quot; &quot;X_5&quot; &quot;X_6&quot; &quot;X_7&quot; &quot;X_8&quot; &quot;X_9&quot; &quot;X_10&quot; 7.3.3 rep() La función rep() permite repetir elementos. miVec12 &lt;- c(1, 1, 1, 1, 1, 1, 1, 1, 1) miVec12 &lt;- rep(1, times = 9) # ;-) rep(&quot;Hola&quot;, times = 3) ## [1] &quot;Hola&quot; &quot;Hola&quot; &quot;Hola&quot; rep(1:3, time = 3) ## [1] 1 2 3 1 2 3 1 2 3 rep(1:3, length.out = 10) ## [1] 1 2 3 1 2 3 1 2 3 1 rep(1:3, each = 3) ## [1] 1 1 1 2 2 2 3 3 3 7.3.4 seq() La función seq() permite crear una secuencia personalizada. seq(from = 0, to = 1, by = 0.2) ## [1] 0.0 0.2 0.4 0.6 0.8 1.0 seq(from = 20, to = 10, length.out = 10) ## [1] 20.00000 18.88889 17.77778 16.66667 15.55556 14.44444 13.33333 12.22222 ## [9] 11.11111 10.00000 letters[seq(from = 1, to = 26, by = 2)] ## [1] &quot;a&quot; &quot;c&quot; &quot;e&quot; &quot;g&quot; &quot;i&quot; &quot;k&quot; &quot;m&quot; &quot;o&quot; &quot;q&quot; &quot;s&quot; &quot;u&quot; &quot;w&quot; &quot;y&quot; rep(seq(from = 1, to = 2, by = 0.5), times = 3) ## [1] 1.0 1.5 2.0 1.0 1.5 2.0 1.0 1.5 2.0 7.3.5 getwd() La función getwd() establece la carpeta de trabajo. Esto corresponde a la ubicación relativa desde la cual R se posiciona para identificar los archivos. Este concepto tendrá sentido cuando veamos cómo importar y exportar datos. getwd() ## [1] &quot;C:/Users/nous/Documents/Francois/GITHUB/myRbook_SP&quot; 7.3.6 setwd() La función setwd() se usa para definir un nuevo directorio de trabajo (carpeta de trabajo). oldWd &lt;- getwd() print(oldWd) ## [1] &quot;C:/Users/nous/Documents/Francois/GITHUB/myRbook_SP&quot; setwd(&quot;..&quot;) getwd() ## [1] &quot;C:/Users/nous/Documents/Francois/GITHUB&quot; setwd(oldWd) getwd() ## [1] &quot;C:/Users/nous/Documents/Francois/GITHUB/myRbook_SP&quot; 7.3.7 list.files() La función list.files () se usa para listar todos los archivos en el directorio de trabajo. list.files(pattern = &quot;(html)$&quot;) # html ## [1] &quot;google_analytics_SP.html&quot; list.files(pattern = &quot;(pdf)$&quot;) # pdf ## character(0) 7.3.8 ls() Al igual que la función list.files() hace posible listar todos los archivos presentes en el directorio de trabajo, la función ls() permite listar todos los objetos presentes en el entorno de trabajo de R. ls() ## [1] &quot;aLogic&quot; &quot;bddInsect&quot; &quot;characters&quot; &quot;dfForMat&quot; &quot;factor01&quot; ## [6] &quot;i&quot; &quot;irisCopy&quot; &quot;j&quot; &quot;k&quot; &quot;logicals&quot; ## [11] &quot;mdat&quot; &quot;miArray&quot; &quot;miArray02&quot; &quot;miDf01&quot; &quot;miDfSub01&quot; ## [16] &quot;miDfSub02&quot; &quot;miDfSub03&quot; &quot;miDfSub04&quot; &quot;miList01&quot; &quot;miList02&quot; ## [21] &quot;miList0203&quot; &quot;miList03&quot; &quot;miList04&quot; &quot;miList05&quot; &quot;miList06&quot; ## [26] &quot;miMat&quot; &quot;miMat01&quot; &quot;miMat02&quot; &quot;miVec01&quot; &quot;miVec02&quot; ## [31] &quot;miVec03&quot; &quot;miVec04&quot; &quot;miVec05&quot; &quot;miVec06&quot; &quot;miVec07&quot; ## [36] &quot;miVec08&quot; &quot;miVec09&quot; &quot;miVec10&quot; &quot;miVec11&quot; &quot;miVec12&quot; ## [41] &quot;miVec13&quot; &quot;miVec14&quot; &quot;miVec15&quot; &quot;miVec20&quot; &quot;miVec21&quot; ## [46] &quot;miVec22&quot; &quot;miVec23&quot; &quot;miVec24&quot; &quot;miVec25&quot; &quot;miVecArr&quot; ## [51] &quot;miVecArr02&quot; &quot;miVecConf&quot; &quot;miVecNA&quot; &quot;miVecOp&quot; &quot;myCol&quot; ## [56] &quot;myRow&quot; &quot;myText&quot; &quot;myText2&quot; &quot;myText3&quot; &quot;myText4&quot; ## [61] &quot;myText5&quot; &quot;nbrRep&quot; &quot;newVec&quot; &quot;newVec2&quot; &quot;numbers&quot; ## [66] &quot;oldWd&quot; &quot;opAriDf&quot; &quot;roundDou&quot; &quot;sumIntDou&quot; &quot;sumIntInt&quot; ## [71] &quot;termino01&quot; &quot;termino02&quot; &quot;vecForMat01&quot; &quot;vecForMat02&quot; &quot;vecForMat03&quot; ## [76] &quot;vecForMatrix&quot; &quot;vecManip&quot; &quot;vecManip2&quot; &quot;vecManip3&quot; zzz &lt;- &quot;a new object&quot; ls() ## [1] &quot;aLogic&quot; &quot;bddInsect&quot; &quot;characters&quot; &quot;dfForMat&quot; &quot;factor01&quot; ## [6] &quot;i&quot; &quot;irisCopy&quot; &quot;j&quot; &quot;k&quot; &quot;logicals&quot; ## [11] &quot;mdat&quot; &quot;miArray&quot; &quot;miArray02&quot; &quot;miDf01&quot; &quot;miDfSub01&quot; ## [16] &quot;miDfSub02&quot; &quot;miDfSub03&quot; &quot;miDfSub04&quot; &quot;miList01&quot; &quot;miList02&quot; ## [21] &quot;miList0203&quot; &quot;miList03&quot; &quot;miList04&quot; &quot;miList05&quot; &quot;miList06&quot; ## [26] &quot;miMat&quot; &quot;miMat01&quot; &quot;miMat02&quot; &quot;miVec01&quot; &quot;miVec02&quot; ## [31] &quot;miVec03&quot; &quot;miVec04&quot; &quot;miVec05&quot; &quot;miVec06&quot; &quot;miVec07&quot; ## [36] &quot;miVec08&quot; &quot;miVec09&quot; &quot;miVec10&quot; &quot;miVec11&quot; &quot;miVec12&quot; ## [41] &quot;miVec13&quot; &quot;miVec14&quot; &quot;miVec15&quot; &quot;miVec20&quot; &quot;miVec21&quot; ## [46] &quot;miVec22&quot; &quot;miVec23&quot; &quot;miVec24&quot; &quot;miVec25&quot; &quot;miVecArr&quot; ## [51] &quot;miVecArr02&quot; &quot;miVecConf&quot; &quot;miVecNA&quot; &quot;miVecOp&quot; &quot;myCol&quot; ## [56] &quot;myRow&quot; &quot;myText&quot; &quot;myText2&quot; &quot;myText3&quot; &quot;myText4&quot; ## [61] &quot;myText5&quot; &quot;nbrRep&quot; &quot;newVec&quot; &quot;newVec2&quot; &quot;numbers&quot; ## [66] &quot;oldWd&quot; &quot;opAriDf&quot; &quot;roundDou&quot; &quot;sumIntDou&quot; &quot;sumIntInt&quot; ## [71] &quot;termino01&quot; &quot;termino02&quot; &quot;vecForMat01&quot; &quot;vecForMat02&quot; &quot;vecForMat03&quot; ## [76] &quot;vecForMatrix&quot; &quot;vecManip&quot; &quot;vecManip2&quot; &quot;vecManip3&quot; &quot;zzz&quot; 7.3.9 rm() La función rm() permite eliminar un objeto presente en el entorno de trabajo de R. rm(zzz) ls() ## [1] &quot;aLogic&quot; &quot;bddInsect&quot; &quot;characters&quot; &quot;dfForMat&quot; &quot;factor01&quot; ## [6] &quot;i&quot; &quot;irisCopy&quot; &quot;j&quot; &quot;k&quot; &quot;logicals&quot; ## [11] &quot;mdat&quot; &quot;miArray&quot; &quot;miArray02&quot; &quot;miDf01&quot; &quot;miDfSub01&quot; ## [16] &quot;miDfSub02&quot; &quot;miDfSub03&quot; &quot;miDfSub04&quot; &quot;miList01&quot; &quot;miList02&quot; ## [21] &quot;miList0203&quot; &quot;miList03&quot; &quot;miList04&quot; &quot;miList05&quot; &quot;miList06&quot; ## [26] &quot;miMat&quot; &quot;miMat01&quot; &quot;miMat02&quot; &quot;miVec01&quot; &quot;miVec02&quot; ## [31] &quot;miVec03&quot; &quot;miVec04&quot; &quot;miVec05&quot; &quot;miVec06&quot; &quot;miVec07&quot; ## [36] &quot;miVec08&quot; &quot;miVec09&quot; &quot;miVec10&quot; &quot;miVec11&quot; &quot;miVec12&quot; ## [41] &quot;miVec13&quot; &quot;miVec14&quot; &quot;miVec15&quot; &quot;miVec20&quot; &quot;miVec21&quot; ## [46] &quot;miVec22&quot; &quot;miVec23&quot; &quot;miVec24&quot; &quot;miVec25&quot; &quot;miVecArr&quot; ## [51] &quot;miVecArr02&quot; &quot;miVecConf&quot; &quot;miVecNA&quot; &quot;miVecOp&quot; &quot;myCol&quot; ## [56] &quot;myRow&quot; &quot;myText&quot; &quot;myText2&quot; &quot;myText3&quot; &quot;myText4&quot; ## [61] &quot;myText5&quot; &quot;nbrRep&quot; &quot;newVec&quot; &quot;newVec2&quot; &quot;numbers&quot; ## [66] &quot;oldWd&quot; &quot;opAriDf&quot; &quot;roundDou&quot; &quot;sumIntDou&quot; &quot;sumIntInt&quot; ## [71] &quot;termino01&quot; &quot;termino02&quot; &quot;vecForMat01&quot; &quot;vecForMat02&quot; &quot;vecForMat03&quot; ## [76] &quot;vecForMatrix&quot; &quot;vecManip&quot; &quot;vecManip2&quot; &quot;vecManip3&quot; 7.4 Algunos ejercicios para practicar Aquí hay algunos ejercicios para mejorar el uso de las funciones y aprender nuevas gracias a la documentación. Algunos ejercicios son difíciles, podremos volver a resolverlos más tarde. 7.4.1 Secuencias 7.4.1.1 Vamos a reproducir las siguientes secuencias: -3 -4 -5 -6 -7 -8 -9 -10 11 -3 -1 1 3 5 7 9 11 3.0 3.2 3.4 3.6 3.8 4.0 20 18 16 14 12 10 8 6 a f k p u z a a a a a f f f f f k k k k k p p p p p u u u u u z z z z z 7.4.1.2 Posibles soluciones (porque siempre hay varias soluciones): -3:-11 ## [1] -3 -4 -5 -6 -7 -8 -9 -10 -11 seq(from = -3, to = 11, by = 2) ## [1] -3 -1 1 3 5 7 9 11 seq(from = 3.0, to = 4.0, by = 0.2) ## [1] 3.0 3.2 3.4 3.6 3.8 4.0 letters[seq(from = 1, to = 26, by = 5)] ## [1] &quot;a&quot; &quot;f&quot; &quot;k&quot; &quot;p&quot; &quot;u&quot; &quot;z&quot; letters[rep(seq(from = 1, to = 26, by = 5), each = 5)] ## [1] &quot;a&quot; &quot;a&quot; &quot;a&quot; &quot;a&quot; &quot;a&quot; &quot;f&quot; &quot;f&quot; &quot;f&quot; &quot;f&quot; &quot;f&quot; &quot;k&quot; &quot;k&quot; &quot;k&quot; &quot;k&quot; &quot;k&quot; &quot;p&quot; &quot;p&quot; &quot;p&quot; &quot;p&quot; ## [20] &quot;p&quot; &quot;u&quot; &quot;u&quot; &quot;u&quot; &quot;u&quot; &quot;u&quot; &quot;z&quot; &quot;z&quot; &quot;z&quot; &quot;z&quot; &quot;z&quot; 7.4.2 Estadísticas descriptivas En el conjunto de datos iris, ¿cuántos valores de ancho del sépalo son mayores que 3? Entre 2.8 y 3.2? ¿Cómo se puede visualizar la distribución de datos (función table())? ¿Cuáles son los 10 valores más pequeños? ¿Cómo se calcula el intervalo que contiene el 90% de los valores? Si la distribución de los datos era Normal, ¿cuál sería el valor teórico de este intervalo del 90% (función qnorm())? Soluciones: length(iris$Sepal.Width[iris$Sepal.Width &gt; 3]) ## [1] 67 length(iris$Sepal.Width[iris$Sepal.Width &gt; 2.8 &amp; iris$Sepal.Width &lt; 3.2]) ## [1] 47 table(iris$Sepal.Width) ## ## 2 2.2 2.3 2.4 2.5 2.6 2.7 2.8 2.9 3 3.1 3.2 3.3 3.4 3.5 3.6 3.7 3.8 3.9 4 ## 1 3 4 3 8 5 9 14 10 26 11 13 6 12 6 4 3 6 2 1 ## 4.1 4.2 4.4 ## 1 1 1 table(round(iris$Sepal.Width)) ## ## 2 3 4 ## 19 106 25 irisSepWCopy &lt;- iris$Sepal.Width irisSepWCopy &lt;- irisSepWCopy[order(irisSepWCopy)] head(irisSepWCopy, n = 10) ## [1] 2.0 2.2 2.2 2.2 2.3 2.3 2.3 2.3 2.4 2.4 quantile(irisSepWCopy, probs = c(0.05, 0.95)) ## 5% 95% ## 2.345 3.800 qnorm( p = c(0.05, 0.95), mean = mean(irisSepWCopy), sd = sd(irisSepWCopy) ) ## [1] 2.340397 3.774270 7.5 Escribir una función Cuando reproducimos las mismas operaciones varias veces, el código se vuelve difícil de escribir y de mantener porque si tenemos que hacer una modificación, tendremos que repetirla cada vez que la usemos. Esto es un signo de la necesidad de usar una función. En el siguiente ejemplo, sera largo modificar el código si queremos agregar +45 en lugar de +20 para cada línea. 35 + 20 ## [1] 55 758 + 20 ## [1] 778 862 + 20 ## [1] 882 782 + 20 ## [1] 802 Como todas las funciones básicas de R, nuestras funciones tendrán un nombre y argumentos. Al igual que con los nombres de los objetos y los nombres de los archivos, es importante elegir bien el nombre de nuestra función (ver la sección sobre objetos). Para crear una función utilizaremos la función function() que toma como argumento los argumentos de nuestra función. La función devolverá el resultado deseado. Por defecto, el resultado devuelto es el último utilizado, pero es mejor usar la función return(). La siguiente función addX() toma como argumento x y devuelve x + 20. addX &lt;- function(x){ return(x + 20) } Nuestro código se convierte en: addX(35) ## [1] 55 addX(758) ## [1] 778 addX(862) ## [1] 882 addX(782) ## [1] 802 Si queremos cambiar el código para agregar 45 en lugar de 20, simplemente cambiamos la función addX(). addX &lt;- function(x){ return(x + 45) } addX(35) ## [1] 80 addX(758) ## [1] 803 addX(862) ## [1] 907 addX(782) ## [1] 827 Aquí podríamos haber usado el formato vector para evitar la repetición, pero eso no siempre es posible. c(35, 758, 862, 782) + 20 ## [1] 55 778 882 802 Vamos a esribir una nueva función que contará el número de consonantes y vocales en minúsculas en una palabra. Primero separaremos todas las letras de la palabra con la función strsplit (podemos consultar la ayuda para saber más acerca de esta función). Luego contaremos las vocales y las consonantes con la función length(). Para la lista de letras, usaremos el objeto letters incluido en R que contiene las 26 letras en minuscula (consulte la ayuda con ?letters). print(letters) # las 26 letras ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; &quot;i&quot; &quot;j&quot; &quot;k&quot; &quot;l&quot; &quot;m&quot; &quot;n&quot; &quot;o&quot; &quot;p&quot; &quot;q&quot; &quot;r&quot; &quot;s&quot; ## [20] &quot;t&quot; &quot;u&quot; &quot;v&quot; &quot;w&quot; &quot;x&quot; &quot;y&quot; &quot;z&quot; countVowelConso &lt;- function(word){ # nombre: countVowelConso ; argumento: word wordSplit &lt;- strsplit(word, split = &quot;&quot;)[[1]] # separar letras de word vowels &lt;- c(&quot;a&quot;, &quot;e&quot;, &quot;i&quot;, &quot;o&quot;, &quot;u&quot;, &quot;y&quot;) # las vocales numVowel &lt;- length(wordSplit[wordSplit %in% vowels]) # numero de vocales consonants &lt;- letters[!letters %in% vowels] # las consonantes numConso &lt;- length(wordSplit[wordSplit %in% consonants]) # numero de consonantes return(c(numVowel, numConso)) # el resultado de la funcion } Ahora podemos usar nuestra función. countVowelConso(word = &quot;qwertyuiop azertyuiop&quot;) ## [1] 11 9 Esta función se puede modificar mostrando un mensaje más explícito. Aunque en general se debe evitar este tipo de mensaje para evitar sobrecargar las funciones, puede ser útil verificar que todo esté funcionando correctamente (luego lo borraremos). countVowelConso &lt;- function(word){ wordSplit &lt;- strsplit(word, split = &quot;&quot;)[[1]] vowels &lt;- c(&quot;a&quot;, &quot;e&quot;, &quot;i&quot;, &quot;o&quot;, &quot;u&quot;, &quot;y&quot;) numVowel &lt;- length(wordSplit[wordSplit %in% vowels]) consonants &lt;- letters[!letters %in% vowels] numConso &lt;- length(wordSplit[wordSplit %in% consonants]) print(paste0(&quot;Hay &quot;, numVowel, &quot; vocales y &quot;, numConso, &quot; consonantes en la palabra &#39;&quot;, word, &quot;&#39;.&quot;)) return(c(numVowel, numConso)) } countVowelConso(word = &quot;qwertyuiop azertyuiop&quot;) ## [1] &quot;Hay 11 vocales y 9 consonantes en la palabra &#39;qwertyuiop azertyuiop&#39;.&quot; ## [1] 11 9 Por otro lado, si usamos countVowelConso(word = 5), se devolverá un error porque nuestra función espera un objeto de tipo character. En general, se recomienda manejar los errores devueltos por nuestras funciones para que nuestro código sea más fácil de mantener. Aquí simplemente comprobaremos que el argumento sea de tipo character, en un vector de tamaño 1. También comentaremos nuestra función para encontrar rápidamente lo que hace (comentario insertado en la primera línea, que a veces encontramos en la última línea de las funciones). countVowelConso &lt;- function(word){ # número de vocales y consonantes if(is.vector(word) &amp; is.character(word) &amp; length(word) == 1){ wordSplit &lt;- strsplit(word, split = &quot;&quot;)[[1]] vowels &lt;- c(&quot;a&quot;, &quot;e&quot;, &quot;i&quot;, &quot;o&quot;, &quot;u&quot;, &quot;y&quot;) numVowel &lt;- length(wordSplit[wordSplit %in% vowels]) consonants &lt;- letters[!letters %in% vowels] numConso &lt;- length(wordSplit[wordSplit %in% consonants]) return(c(numVowel, numConso)) } else { print(paste0(&quot;Error: &quot;, &quot;argumento &#39;word&#39; incorrecto (&quot;, word, &quot;)&quot;)) } } countVowelConso(word = &quot;qwertyuiop azertyuiop&quot;) ## [1] 11 9 countVowelConso(word = 5) ## [1] &quot;Error: argumento &#39;word&#39; incorrecto (5)&quot; Con R como para cualquier lenguaje de programación, para un problema siempre hay múltiples soluciones. Recordamos la sección sobre tipos de datos (tipo de datos logical), así como la sección sobre operadores de comparación que el valor de TRUE es 1 y el valor de FALSE es 0. Hemos visto anteriormente que la función % in% devuelve TRUE o FALSE para cada elemento del primer objeto dependiendo de su presencia o ausencia en el segundo objeto. Nuestra función podría haber usado otra función en lugar de length() para contar vocales y consonantes (función sum()). countVowelConsoAlt &lt;- function(word){ # número de vocales y consonantes if(is.vector(word) &amp; is.character(word) &amp; length(word) == 1){ wordSplit &lt;- strsplit(word, split = &quot;&quot;)[[1]] vowels &lt;- c(&quot;a&quot;, &quot;e&quot;, &quot;i&quot;, &quot;o&quot;, &quot;u&quot;, &quot;y&quot;) numVowel &lt;- sum(wordSplit %in% vowels) # &lt;- cambio aqui consonants &lt;- letters[!letters %in% vowels] numConso &lt;- sum(wordSplit %in% consonants) # &lt;- cambio aqui return(c(numVowel, numConso)) } else { print(paste0(&quot;Error: &quot;, &quot;argumento &#39;word&#39; incorrecto (&quot;, word, &quot;)&quot;)) } } countVowelConsoAlt(word = &quot;qwertyuiop azertyuiop&quot;) ## [1] 11 9 No existe una solución óptima en absoluto, todo depende de los objetivos deseados. La primera solución puede ser más fácil de entender, y la segunda puede ser más rápida en términos de velocidad de ejecución (repitiendo el uso de la función 10000 veces, el ahorro de tiempo es casi cero en nuestro caso). system.time(replicate(n = 10000, countVowelConso(word = &quot;qwertyuiop azertyuiop&quot;))) ## utilisateur système écoulé ## 0.20 0.01 0.22 system.time(replicate(n = 10000, countVowelConsoAlt(word = &quot;qwertyuiop azertyuiop&quot;))) ## utilisateur système écoulé ## 0.17 0.00 0.19 Una función puede tener valores predeterminados para sus argumentos. Este es el caso para la mayoría de las funciones existentes. Por defecto, nuestra función ahora contará el número de vocales y consonantes en la palabra qwerty (los paréntesis son necesarios incluso en ausencia de argumentos). countVowelConsoAlt &lt;- function(word = &quot;qwerty&quot;){ # número de vocales y consonantes if(is.vector(word) &amp; is.character(word) &amp; length(word) == 1){ wordSplit &lt;- strsplit(word, split = &quot;&quot;)[[1]] vowels &lt;- c(&quot;a&quot;, &quot;e&quot;, &quot;i&quot;, &quot;o&quot;, &quot;u&quot;, &quot;y&quot;) numVowel &lt;- sum(wordSplit %in% vowels) consonants &lt;- letters[!letters %in% vowels] numConso &lt;- sum(wordSplit %in% consonants) return(c(numVowel, numConso)) } else { print(paste0(&quot;Error: &quot;, &quot;argumento &#39;word&#39; incorrecto (&quot;, word, &quot;)&quot;)) } } countVowelConsoAlt() # no hay que olvidar los paréntesis ## [1] 2 4 R tiene muchas funciones, por lo tanto, antes de comenzar a escribir una nueva función, siempre debemos verificar que ya no exista en la versión básica de R o en los packages desarrollado por la comunidad de usuarios. Para esto podemos usar la ayuda con la función ??miBusqueda, pero también nuestro navegador de Internet. 7.6 Otras funciones desarrolladas por la comunidad de usuarios: los packages Un package (o paquete) es un conjunto de archivos que agregaremos a R para usar funciones (o conjuntos de datos) que otras personas hayan desarrollado. Actualmente hay más de 10,000 paquetes en los servidores CRAN de R (CRAN; https://cran.r-project.org/web/packages/), más de 1000 en los servidores de BioConductor (para análisis genómicos) y varios cientos en GitHub. Cada paquete hace posible usar nuevas funciones para casi todo  Por lo tanto, puede ser difícil encontrar el paquete adecuado para lo que queremos lograr, y es importante dedicar tiempo a la busqueda del paquete adecuado y probar varios soluciones. Para usar un paquete, primero debemos instalarlo, y luego cargarlo en nuestra sesión R. 7.6.1 Instalar un paquete Una vez que hemos seleccionado nuestro paquete, podemos descargarlo e instalarlo con la función install.packages(), que toma el nombre del paquete entre comillas como argumento (la función tolera la ausencia de comillas, pero es mejor usarlas para que el código sea más legible). Algunos paquetes ya son instalados por defecto con R, como stats (que también se carga de forma predeterminada). install.packages(&quot;stats&quot;) # R statistical functions La instalación de un paquete debe hacerse una vez, luego el paquete está en nuestra computadora. 7.6.2 Cargar un paquete Para poder usar las funciones de un paquete, tenemos que cargarlo en nuestra sesión R. Hay tantos paquetes disponibles que R no cargará todos los que tenemos instalados por defecto, sino solo los que necesitaremos para nuestro estudio actual. Para cargar un paquete usamos la función library() o require(). library(&quot;stats&quot;) La carga del paquete debe hacerse cada vez que queremos ejecutar nuestro código, por lo tanto, es una parte integral de nuestro script. 7.6.3 Portabilidad del código Acabamos de ver que la instalación de un paquete solo se debe hacer una vez por computadora, y que la carga de un paquete se debe lograr para cada nueva sesión de R. Si uno cambia de computadora o si compartimos un script con colegas, puede haber errores de ejecución relacionados con la falta de instalación de un paquete. Para superar este problema, se recomienda utilizar una función que verifique si los paquetes necesarios para ejecutar un script están instalados; si es necesario, instálelos y luego cárguelos. Hay muchas funciones para hacer esto en Internet. La solución que proponemos aquí es una mezcla adaptada de diferentes fuentes. No es necesario comprender los detalles de este script por el momento, sino simplemente comprender lo que hace. Este es un ejemplo para el paquete stats y graphics, dos paquetes que ya estan presente con la versión básica de R, pero podemos tratar todos los paquetes disponibles en CRAN; la lista se puede encontrar aquí: https://cran.r-project.org/web/packages/available_packages_by_name.html. pkgCheck &lt;- function(packages){ for(x in packages){ try(if(!require(x, character.only = TRUE)){ install.packages(x, dependencies = TRUE) if(!require(x, character.only = TRUE)){ stop() } }) } } pkgCheck(c(&quot;stats&quot;, &quot;graphics&quot;)) Alternativamente, podemos usar la función .packages() para listar los paquetes disponibles en el CRAN en orden alfabético. head(.packages(all.available = TRUE), n = 30) ## [1] &quot;abind&quot; &quot;acepack&quot; &quot;ade4&quot; &quot;agricolae&quot; &quot;akima&quot; ## [6] &quot;AlgDesign&quot; &quot;alr4&quot; &quot;aof&quot; &quot;ape&quot; &quot;askpass&quot; ## [11] &quot;assertthat&quot; &quot;backports&quot; &quot;base64enc&quot; &quot;BayesLogit&quot; &quot;bcpa&quot; ## [16] &quot;bdsmatrix&quot; &quot;BH&quot; &quot;bibtex&quot; &quot;bindr&quot; &quot;bindrcpp&quot; ## [21] &quot;BioFTF&quot; &quot;bitops&quot; &quot;blob&quot; &quot;bold&quot; &quot;bookdown&quot; ## [26] &quot;boot&quot; &quot;brew&quot; &quot;brio&quot; &quot;broom&quot; &quot;bslib&quot; La función pkgCheck() asegura la portabilidad de nuestros scripts: funcionarán en todas las computadoras sin tener que realizar ningún cambio. Por lo tanto, nuestros scipts pueden adjuntarse, por ejemplo, a nuestros artículos científicos y así garantizar la reproducibilidad de nuestros resultados. 7.7 Conclusión Felicitaciones! Ahora sabemos reconocer y usar una función, sabemos cómo buscar ayuda para una función e incluso sabemos escribir nuestras propias funciones. También sabemos que hay muchas funciones desarrolladas por la comunidad de usuarios de R dentro de paquetes (packages) que sabemos cómo instalar y cargar, y asegurar la portabilidad de nuestros scripts de una computadora a otra (importante para la reproducibilidad de los resultados). El próximo capítulo se enfocará en leer y escribir archivos porque nuestros datos suelen estar en archivos de texto u hojas de cálculo. "],["import.html", " 8 Importar y exportar datos 8.1 Leer datos de un archivo 8.2 Guardar datos para R 8.3 Exportar datos 8.4 Conclusión", " 8 Importar y exportar datos 8.1 Leer datos de un archivo 8.1.1 Transformar datos en formato TXT o CSV Hay muchas maneras de leer el contenido de un archivo con R. Sin embargo, nos enfocaremos en leer los archivos TXT y CSV que son los más comunes y los más confiables. Con raras excepciones, todos los archivos de datos se pueden transformar fácilmente en formatos TXT y CSV. Esta es la práctica preferida para el análisis de datos con R. En concreto, desde Microsoft Excel, simplemente vamos a Archivo, luego Guardar como, seleccionamos el lugar donde queremos guardar nuestro archivo (hablaremos en el siguiente capítulo sobre la gestión de un proyecto R) y luego en el la ventana de copia de seguridad cambiamos el Tipo desde XLSX hacia CSV. Desde LibreOffice Calc, simplemente vamos a Archivo, luego Guardar como, luego seleccionamos el tipo CSV. Es importante saber que el archivo CSV no admite el formato de archivos de hoja de cálculo con, por ejemplo, colores, y que el archivo CSV contiene solo una pestaña. Si tenemos un archivo de hoja de cálculo con varias pestañas, tendremos que guardar tantos archivos CSV como pestañas. CSV viene del Inglés Comma-separated values (https://es.wikipedia.org/wiki/Valores_separados_por_comas) y representa los datos de hoja de cálculo en un formato de texto separado por comas (o punto y coma según el país). Siempre se puede abrir un archivo CSV con software de hoja de cálculo, pero también con un editor de texto simple como el bloc de notas de Windows o con Notepad++. Es preferible abrir archivos CSV con un editor de texto porque las hojas de cálculo tienden a querer cambiar automáticamente los archivos CSV y esto tiene el efecto de dificultar su lectura. Una vez que se obtiene el archivo TXT o CSV, la lectura del contenido desde R es fácil, aun que requiere un poco de rigor. 8.1.2 Leer un archivo CSV Esta es la fuente de error más común para los principiantes en R. Es por eso que es importante leer y volver a leer este capítulo y lo siguiente sobre la gestión de un proyecto R con mucha atención. R funciona en un directorio definido por defecto. Los usuarios de Rstudio u otro entorno de desarrollo especializado para R intentarán usar las opciones disponibles a través de los menús para establecer su directorio de trabajo o cargar el contenido de un archivo. En este libro, estas técnicas nunca se usarán porque no permiten la reproducibilidad de los resultados. Un script debe poder funcionar para todos los sistemas operativos y sin tener en cuenta el entorno de desarrollo del usuario. El directorio de trabajo por defecto se puede obtener con la función getwd() y cambiar con la función setwd(). oldWd &lt;- getwd() print(oldWd) ## [1] &quot;C:/Users/nous/Documents/Francois/GITHUB/myRbook_SP&quot; setwd(&quot;..&quot;) getwd() ## [1] &quot;C:/Users/nous/Documents/Francois/GITHUB&quot; setwd(oldWd) getwd() ## [1] &quot;C:/Users/nous/Documents/Francois/GITHUB/myRbook_SP&quot; Entonces tenemos cuatro opciones: podemos leer el contenido de un archivo indicando a R su ruta completa (limitacion para la reproducibilidad de los resultados) podemos leer el contenido de un archivo indicando a R su ruta relativa podemos mover el archivo en el directorio de trabajo de R podemos modificar el directorio de trabajo de R para que coincida con la ubicación de nuestro archivo (con su ruta relativa) Un ejemplo de una ruta completa sería: /home/myName/myFile.csv en un entorno UNIX C:/users/myName/myFile.csv bajo un entorno de Windows (tenga cuidado, bajo R utilizamos / y no \\ como es el caso por defecto en Windows) Un camino relativo sería: myName/myFiles.csv Para navegar por las rutas relativas, podemos usar .. que permite volver al directorio de origen. Por ejemplo, si el directorio de trabajo es myScripts y el árbol de mis archivos es: ## -myProject ## |-myFiles ## |-|-data01.csv ## |-|-data02.csv ## |-myScripts ## |-|-myFirstScript.R La ruta relativa al archivo data01.csv sería ../myFiles/data01.csv Entonces, para leer el contenido del archivo data01.csv, privilegiaremos la opción 2 (leer el contenido de un archivo que indicando su ruta relativa) o la opción 4 (modificar el directorio de trabajo de R para que coincida con la ubicación de nuestro archivo). En el último caso: myWD &lt;- &quot;../myFiles/&quot; setwd(myWd) getwd() # para verificar que estamos en el directorio correcto list.files() # para verificar que el archivo está aquí El error más común: ## Error in setwd(&quot;../myFiles/&quot;) : ## no se puede cambiar el directorio de trabajo Esto significa que el directorio no existe (se debe verificar que la sintaxis sea correcta y que el directorio exista con esta ruta). Una vez que el directorio de trabajo está definido correctamente o la ruta relativa al archivo está establecida correctamente, podemos leer el archivo con la función read.table(). Algunos usan la función read.csv() pero este es solo un caso especial de read.table(). myWD &lt;- &quot;../myFiles/&quot; setwd(myWd) read.table(file = &quot;data01.csv&quot;) o alternativamente: read.table(file = &quot;../myFiles/data01.csv&quot;) Si la ruta no se llena correctamente o si el archivo de datos no existe, R devolverá el siguiente error: ## Error in file(file, &quot;rt&quot;) : incapaz de abrir la conexión ## De más : Warning message: ## In file(file, &quot;rt&quot;) : ## incapaz de abrir el archivo &#39;../myFiles/data01.csv&#39; : No such file or directory Si todo está bien, R muestra el contenido del archivo data01.csv. Advertencia a los usuarios de Windows porque por defecto no aparece la extensión de los archivos Así que cuando navegamos a través de directorios con el explorador de archivos, no hay data01.csv, pero sólo un archivo data01. Es esencial remediar este problema para evitar errores. Para hacer esto, simplemente abrimos las Opciones del Explorador de archivos a través de la tecla Windows, luego en la pestaña Ver, verificamos que la opción Ocultar extensiones de archivos cuyo tipo es conocido no está marcado. Consultando la ayuda sobre la función read.table(), podemos ver que tiene muchos argumentos. Los principales son: header = FALSE: ¿el archivo contiene nombres de columna? Si es así, cambiamos el valor a header = TRUE sep =\" \": ¿cómo se separan los datos de la tabla? En un archivo CSV es la coma o el punto y coma, así que cambiamos a sep = \",\" o sep = \";\" dec =\". \": ¿cuál es el separador de los números decimales? Si es la coma, entonces debes cambiar a dec = \",\" Con estos tres argumentos, la mayoría de los archivos se pueden leer sin ningún problema. En caso de necesidad, la ayuda de esta función es muy completa. La función read.table () devuelve el contenido del archivo como data.frame. Para poder usar el contenido del archivo, almacenaremos el data.frame en un objeto. myWD &lt;- &quot;../myFiles/&quot; setwd(myWd) data01 &lt;- read.table(file = &quot;data01.csv&quot;) str(data01) # verificar el formato de los datos head(data01) # vverificar los primeros datos El estudio de caso sobre el análisis de datos de datalogger se basa en un archivo CSV. Aquí hay un extracto: bdd &lt;- read.table(&quot;myFiles/E05C13.csv&quot;, skip = 1, header = TRUE, sep = &quot;,&quot;, dec = &quot;.&quot;, stringsAsFactors = FALSE) colnames(bdd) &lt;- c(&quot;id&quot;, &quot;date&quot;, &quot;temp&quot;) head(bdd) ## id date temp ## 1 1 11/12/15 23:00:00 4.973 ## 2 2 11/12/15 23:30:00 4.766 ## 3 3 11/13/15 00:00:00 4.844 ## 4 4 11/13/15 00:30:00 4.844 ## 5 5 11/13/15 01:00:00 5.076 ## 6 6 11/13/15 01:30:00 5.282 tail(bdd) ## id date temp ## 32781 32781 09/25/17 21:00:00 7.091 ## 32782 32782 09/25/17 21:30:00 6.914 ## 32783 32783 09/25/17 22:00:00 6.813 ## 32784 32784 09/25/17 22:30:00 6.611 ## 32785 32785 09/25/17 23:00:00 6.331 ## 32786 32786 09/25/17 23:30:00 5.385 str(bdd) ## &#39;data.frame&#39;: 32786 obs. of 3 variables: ## $ id : int 1 2 3 4 5 6 7 8 9 10 ... ## $ date: chr &quot;11/12/15 23:00:00&quot; &quot;11/12/15 23:30:00&quot; &quot;11/13/15 00:00:00&quot; &quot;11/13/15 00:30:00&quot; ... ## $ temp: num 4.97 4.77 4.84 4.84 5.08 ... 8.1.3 Leer un archivo de texto La función más simple para leer un archivo que contiene texto es readlines(). Aquí hay un ejemplo con el archivo README.md de este libro, que se encuentra en GitHub. readmeGitHub &lt;- &quot;https://raw.githubusercontent.com/frareb/myRBook_SP/master/README.md&quot; readLines(readmeGitHub) ## [1] &quot;# myRBook_SP&quot; ## [2] &quot;Aqui se encuentra el cÃ³digo fuente del libro *Aprender R: iniciaciÃ³n y perfeccionamiento*, construido con bookdown.&quot; ## [3] &quot;&quot; ## [4] &quot;Este libro estÃ¡ diseÃ±ado para actualizarse de acuerdo con las nuevas caracterÃ­sticas de R y segÃºn la disponibilidad de sus colaboradores. Es un libro de colaboraciÃ³n, asÃ­ que siÃ©ntase libre de compartir sus comentarios o colaborar directamente para mejorarlo.&quot; ## [5] &quot;&quot; ## [6] &quot;Si tiene algÃºn comentario, sugerencia o si identifica errores, no dude en enviarme un correo electrÃ³nico (francois.rebaudo@ird.fr), o si estÃ¡ familiarizado con GitHub en el sitio web del proyecto (https://github.com/frareb/myRBook_SP). Este libro es colaborativo, se basa en su participaciÃ³n.&quot; ## [7] &quot;&quot; ## [8] &quot;Este libro tambiÃ©n estÃ¡ disponible en francÃ©s (http://myrbookfr.netlify.com/). MÃ¡s allÃ¡ de este libro, puede acceder a las diapositivas del [Ãºltimo curso de R realizado en marzo de 2019 en Quito, Ecuador](http://myrbooksp.netlify.com/myHtmls/Ecuador_Quito_2019/R00_links.html).&quot; ## [9] &quot;&quot; ## [10] &quot;## Ãltimas modificaciones&quot; ## [11] &quot;&quot; ## [12] &quot;**31/05/2020**&quot; ## [13] &quot;&quot; ## [14] &quot;* modificaciones menores &quot; ## [15] &quot;&quot; ## [16] &quot;**12/12/2019**&quot; ## [17] &quot;&quot; ## [18] &quot;* De la grÃ¡fica a la figura en un artÃ­culo cientÃ­fico&quot; ## [19] &quot;&quot; ## [20] &quot;**10/04/2019**&quot; ## [21] &quot;&quot; ## [22] &quot;* Modificaciones en el estudio de caso: [dataloggers](#studyCase1)&quot; ## [23] &quot;&quot; ## [24] &quot;**28/03/2019**&quot; ## [25] &quot;&quot; ## [26] &quot;* diapositivas del [curso de R en Quito - Ecuador](http://myrbooksp.netlify.com/myHtmls/Ecuador_Quito_2019/R00_links.html)&quot; ## [27] &quot;&quot; ## [28] &quot;**22/01/2019**&quot; ## [29] &quot;&quot; ## [30] &quot;* CapÃ­tulo [Paquetes grÃ¡ficos](#graph3) &quot; ## [31] &quot;&quot; ## [32] &quot;**10/12/2018**&quot; ## [33] &quot;&quot; ## [34] &quot;* CapÃ­tulo [GestiÃ³n del color](#graph2) &quot; ## [35] &quot;&quot; ## [36] &quot;**29/11/2018**&quot; ## [37] &quot;&quot; ## [38] &quot;* CapÃ­tulo [GrÃ¡ficos simples](#graph1) &quot; ## [39] &quot;&quot; ## [40] &quot;**09/11/2018**&quot; ## [41] &quot;&quot; ## [42] &quot;* CapÃ­tulo [GestiÃ³n de proyectos con R](#project)&quot; ## [43] &quot;* La primera parte de este libro sobre conceptos bÃ¡sicos estÃ¡ completa&quot; ## [44] &quot;&quot; ## [45] &quot;**08/11/2018**&quot; ## [46] &quot;&quot; ## [47] &quot;* algorÃ­tmico (5/6) [`next` y `break`](#l17spe)&quot; ## [48] &quot;* algorÃ­tmico (6/6) [Los bucles de la familia `apply`](#l17applyfamily)&quot; ## [49] &quot;&quot; ## [50] &quot;**19/10/2018**&quot; ## [51] &quot;&quot; ## [52] &quot;* algorÃ­tmico (3/6) [el bucle `for`](#l17for)&quot; ## [53] &quot;* algorÃ­tmico (4/6) [el bucle `while`](#l17while)&quot; ## [54] &quot;* algorÃ­tmico (4&#39;/6) [el bucle `repeat`](#l17repeat)&quot; ## [55] &quot;&quot; ## [56] &quot;**28/09/2018**&quot; ## [57] &quot;&quot; ## [58] &quot;* algorÃ­tmico (1/6) [Pruebas lÃ³gicas con `if`](#l17if)&quot; ## [59] &quot;* algorÃ­tmico (2/6) [Pruebas lÃ³gicas con `switch`](#l17switch)&quot; ## [60] &quot;&quot; ## [61] &quot;**17/09/2018**&quot; ## [62] &quot;&quot; ## [63] &quot;* IntroducciÃ³n&quot; ## [64] &quot;&quot; ## [65] &quot;**10/09/2018**&quot; ## [66] &quot;&quot; ## [67] &quot;* Importar y exportar datos (parte 2-3/3): [Guardar y exportar datos](#l016save)&quot; ## [68] &quot;&quot; ## [69] &quot;**06/09/2018**&quot; ## [70] &quot;&quot; ## [71] &quot;* Importar y exportar datos (parte 1/3): [Leer datos desde un archivo](#l016read)&quot; ## [72] &quot;&quot; ## [73] &quot;**30/08/2018**&quot; ## [74] &quot;&quot; ## [75] &quot;* Nuevo estudio de caso: [dataloggers](#studyCase1)&quot; ## [76] &quot;* Modificaciones de Marc G. sobre el [tipo de datos numeric](#dataType1) y los [entornos de desarrollo](#IDE)&quot; ## [77] &quot;&quot; ## [78] &quot;**24/08/2018**&quot; ## [79] &quot;&quot; ## [80] &quot;* CapÃ­tulo sobre [las funciones (3/3)](#fonctions)&quot; ## [81] &quot;&quot; ## [82] &quot;**27/07/2018**&quot; ## [83] &quot;&quot; ## [84] &quot;* CapÃ­tulo sobre [las funciones (2/3)](#fonctions)&quot; ## [85] &quot;&quot; ## [86] &quot;**25/07/2018**&quot; ## [87] &quot;&quot; ## [88] &quot;* CapÃ­tulo sobre [las funciones (1/3)](#fonctions)&quot; ## [89] &quot;&quot; ## [90] &quot;**17/07/2018**&quot; ## [91] &quot;&quot; ## [92] &quot;* ediciÃ³n y correcciÃ³n del espaÃ±ol (Susi L.) &quot; ## [93] &quot;* tercera parte del capÃ­tulo [*Contenedores de datos*](#dataType2): El contenedor [*data.frame*](#l014dataframe)&quot; ## [94] &quot;* cuarta parte del capÃ­tulo [*Contenedores de datos*](#dataType2): El contenedor [*matrix*](#l014matrix)&quot; ## [95] &quot;* quinta parte del capÃ­tulo [*Contenedores de datos*](#dataType2): El contenedor [*array*](#l014array)&quot; ## [96] &quot;&quot; ## [97] &quot;**16/07/2018**&quot; ## [98] &quot;&quot; ## [99] &quot;* ediciÃ³n y correcciÃ³n del espaÃ±ol (EstefanÃ­a Q.) &quot; ## [100] &quot;&quot; ## [101] &quot;**12/07/2018**&quot; ## [102] &quot;&quot; ## [103] &quot;* segunda parte del capÃ­tulo [*Contenedores de datos*](#dataType2): El contenedor [*list*](#l014list)&quot; ## [104] &quot;&quot; ## [105] &quot;**06/07/2018**&quot; ## [106] &quot;&quot; ## [107] &quot;* ediciÃ³n y correcciÃ³n del espaÃ±ol (Camila B.) &quot; ## [108] &quot;* primera parte del capÃ­tulo [*Contenedores de datos*](#dataType2): El contenedor [*vector*](#l014vector)&quot; ## [109] &quot;&quot; ## [110] &quot;**04/07/2018**&quot; ## [111] &quot;&quot; ## [112] &quot;* tabla de contenidos con los prÃ³ximos capÃ­tulos&quot; ## [113] &quot;* error de tipografÃ­a en *Elegir un entorno de desarrollo*&quot; ## [114] &quot;&quot; ## [115] &quot;**02/07/2018**&quot; ## [116] &quot;&quot; ## [117] &quot;* tres capÃ­tulos en lÃ­nea (*primeros pasos*, *elegir un entorno de desarrollo*, *tipos de datos*)&quot; También está la función scan() que devolve todas las palabras separadas por espacios. Podemos consultar la ayuda para obtener más información. scan(readmeGitHub, what = &quot;character&quot;) ## [1] &quot;#&quot; ## [2] &quot;myRBook_SP&quot; ## [3] &quot;Aqui&quot; ## [4] &quot;se&quot; ## [5] &quot;encuentra&quot; ## [6] &quot;el&quot; ## [7] &quot;cÃ³digo&quot; ## [8] &quot;fuente&quot; ## [9] &quot;del&quot; ## [10] &quot;libro&quot; ## [11] &quot;*Aprender&quot; ## [12] &quot;R:&quot; ## [13] &quot;iniciaciÃ³n&quot; ## [14] &quot;y&quot; ## [15] &quot;perfeccionamiento*,&quot; ## [16] &quot;construido&quot; ## [17] &quot;con&quot; ## [18] &quot;bookdown.&quot; ## [19] &quot;Este&quot; ## [20] &quot;libro&quot; ## [21] &quot;estÃ¡&quot; ## [22] &quot;diseÃ±ado&quot; ## [23] &quot;para&quot; ## [24] &quot;actualizarse&quot; ## [25] &quot;de&quot; ## [26] &quot;acuerdo&quot; ## [27] &quot;con&quot; ## [28] &quot;las&quot; ## [29] &quot;nuevas&quot; ## [30] &quot;caracterÃ­sticas&quot; ## [31] &quot;de&quot; ## [32] &quot;R&quot; ## [33] &quot;y&quot; ## [34] &quot;segÃºn&quot; ## [35] &quot;la&quot; ## [36] &quot;disponibilidad&quot; ## [37] &quot;de&quot; ## [38] &quot;sus&quot; ## [39] &quot;colaboradores.&quot; ## [40] &quot;Es&quot; ## [41] &quot;un&quot; ## [42] &quot;libro&quot; ## [43] &quot;de&quot; ## [44] &quot;colaboraciÃ³n,&quot; ## [45] &quot;asÃ­&quot; ## [46] &quot;que&quot; ## [47] &quot;siÃ©ntase&quot; ## [48] &quot;libre&quot; ## [49] &quot;de&quot; ## [50] &quot;compartir&quot; ## [51] &quot;sus&quot; ## [52] &quot;comentarios&quot; ## [53] &quot;o&quot; ## [54] &quot;colaborar&quot; ## [55] &quot;directamente&quot; ## [56] &quot;para&quot; ## [57] &quot;mejorarlo.&quot; ## [58] &quot;Si&quot; ## [59] &quot;tiene&quot; ## [60] &quot;algÃºn&quot; ## [61] &quot;comentario,&quot; ## [62] &quot;sugerencia&quot; ## [63] &quot;o&quot; ## [64] &quot;si&quot; ## [65] &quot;identifica&quot; ## [66] &quot;errores,&quot; ## [67] &quot;no&quot; ## [68] &quot;dude&quot; ## [69] &quot;en&quot; ## [70] &quot;enviarme&quot; ## [71] &quot;un&quot; ## [72] &quot;correo&quot; ## [73] &quot;electrÃ³nico&quot; ## [74] &quot;(francois.rebaudo@ird.fr),&quot; ## [75] &quot;o&quot; ## [76] &quot;si&quot; ## [77] &quot;estÃ¡&quot; ## [78] &quot;familiarizado&quot; ## [79] &quot;con&quot; ## [80] &quot;GitHub&quot; ## [81] &quot;en&quot; ## [82] &quot;el&quot; ## [83] &quot;sitio&quot; ## [84] &quot;web&quot; ## [85] &quot;del&quot; ## [86] &quot;proyecto&quot; ## [87] &quot;(https://github.com/frareb/myRBook_SP).&quot; ## [88] &quot;Este&quot; ## [89] &quot;libro&quot; ## [90] &quot;es&quot; ## [91] &quot;colaborativo,&quot; ## [92] &quot;se&quot; ## [93] &quot;basa&quot; ## [94] &quot;en&quot; ## [95] &quot;su&quot; ## [96] &quot;participaciÃ³n.&quot; ## [97] &quot;Este&quot; ## [98] &quot;libro&quot; ## [99] &quot;tambiÃ©n&quot; ## [100] &quot;estÃ¡&quot; ## [101] &quot;disponible&quot; ## [102] &quot;en&quot; ## [103] &quot;francÃ©s&quot; ## [104] &quot;(http://myrbookfr.netlify.com/).&quot; ## [105] &quot;MÃ¡s&quot; ## [106] &quot;allÃ¡&quot; ## [107] &quot;de&quot; ## [108] &quot;este&quot; ## [109] &quot;libro,&quot; ## [110] &quot;puede&quot; ## [111] &quot;acceder&quot; ## [112] &quot;a&quot; ## [113] &quot;las&quot; ## [114] &quot;diapositivas&quot; ## [115] &quot;del&quot; ## [116] &quot;[Ãºltimo&quot; ## [117] &quot;curso&quot; ## [118] &quot;de&quot; ## [119] &quot;R&quot; ## [120] &quot;realizado&quot; ## [121] &quot;en&quot; ## [122] &quot;marzo&quot; ## [123] &quot;de&quot; ## [124] &quot;2019&quot; ## [125] &quot;en&quot; ## [126] &quot;Quito,&quot; ## [127] &quot;Ecuador](http://myrbooksp.netlify.com/myHtmls/Ecuador_Quito_2019/R00_links.html).&quot; ## [128] &quot;##&quot; ## [129] &quot;Ãltimas&quot; ## [130] &quot;modificaciones&quot; ## [131] &quot;**31/05/2020**&quot; ## [132] &quot;*&quot; ## [133] &quot;modificaciones&quot; ## [134] &quot;menores&quot; ## [135] &quot;**12/12/2019**&quot; ## [136] &quot;*&quot; ## [137] &quot;De&quot; ## [138] &quot;la&quot; ## [139] &quot;grÃ¡fica&quot; ## [140] &quot;a&quot; ## [141] &quot;la&quot; ## [142] &quot;figura&quot; ## [143] &quot;en&quot; ## [144] &quot;un&quot; ## [145] &quot;artÃ­culo&quot; ## [146] &quot;cientÃ­fico&quot; ## [147] &quot;**10/04/2019**&quot; ## [148] &quot;*&quot; ## [149] &quot;Modificaciones&quot; ## [150] &quot;en&quot; ## [151] &quot;el&quot; ## [152] &quot;estudio&quot; ## [153] &quot;de&quot; ## [154] &quot;caso:&quot; ## [155] &quot;[dataloggers](#studyCase1)&quot; ## [156] &quot;**28/03/2019**&quot; ## [157] &quot;*&quot; ## [158] &quot;diapositivas&quot; ## [159] &quot;del&quot; ## [160] &quot;[curso&quot; ## [161] &quot;de&quot; ## [162] &quot;R&quot; ## [163] &quot;en&quot; ## [164] &quot;Quito&quot; ## [165] &quot;-&quot; ## [166] &quot;Ecuador](http://myrbooksp.netlify.com/myHtmls/Ecuador_Quito_2019/R00_links.html)&quot; ## [167] &quot;**22/01/2019**&quot; ## [168] &quot;*&quot; ## [169] &quot;CapÃ­tulo&quot; ## [170] &quot;[Paquetes&quot; ## [171] &quot;grÃ¡ficos](#graph3)&quot; ## [172] &quot;**10/12/2018**&quot; ## [173] &quot;*&quot; ## [174] &quot;CapÃ­tulo&quot; ## [175] &quot;[GestiÃ³n&quot; ## [176] &quot;del&quot; ## [177] &quot;color](#graph2)&quot; ## [178] &quot;**29/11/2018**&quot; ## [179] &quot;*&quot; ## [180] &quot;CapÃ­tulo&quot; ## [181] &quot;[GrÃ¡ficos&quot; ## [182] &quot;simples](#graph1)&quot; ## [183] &quot;**09/11/2018**&quot; ## [184] &quot;*&quot; ## [185] &quot;CapÃ­tulo&quot; ## [186] &quot;[GestiÃ³n&quot; ## [187] &quot;de&quot; ## [188] &quot;proyectos&quot; ## [189] &quot;con&quot; ## [190] &quot;R](#project)&quot; ## [191] &quot;*&quot; ## [192] &quot;La&quot; ## [193] &quot;primera&quot; ## [194] &quot;parte&quot; ## [195] &quot;de&quot; ## [196] &quot;este&quot; ## [197] &quot;libro&quot; ## [198] &quot;sobre&quot; ## [199] &quot;conceptos&quot; ## [200] &quot;bÃ¡sicos&quot; ## [201] &quot;estÃ¡&quot; ## [202] &quot;completa&quot; ## [203] &quot;**08/11/2018**&quot; ## [204] &quot;*&quot; ## [205] &quot;algorÃ­tmico&quot; ## [206] &quot;(5/6)&quot; ## [207] &quot;[`next`&quot; ## [208] &quot;y&quot; ## [209] &quot;`break`](#l17spe)&quot; ## [210] &quot;*&quot; ## [211] &quot;algorÃ­tmico&quot; ## [212] &quot;(6/6)&quot; ## [213] &quot;[Los&quot; ## [214] &quot;bucles&quot; ## [215] &quot;de&quot; ## [216] &quot;la&quot; ## [217] &quot;familia&quot; ## [218] &quot;`apply`](#l17applyfamily)&quot; ## [219] &quot;**19/10/2018**&quot; ## [220] &quot;*&quot; ## [221] &quot;algorÃ­tmico&quot; ## [222] &quot;(3/6)&quot; ## [223] &quot;[el&quot; ## [224] &quot;bucle&quot; ## [225] &quot;`for`](#l17for)&quot; ## [226] &quot;*&quot; ## [227] &quot;algorÃ­tmico&quot; ## [228] &quot;(4/6)&quot; ## [229] &quot;[el&quot; ## [230] &quot;bucle&quot; ## [231] &quot;`while`](#l17while)&quot; ## [232] &quot;*&quot; ## [233] &quot;algorÃ­tmico&quot; ## [234] &quot;(4&#39;/6)&quot; ## [235] &quot;[el&quot; ## [236] &quot;bucle&quot; ## [237] &quot;`repeat`](#l17repeat)&quot; ## [238] &quot;**28/09/2018**&quot; ## [239] &quot;*&quot; ## [240] &quot;algorÃ­tmico&quot; ## [241] &quot;(1/6)&quot; ## [242] &quot;[Pruebas&quot; ## [243] &quot;lÃ³gicas&quot; ## [244] &quot;con&quot; ## [245] &quot;`if`](#l17if)&quot; ## [246] &quot;*&quot; ## [247] &quot;algorÃ­tmico&quot; ## [248] &quot;(2/6)&quot; ## [249] &quot;[Pruebas&quot; ## [250] &quot;lÃ³gicas&quot; ## [251] &quot;con&quot; ## [252] &quot;`switch`](#l17switch)&quot; ## [253] &quot;**17/09/2018**&quot; ## [254] &quot;*&quot; ## [255] &quot;IntroducciÃ³n&quot; ## [256] &quot;**10/09/2018**&quot; ## [257] &quot;*&quot; ## [258] &quot;Importar&quot; ## [259] &quot;y&quot; ## [260] &quot;exportar&quot; ## [261] &quot;datos&quot; ## [262] &quot;(parte&quot; ## [263] &quot;2-3/3):&quot; ## [264] &quot;[Guardar&quot; ## [265] &quot;y&quot; ## [266] &quot;exportar&quot; ## [267] &quot;datos](#l016save)&quot; ## [268] &quot;**06/09/2018**&quot; ## [269] &quot;*&quot; ## [270] &quot;Importar&quot; ## [271] &quot;y&quot; ## [272] &quot;exportar&quot; ## [273] &quot;datos&quot; ## [274] &quot;(parte&quot; ## [275] &quot;1/3):&quot; ## [276] &quot;[Leer&quot; ## [277] &quot;datos&quot; ## [278] &quot;desde&quot; ## [279] &quot;un&quot; ## [280] &quot;archivo](#l016read)&quot; ## [281] &quot;**30/08/2018**&quot; ## [282] &quot;*&quot; ## [283] &quot;Nuevo&quot; ## [284] &quot;estudio&quot; ## [285] &quot;de&quot; ## [286] &quot;caso:&quot; ## [287] &quot;[dataloggers](#studyCase1)&quot; ## [288] &quot;*&quot; ## [289] &quot;Modificaciones&quot; ## [290] &quot;de&quot; ## [291] &quot;Marc&quot; ## [292] &quot;G.&quot; ## [293] &quot;sobre&quot; ## [294] &quot;el&quot; ## [295] &quot;[tipo&quot; ## [296] &quot;de&quot; ## [297] &quot;datos&quot; ## [298] &quot;numeric](#dataType1)&quot; ## [299] &quot;y&quot; ## [300] &quot;los&quot; ## [301] &quot;[entornos&quot; ## [302] &quot;de&quot; ## [303] &quot;desarrollo](#IDE)&quot; ## [304] &quot;**24/08/2018**&quot; ## [305] &quot;*&quot; ## [306] &quot;CapÃ­tulo&quot; ## [307] &quot;sobre&quot; ## [308] &quot;[las&quot; ## [309] &quot;funciones&quot; ## [310] &quot;(3/3)](#fonctions)&quot; ## [311] &quot;**27/07/2018**&quot; ## [312] &quot;*&quot; ## [313] &quot;CapÃ­tulo&quot; ## [314] &quot;sobre&quot; ## [315] &quot;[las&quot; ## [316] &quot;funciones&quot; ## [317] &quot;(2/3)](#fonctions)&quot; ## [318] &quot;**25/07/2018**&quot; ## [319] &quot;*&quot; ## [320] &quot;CapÃ­tulo&quot; ## [321] &quot;sobre&quot; ## [322] &quot;[las&quot; ## [323] &quot;funciones&quot; ## [324] &quot;(1/3)](#fonctions)&quot; ## [325] &quot;**17/07/2018**&quot; ## [326] &quot;*&quot; ## [327] &quot;ediciÃ³n&quot; ## [328] &quot;y&quot; ## [329] &quot;correcciÃ³n&quot; ## [330] &quot;del&quot; ## [331] &quot;espaÃ±ol&quot; ## [332] &quot;(Susi&quot; ## [333] &quot;L.)&quot; ## [334] &quot;*&quot; ## [335] &quot;tercera&quot; ## [336] &quot;parte&quot; ## [337] &quot;del&quot; ## [338] &quot;capÃ­tulo&quot; ## [339] &quot;[*Contenedores&quot; ## [340] &quot;de&quot; ## [341] &quot;datos*](#dataType2):&quot; ## [342] &quot;El&quot; ## [343] &quot;contenedor&quot; ## [344] &quot;[*data.frame*](#l014dataframe)&quot; ## [345] &quot;*&quot; ## [346] &quot;cuarta&quot; ## [347] &quot;parte&quot; ## [348] &quot;del&quot; ## [349] &quot;capÃ­tulo&quot; ## [350] &quot;[*Contenedores&quot; ## [351] &quot;de&quot; ## [352] &quot;datos*](#dataType2):&quot; ## [353] &quot;El&quot; ## [354] &quot;contenedor&quot; ## [355] &quot;[*matrix*](#l014matrix)&quot; ## [356] &quot;*&quot; ## [357] &quot;quinta&quot; ## [358] &quot;parte&quot; ## [359] &quot;del&quot; ## [360] &quot;capÃ­tulo&quot; ## [361] &quot;[*Contenedores&quot; ## [362] &quot;de&quot; ## [363] &quot;datos*](#dataType2):&quot; ## [364] &quot;El&quot; ## [365] &quot;contenedor&quot; ## [366] &quot;[*array*](#l014array)&quot; ## [367] &quot;**16/07/2018**&quot; ## [368] &quot;*&quot; ## [369] &quot;ediciÃ³n&quot; ## [370] &quot;y&quot; ## [371] &quot;correcciÃ³n&quot; ## [372] &quot;del&quot; ## [373] &quot;espaÃ±ol&quot; ## [374] &quot;(EstefanÃ­a&quot; ## [375] &quot;Q.)&quot; ## [376] &quot;**12/07/2018**&quot; ## [377] &quot;*&quot; ## [378] &quot;segunda&quot; ## [379] &quot;parte&quot; ## [380] &quot;del&quot; ## [381] &quot;capÃ­tulo&quot; ## [382] &quot;[*Contenedores&quot; ## [383] &quot;de&quot; ## [384] &quot;datos*](#dataType2):&quot; ## [385] &quot;El&quot; ## [386] &quot;contenedor&quot; ## [387] &quot;[*list*](#l014list)&quot; ## [388] &quot;**06/07/2018**&quot; ## [389] &quot;*&quot; ## [390] &quot;ediciÃ³n&quot; ## [391] &quot;y&quot; ## [392] &quot;correcciÃ³n&quot; ## [393] &quot;del&quot; ## [394] &quot;espaÃ±ol&quot; ## [395] &quot;(Camila&quot; ## [396] &quot;B.)&quot; ## [397] &quot;*&quot; ## [398] &quot;primera&quot; ## [399] &quot;parte&quot; ## [400] &quot;del&quot; ## [401] &quot;capÃ­tulo&quot; ## [402] &quot;[*Contenedores&quot; ## [403] &quot;de&quot; ## [404] &quot;datos*](#dataType2):&quot; ## [405] &quot;El&quot; ## [406] &quot;contenedor&quot; ## [407] &quot;[*vector*](#l014vector)&quot; ## [408] &quot;**04/07/2018**&quot; ## [409] &quot;*&quot; ## [410] &quot;tabla&quot; ## [411] &quot;de&quot; ## [412] &quot;contenidos&quot; ## [413] &quot;con&quot; ## [414] &quot;los&quot; ## [415] &quot;prÃ³ximos&quot; ## [416] &quot;capÃ­tulos&quot; ## [417] &quot;*&quot; ## [418] &quot;error&quot; ## [419] &quot;de&quot; ## [420] &quot;tipografÃ­a&quot; ## [421] &quot;en&quot; ## [422] &quot;*Elegir&quot; ## [423] &quot;un&quot; ## [424] &quot;entorno&quot; ## [425] &quot;de&quot; ## [426] &quot;desarrollo*&quot; ## [427] &quot;**02/07/2018**&quot; ## [428] &quot;*&quot; ## [429] &quot;tres&quot; ## [430] &quot;capÃ­tulos&quot; ## [431] &quot;en&quot; ## [432] &quot;lÃ­nea&quot; ## [433] &quot;(*primeros&quot; ## [434] &quot;pasos*,&quot; ## [435] &quot;*elegir&quot; ## [436] &quot;un&quot; ## [437] &quot;entorno&quot; ## [438] &quot;de&quot; ## [439] &quot;desarrollo*,&quot; ## [440] &quot;*tipos&quot; ## [441] &quot;de&quot; ## [442] &quot;datos*)&quot; 8.2 Guardar datos para R A veces es útil poder guardar un objeto R para poder reutilizarlo más tarde. Este es el caso, por ejemplo, cuando el tiempo de cálculo para llegar a un resultado es muy largo, o cuando queremos liberar espacio en la RAM. Para hacer esto, existe la función save() que toma como argumento principal el nombre de los objetos que queremos guardar. El objeto guardado se almacenará en un archivo. Por convención, es bueno dar como nombre de extensión .RData a los archivos que contienen objetos R, preferir un solo objeto por archivo, y dar el nombre del objeto como nombre del archivo. myObject &lt;- 5 ls(pattern = &quot;myObject&quot;) ## [1] &quot;myObject&quot; save(myObject, file = &quot;myFiles/myObject.RData&quot;) rm(myObject) ls(pattern = &quot;myObject&quot;) ## character(0) Si necesitamos el objeto guardado en el archivo, podemos volver a cargarlo con la función load(). ls(pattern = &quot;myObject&quot;) ## character(0) load(&quot;myFiles/myObject.RData&quot;) ls(pattern = &quot;myObject&quot;) ## [1] &quot;myObject&quot; print(myObject) ## [1] 5 8.3 Exportar datos La mejor forma de comunicar sus resultados o datos es enviar sus scripts y archivos de datos. A veces esto no es posible o no es adecuado, y puede ser útil exportar sus datos en un archivo de texto o CSV. Para hacer esto, existe la función genérica write() y la función write.table() para data.frame. Por ejemplo, crearemos un data.frame con los números del 1 al 26 y las letras correspondientes, luego los guardaremos en un archivo CSV, luego volveremos a leer los datos contenidos en este archivo. dfLetters &lt;- data.frame(num = 1:26, letters = letters) write.table(dfLetters, file = &quot;myFiles/dfLetters.csv&quot;, sep = &quot;,&quot;, col.names = TRUE, row.names = FALSE) read.table(file = &quot;myFiles/dfLetters.csv&quot;, header = TRUE, sep = &quot;,&quot;) ## num letters ## 1 1 a ## 2 2 b ## 3 3 c ## 4 4 d ## 5 5 e ## 6 6 f ## 7 7 g ## 8 8 h ## 9 9 i ## 10 10 j ## 11 11 k ## 12 12 l ## 13 13 m ## 14 14 n ## 15 15 o ## 16 16 p ## 17 17 q ## 18 18 r ## 19 19 s ## 20 20 t ## 21 21 u ## 22 22 v ## 23 23 w ## 24 24 x ## 25 25 y ## 26 26 z 8.4 Conclusión Felicitaciones! Ahora sabemos cómo leer datos de un archivo de texto o CSV, guardar y cargar datos de RData, y escribir en un archivo. El error más común entre los principiantes en R es la lectura de archivos de datos. Es por eso que este capítulo es para leer y volver a leer sin moderación. "],["algo.html", " 9 Algorítmico 9.1 Pruebas lógicas con if 9.2 Pruebas lógicas con switch 9.3 El bucle for 9.4 El bucle while 9.5 El bucle repeat 9.6 next y break 9.7 Los bucles de la familia apply 9.8 Conclusión", " 9 Algorítmico 9.1 Pruebas lógicas con if Si queremos realizar una operación diferente según una condición, podemos configurar una prueba lógica del tipo SI esto ENTONCES esto SINO esto. Con R esto dará como resultado la función if(cond) cons.express alt.expr como se muestra en la función help. myVar &lt;- 2 if(myVar &lt; 3) print(&quot;myVar &lt; 3&quot;) ## [1] &quot;myVar &lt; 3&quot; if(myVar &lt; 3) print(&quot;myVar &lt; 3&quot;) else print(&quot;myVar &gt; 3&quot;) ## [1] &quot;myVar &lt; 3&quot; Cuando hay varias líneas de código para ejecutar basadas en la prueba lógica, o simplemente para hacer que el código sea más fácil de leer, utilizamos varias líneas con {} y con identacion. myVar &lt;- 2 myResult &lt;- 0 if(myVar &lt; 3){ print(&quot;myVar &lt; 3&quot;) myResult &lt;- myVar + 10 } else { print(&quot;myVar &gt; 3&quot;) myResult &lt;- myVar - 10 } ## [1] &quot;myVar &lt; 3&quot; print(myResult) ## [1] 12 En este ejemplo definimos una variable myVar. Si esta variable es menor que 3, la variable myResult se establece en myVar + 10, y de lo contrario myResult se establece en myVar - 10. Ya hemos visto el uso de la prueba lógica if en el capítulo sobre las funciones. Habiamos probado si la variable ingresada como argumento en nuestra función era de tipo character. myVar &lt;- &quot;qwerty&quot; if(is.character(myVar)){ print(&quot;ok&quot;) } else { print(&quot;error&quot;) } ## [1] &quot;ok&quot; También podemos anidar pruebas lógicas entre sí. myVar &lt;- TRUE if(is.character(myVar)){ print(&quot;myVar: character&quot;) } else { if(is.numeric(myVar)){ print(&quot;myVar: numeric&quot;) } else { if(is.logical(myVar)){ print(&quot;myVar: logical&quot;) } else { print(&quot;myVar: ...&quot;) } } } ## [1] &quot;myVar: logical&quot; También es posible estipular varias condiciones, como vimos en el capítulo sobre operadores de comparación. myVar &lt;- 2 if(myVar &gt; 1 &amp; myVar &lt; 50){ print(&quot;ok&quot;) } ## [1] &quot;ok&quot; En este ejemplo, myVar está en formato numeric, por lo que la primera condición (&gt; 1) y la segunda condición (&lt; 50) son verificables. Por otro lado, si asignamos una variable de tipo character a myVar entonces R transformará 0 y 10 en objetos de tipo character y probará si myVar&gt; \"1\" y despues si myVar &lt; \"50\" basandose en la clasificación alfabética. En el siguiente ejemplo, \"azerty\" no está ubicado segun el orden alfabético entre \"1\" y \"50\", pero para \"2azerty\" es el caso, lo que resulta problematico. myVar &lt;- &quot;azerty&quot; limInit &lt;- 1 limEnd &lt;- 50 if(myVar &gt; limInit &amp; myVar &lt; limEnd){ print(paste0(myVar, &quot; is between &quot;, limInit, &quot; and &quot;, limEnd, &quot;.&quot;)) } else { print(paste0(myVar, &quot; not between &quot;, limInit, &quot; and &quot;, limEnd, &quot;.&quot;)) } ## [1] &quot;azerty not between 1 and 50.&quot; myVar &lt;- &quot;2azerty&quot; if(myVar &gt; limInit &amp; myVar &lt; limEnd){ print(paste0(myVar, &quot; is between &quot;, limInit, &quot; and &quot;, limEnd, &quot;.&quot;)) } else { print(paste0(myVar, &quot; not between &quot;, limInit, &quot; and &quot;, limEnd, &quot;.&quot;)) } ## [1] &quot;2azerty is between 1 and 50.&quot; Entonces, lo que nos gustaría hacer es probar si myVar está en formato numeric, y entonces solo si es el caso probar las siguientes condiciones. myVar &lt;- &quot;2azerty&quot; if(is.numeric(myVar)){ if(myVar &gt; limInit &amp; myVar &lt; limEnd){ print(paste0(myVar, &quot; is between &quot;, limInit, &quot; and &quot;, limEnd, &quot;.&quot;)) } else { print(paste0(myVar, &quot; not between &quot;, limInit, &quot; and &quot;, limEnd, &quot;.&quot;)) } } else { print(paste0(&quot;Object &quot;, myVar, &quot; is not numeric&quot;)) } ## [1] &quot;Object 2azerty is not numeric&quot; A veces es posible que necesitemos probar una primera condición y luego una segunda condición solo si la primera es verdadera en la misma prueba. Por ejemplo, para un sitio nos gustaría saber si hay una sola especie y probar si su abundancia es mayor que 10. Imagine un conjunto de datos con abundancia de vectores. Probaremos el número de especies con la función length(). mySpecies &lt;- c(15, 14, 20, 12) if(length(mySpecies) == 1 &amp; mySpecies &gt; 10){ print(&quot;ok!&quot;) } ## Warning message: ## In if (length(mySpecies) == 1 &amp; mySpecies &gt; 10) { : ## the condition has length &gt; 1 and only the first element will be used R devuelve un error porque no puede dentro de una prueba lógica con if() verificar la segunda condición. De hecho, mySpecies &gt; 10 devuelve TRUE TRUE TRUE TRUE TRUE. Podemos separar el código en dos condiciones: mySpecies &lt;- c(15, 14, 20, 12) if(length(mySpecies) == 1){ if(mySpecies &gt; 10){ print(&quot;ok!&quot;) } } Una alternativa más elegante es decirle a R que verifique la segunda condición solo si la primera es verdadera. Para eso podemos usar &amp;&amp; en lugar de &amp;. mySpecies &lt;- c(15, 14, 20, 12) if(length(mySpecies) == 1 &amp;&amp; mySpecies &gt; 10){ print(&quot;ok!&quot;) } mySpecies &lt;- 15 if(length(mySpecies) == 1 &amp;&amp; mySpecies &gt; 10){ print(&quot;ok!&quot;) } ## [1] &quot;ok!&quot; mySpecies &lt;- 5 if(length(mySpecies) == 1 &amp;&amp; mySpecies &gt; 10){ print(&quot;ok!&quot;) } Con &amp; R comprobará todas las condiciones, y con &amp;&amp; R tomará cada condición una después de la otra y continuará solo si es verdadera. Esto puede parecer anecdótico, pero es bueno saber la diferencia entre &amp; y &amp;&amp; porque a menudo los encontramos en los códigos disponibles en Internet o en los paquetes. 9.2 Pruebas lógicas con switch La función switch() es una variante de if() que es útil cuando tenemos muchas opciones posibles para la misma expresión. El siguiente ejemplo muestra cómo transformar el código usando if() a switch(). x &lt;- &quot;aa&quot; if(x == &quot;a&quot;){ result &lt;- 1 } if(x == &quot;aa&quot;){ result &lt;- 2 } if(x == &quot;aaa&quot;){ result &lt;- 3 } if(x == &quot;aaaa&quot;){ result &lt;- 4 } print(result) ## [1] 2 x &lt;- &quot;aa&quot; switch(x, a = result &lt;- 1, aa = result &lt;- 2, aaa = result &lt;- 3, aaaa = result &lt;- 4) print(result) ## [1] 2 9.3 El bucle for En programación, cuando tenemos que repetir la misma línea de código varias veces, es un signo que indica que debemos usar un bucle. Un bucle es una forma de iterar sobre un conjunto de objetos (o los elementos de un objeto) y repetir una operación. Imaginamos un data.frame con mediciones de datos de campo en dos fechas. bdd &lt;- data.frame(date01 = rnorm(n = 100, mean = 10, sd = 1), date02 = rnorm(n = 100, mean = 10, sd = 1)) print(head(bdd)) ## date01 date02 ## 1 9.719458 8.705486 ## 2 10.615751 8.970232 ## 3 11.489622 9.578997 ## 4 10.969352 9.996233 ## 5 10.763592 8.006116 ## 6 8.043056 10.352328 Nos gustaría cuantificar la diferencia entre la primera y la segunda fecha, luego poner un indicador para saber si esta diferencia es pequeña o grande, por ejemplo, con un umbral arbitrario de 3. Entonces, para cada línea podríamos hacer: bdd$dif &lt;- NA bdd$isDifBig &lt;- NA bdd$dif[1] &lt;- sqrt((bdd$date01[1] - bdd$date02[1])^2) bdd$dif[2] &lt;- sqrt((bdd$date01[2] - bdd$date02[2])^2) bdd$dif[3] &lt;- sqrt((bdd$date01[3] - bdd$date02[3])^2) # ... bdd$dif[100] &lt;- sqrt((bdd$date01[100] - bdd$date02[100])^2) if(bdd$dif[1] &gt; 3){ bdd$isDifBig[1] &lt;- &quot;big&quot; }else{ bdd$isDifBig[1] &lt;- &quot;small&quot; } if(bdd$dif[2] &gt; 3){ bdd$isDifBig[2] &lt;- &quot;big&quot; }else{ bdd$isDifBig[2] &lt;- &quot;small&quot; } if(bdd$dif[3] &gt; 3){ bdd$isDifBig[3] &lt;- &quot;big&quot; }else{ bdd$isDifBig[3] &lt;- &quot;small&quot; } # ... if(bdd$dif[100] &gt; 3){ bdd$isDifBig[100] &lt;- &quot;big&quot; }else{ bdd$isDifBig[100] &lt;- &quot;small&quot; } Esta forma de hacer las cosas sería extremadamente tediosa de lograr, y casi imposible de lograr si la tabla contuviera 1000 o 100000 líneas. Puede parecer lógico querer iterar sobre las líneas de nuestro data.frame para obtener las nuevas columnas. Es lo que vamos a hacer aun que no es la solución que retendremos más adelante. Vamos a usar un bucle for(). El bucle for() recorrerá los elementos de un objeto que vamos a dar como argumento. Por ejemplo, aquí hay un bucle que para todos los números del 3 al 9 calculará su valor al cuadrado. El valor actual del número está simbolizado por un objeto que puede tomar el nombre que queramos (aquí será i). for(i in c(3, 4, 5, 6, 7, 8, 9)){ print(i^2) } ## [1] 9 ## [1] 16 ## [1] 25 ## [1] 36 ## [1] 49 ## [1] 64 ## [1] 81 Eso podemos mejorar usando la función :. for(i in 3:9){ print(i^2) } El bucle for() puede iterar sobre todos los tipos de elementos. nChar &lt;- c(&quot;a&quot;, &quot;z&quot;, &quot;e&quot;, &quot;r&quot;, &quot;t&quot;, &quot;y&quot;) for(i in nChar){ print(i) } ## [1] &quot;a&quot; ## [1] &quot;z&quot; ## [1] &quot;e&quot; ## [1] &quot;r&quot; ## [1] &quot;t&quot; ## [1] &quot;y&quot; Volvamos a nuestro caso. Vamos a iterar sobre el número de líneas de nuestro data.frame bdd. Antes de eso crearemos las columnas dif y isDifBig con los valores NA. Luego usaremos la función nrow() para encontrar el número de líneas. bdd$dif &lt;- NA bdd$isDifBig &lt;- NA for(i in 1:nrow(bdd)){ bdd$dif[i] &lt;- sqrt((bdd$date01[i] - bdd$date02[i])^2) if(bdd$dif[i] &gt; 3){ bdd$isDifBig[i] &lt;- &quot;big&quot; }else{ bdd$isDifBig[i] &lt;- &quot;small&quot; } } print(head(bdd, n = 20)) ## date01 date02 dif isDifBig ## 1 9.719458 8.705486 1.01397192 small ## 2 10.615751 8.970232 1.64551906 small ## 3 11.489622 9.578997 1.91062475 small ## 4 10.969352 9.996233 0.97311922 small ## 5 10.763592 8.006116 2.75747609 small ## 6 8.043056 10.352328 2.30927228 small ## 7 10.308829 10.744864 0.43603505 small ## 8 10.328023 10.854178 0.52615479 small ## 9 9.618543 9.221003 0.39753939 small ## 10 8.594911 9.005062 0.41015150 small ## 11 10.257861 10.716142 0.45828025 small ## 12 10.027734 10.582536 0.55480117 small ## 13 9.139714 9.659108 0.51939478 small ## 14 8.493198 11.423924 2.93072531 small ## 15 11.508191 10.753088 0.75510242 small ## 16 9.493427 9.359546 0.13388117 small ## 17 10.795847 10.052996 0.74285027 small ## 18 10.667033 11.476606 0.80957242 small ## 19 10.955230 8.861647 2.09358311 small ## 20 9.279428 9.353000 0.07357146 small En la práctica, esta no es la mejor manera de realizar este ejercicio porque se trata de cálculos simples en vectores contenidos en un data.frame. R es particularmente potente para realizar operaciones en vectores. Donde sea posible, siempre tenemos que enfócarnos en operaciones vectoriales. Aquí nuestro código se convierte en: bdd$dif &lt;- sqrt((bdd$date01 - bdd$date02)^2) bdd$isDifBig &lt;- &quot;small&quot; bdd$isDifBig[bdd$dif &gt; 3] &lt;- &quot;big&quot; print(head(bdd, n = 20)) ## date01 date02 dif isDifBig ## 1 9.719458 8.705486 1.01397192 small ## 2 10.615751 8.970232 1.64551906 small ## 3 11.489622 9.578997 1.91062475 small ## 4 10.969352 9.996233 0.97311922 small ## 5 10.763592 8.006116 2.75747609 small ## 6 8.043056 10.352328 2.30927228 small ## 7 10.308829 10.744864 0.43603505 small ## 8 10.328023 10.854178 0.52615479 small ## 9 9.618543 9.221003 0.39753939 small ## 10 8.594911 9.005062 0.41015150 small ## 11 10.257861 10.716142 0.45828025 small ## 12 10.027734 10.582536 0.55480117 small ## 13 9.139714 9.659108 0.51939478 small ## 14 8.493198 11.423924 2.93072531 small ## 15 11.508191 10.753088 0.75510242 small ## 16 9.493427 9.359546 0.13388117 small ## 17 10.795847 10.052996 0.74285027 small ## 18 10.667033 11.476606 0.80957242 small ## 19 10.955230 8.861647 2.09358311 small ## 20 9.279428 9.353000 0.07357146 small La mayoría de los ejemplos que se pueden encontrar en Internet sobre el bucle for() pueden reemplazarse por operaciones vectoriales. Aquí hay algunos ejemplos adaptados de varias fuentes: # prueba si los números son pares # [1] FOR x &lt;- sample(1:100, size = 20) count &lt;- 0 for (val in x) { if(val %% 2 == 0){ count &lt;- count + 1 } } print(count) ## [1] 10 # [2] VECTOR sum(x %% 2 == 0) ## [1] 10 # calcular cuadrados # [1] FOR x &lt;- rep(0, 20) for (j in 1:20){ x[j] &lt;- j^2 } print(x) ## [1] 1 4 9 16 25 36 49 64 81 100 121 144 169 196 225 256 289 324 361 ## [20] 400 # [2] VECTOR (1:20)^2 ## [1] 1 4 9 16 25 36 49 64 81 100 121 144 169 196 225 256 289 324 361 ## [20] 400 # repetir una tirada de dados y promediar # [1] FOR ntrials = 1000 trials = rep(0, ntrials) for (j in 1:ntrials){ trials[j] = sample(1:6, size = 1) } mean(trials) ## [1] 3.507 # [2] VECTOR mean(sample(1:6, ntrials, replace = TRUE)) ## [1] 3.555 Es un buen ejercicio explorar los muchos ejemplos disponibles en Internet en el bucle for() e intentar convertirlos en operaciones vectoriales. Esto nos permite adquirir buenos reflejos de programación con R. El bucle for() es muy útil, por ejemplo, para leer varios archivos y tratar la información que contienen de la misma manera, hacer gráficos, o Cuando las operaciones vectoriales se vuelven tediosas. Imagina una matriz de 10 columnas y 100 líneas. Queremos la suma de cada línea (veremos cómo hacer con la función apply() mas adelante). myMat &lt;- matrix(sample(1:100, size = 1000, replace = TRUE), ncol = 10) # VECTOR sumRow &lt;- myMat[, 1] + myMat[, 2] + myMat[, 3] + myMat[, 4] + myMat[, 5] + myMat[, 6] + myMat[, 7] + myMat[, 8] + myMat[, 9] + myMat[, 10] print(sumRow) ## [1] 481 565 544 373 650 396 641 595 663 361 456 554 308 591 468 567 606 462 ## [19] 515 619 534 593 592 660 442 373 309 564 398 498 472 507 496 484 481 550 ## [37] 319 334 463 683 472 516 576 655 409 526 524 549 507 521 467 408 566 450 ## [55] 374 677 622 595 529 591 456 468 578 491 471 698 666 387 433 434 361 684 ## [73] 579 470 574 492 540 496 465 458 598 447 502 415 517 461 418 341 318 361 ## [91] 571 637 425 443 540 420 522 490 319 525 # FOR sumRow &lt;- rep(NA, times = nrow(myMat)) for(j in 1:nrow(myMat)){ sumRow[j] &lt;- sum(myMat[j, ]) } print(sumRow) ## [1] 481 565 544 373 650 396 641 595 663 361 456 554 308 591 468 567 606 462 ## [19] 515 619 534 593 592 660 442 373 309 564 398 498 472 507 496 484 481 550 ## [37] 319 334 463 683 472 516 576 655 409 526 524 549 507 521 467 408 566 450 ## [55] 374 677 622 595 529 591 456 468 578 491 471 698 666 387 433 434 361 684 ## [73] 579 470 574 492 540 496 465 458 598 447 502 415 517 461 418 341 318 361 ## [91] 571 637 425 443 540 420 522 490 319 525 En conclusión, se recomienda no usar el bucle for() con R siempre que sea posible, y en este capítulo veremos alternativas como los bucles familiares apply(). 9.4 El bucle while El bucle while(), a diferencia del bucle for(), significa MIENTRAS. Mientras no se cumpla una condición, el bucle continuará ejecutándose. Atención porque en caso de error, podemos programar fácilmente bucles que nunca terminan. Este bucle es menos común que el bucle for(). Tomemos un ejemplo: i &lt;- 0 while(i &lt; 10){ print(i) i &lt;- i + 1 } ## [1] 0 ## [1] 1 ## [1] 2 ## [1] 3 ## [1] 4 ## [1] 5 ## [1] 6 ## [1] 7 ## [1] 8 ## [1] 9 En este ejemplo, la variable i tiene como valor inicial 0. MIENTRAS QUE i &lt; 10, mostramos i con print(). Para que este bucle finalice, no olvidamos cambiar el valor de i, esto se hace con la línea i &lt;- i + 1. Cuando la condición i &lt; 10 ya no se cumple, el bucle se detiene. El bucle while() es muy útil para crear scripts que realizarán cálculos en variables cuyo valor cambia con el tiempo. Por ejemplo, imaginamos un número entre 0 y 10000 y un generador aleatorio que intentará determinar el valor de este número. Si queremos limitar los intentos de R a 2 segundos, podemos escribir el siguiente script (que debería funcionar cada vez en una computadora de escritorio típica que pueda realizar fácilmente 35000 pruebas en 2 segundos): myNumber &lt;- sample(x = 10000, size = 1) myGuess &lt;- sample(x = 10000, size = 1) startTime &lt;- Sys.time() numberGuess &lt;- 0 while(Sys.time() - startTime &lt; 2){ if(myGuess == myNumber){ numberGuess &lt;- numberGuess + 1 print(&quot;Number found !&quot;) print(paste0(&quot;And I have plenty of time left: &quot;, round(2 - as.numeric(Sys.time() - startTime), digits = 2), &quot; sec&quot;)) break }else{ myGuess &lt;- sample(x = 10000, size = 1) numberGuess &lt;- numberGuess + 1 } } ## [1] &quot;Number found !&quot; ## [1] &quot;And I have plenty of time left: 1.5 sec&quot; En este script generamos un número aleatorio para adivinar con la función sample(), y cada uno de los intentos con la misma función sample(). Luego usamos la función Sys.time() (con una S mayúscula a Sys), para saber la hora de inicio del bucle. Siempre que la diferencia entre cada iteración del bucle y la hora de inicio sea inferior a 2 segundos, el bucle while() verificará si el número correcto estaba adivinando en la prueba lógica con if() y luego si es el caso nos informa que se encontró el número, y nos indica el tiempo restante antes de los dos segundos. Luego para finalizar el bucle usamos la palabra clave break en la que volveremos. En resumen, break, permite salir de un bucle. Si no se ha adivinado el número, el bucle realiza otra prueba con la función sample(). Más concretamente, podríamos imaginar algoritmos para explorar un espacio de soluciones a un problema con un tiempo limitado para lograrlo. El bucle while() también puede ser útil para que un script se ejecute solo cuando un archivo de otro programa esté disponible  En la práctica, el bucle while() se usa poco con R. 9.5 El bucle repeat El bucle repeat() permite repetir una operación sin condiciones para verificar. Para salir de este bucle debemos usar la palabra clave break. i &lt;- 1 repeat{ print(i^2) i &lt;- i + 1 if(i == 5){ break } } ## [1] 1 ## [1] 4 ## [1] 9 ## [1] 16 Si volvemos al ejemplo anterior, podemos usar un bucle repeat() para repetirlo cinco veces. numTry &lt;- 0 repeat{ myNumber &lt;- sample(x = 10000, size = 1) myGuess &lt;- sample(x = 10000, size = 1) startTime &lt;- Sys.time() numberGuess &lt;- 0 while(Sys.time() - startTime &lt; 2){ if(myGuess == myNumber){ numberGuess &lt;- numberGuess + 1 print(round(as.numeric(Sys.time() - startTime), digits = 3)) break }else{ myGuess &lt;- sample(x = 10000, size = 1) numberGuess &lt;- numberGuess + 1 } } numTry &lt;- numTry + 1 if(numTry == 5){break} } ## [1] 1.815 ## [1] 1.762 ## [1] 0.514 ## [1] 0.401 ## [1] 1.178 Al igual que el bucle while(), el bucle repeat() no se usa mucho con R. 9.6 next y break Ya hemos visto la palabra clave break que permite salir del bucle actual. Por ejemplo, si buscamos el primer dígito después de 111 que es divisible por 32: myVars &lt;- 111:1000 for(myVar in myVars){ if(myVar %% 32 == 0){ print(myVar) break } } ## [1] 128 Aunque hemos visto que en la práctica podemos evitar el bucle for() con una operación vectorial: (111:1000)[111:1000 %% 32 == 0][1] ## [1] 128 La palabra clave next permite pasar a la siguiente iteración de un bucle si se cumple una determinada condición. Por ejemplo, si queremos imprimir las letras del alfabeto sin las vocales: for(myLetter in letters){ if(myLetter %in% c(&quot;a&quot;, &quot;e&quot;, &quot;i&quot;, &quot;o&quot;, &quot;u&quot;, &quot;y&quot;)){ next } print(myLetter) } ## [1] &quot;b&quot; ## [1] &quot;c&quot; ## [1] &quot;d&quot; ## [1] &quot;f&quot; ## [1] &quot;g&quot; ## [1] &quot;h&quot; ## [1] &quot;j&quot; ## [1] &quot;k&quot; ## [1] &quot;l&quot; ## [1] &quot;m&quot; ## [1] &quot;n&quot; ## [1] &quot;p&quot; ## [1] &quot;q&quot; ## [1] &quot;r&quot; ## [1] &quot;s&quot; ## [1] &quot;t&quot; ## [1] &quot;v&quot; ## [1] &quot;w&quot; ## [1] &quot;x&quot; ## [1] &quot;z&quot; De nuevo podimos evitar el bucle for() con: letters[! letters %in% c(&quot;a&quot;, &quot;e&quot;, &quot;i&quot;, &quot;o&quot;, &quot;u&quot;, &quot;y&quot;)] ## [1] &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; &quot;j&quot; &quot;k&quot; &quot;l&quot; &quot;m&quot; &quot;n&quot; &quot;p&quot; &quot;q&quot; &quot;r&quot; &quot;s&quot; &quot;t&quot; &quot;v&quot; &quot;w&quot; &quot;x&quot; ## [20] &quot;z&quot; En conclusión, si usamos bucles, las palabras clave next y break suelen ser muy útiles, pero siempre que sea posible es mejor usar operaciones vectoriales. Cuando no es posible trabajar con vectores, es mejor usar los bucles del tipo apply que son el tema de la siguiente sección. 9.7 Los bucles de la familia apply 9.7.1 apply La función apply() permite aplicar una función a todos los elementos de un array o un matrix. Por ejemplo, si queremos saber la suma de cada fila de una matriz de 10 columnas y 100 líneas: myMat &lt;- matrix(sample(1:100, size = 1000, replace = TRUE), ncol = 10) apply(X = myMat, MARGIN = 1, FUN = sum) ## [1] 466 475 521 450 338 625 400 514 672 397 546 438 574 557 469 512 377 613 ## [19] 514 482 630 660 452 491 436 737 623 706 606 452 587 417 504 458 506 508 ## [37] 614 463 562 525 465 357 459 598 469 370 452 413 497 347 545 454 307 629 ## [55] 455 603 497 325 435 563 332 727 664 425 348 467 554 540 604 462 425 454 ## [73] 232 383 530 659 396 501 500 716 531 403 475 518 457 594 329 350 403 464 ## [91] 493 589 667 314 489 613 542 602 433 547 Si queremos saber la mediana de cada columna, la expresión se convierte en: apply(X = myMat, MARGIN = 2, FUN = median) ## [1] 41.0 47.5 55.0 56.5 47.0 39.5 56.0 58.0 50.0 50.0 El argumento X es el objeto en el que el bucle apply se repetirá. El argumento MARGEN corresponde a la dimensión a tener en cuenta (1 para las filas y 2 para las columnas). El argumento FUN es la función a aplicar. En un objeto array, el argumento MARGIN puede tomar tantos valores como dimensiones. En este ejemplo, MARGIN = 1 es el promedio de cada fila - dimensión 1 - (todas las dimensiones combinadas), MARGIN = 2 es el promedio de cada columna - dimensión 2 - (todas las dimensiones combinadas), y MARGEN = 3 es el promedio de cada dimensión 3. Debajo cada cálculo se realiza de dos maneras diferentes para explicar su operación. myArr &lt;- array(sample(1:100, size = 1000, replace = TRUE), dim = c(10, 20, 5)) apply(X = myArr, MARGIN = 1, FUN = mean) ## [1] 48.62 50.92 50.28 51.40 51.26 49.71 50.68 45.50 51.09 47.90 (apply(myArr[,,1], 1, mean) + apply(myArr[,,2], 1, mean) + apply(myArr[,,3], 1, mean) + apply(myArr[,,4], 1, mean) + apply(myArr[,,5], 1, mean))/5 ## [1] 48.62 50.92 50.28 51.40 51.26 49.71 50.68 45.50 51.09 47.90 apply(X = myArr, MARGIN = 2, FUN = mean) ## [1] 52.22 46.72 51.88 47.74 54.60 47.28 53.46 49.02 50.44 48.44 54.82 47.60 ## [13] 50.30 43.50 40.76 55.16 51.50 50.90 47.88 50.50 (apply(myArr[,,1], 2, mean) + apply(myArr[,,2], 2, mean) + apply(myArr[,,3], 2, mean) + apply(myArr[,,4], 2, mean) + apply(myArr[,,5], 2, mean))/5 ## [1] 52.22 46.72 51.88 47.74 54.60 47.28 53.46 49.02 50.44 48.44 54.82 47.60 ## [13] 50.30 43.50 40.76 55.16 51.50 50.90 47.88 50.50 apply(X = myArr, MARGIN = 3, FUN = mean) ## [1] 49.735 47.330 49.255 51.605 50.755 c(mean(myArr[,,1]), mean(myArr[,,2]), mean(myArr[,,3]), mean(myArr[,,4]), mean(myArr[,,5])) ## [1] 49.735 47.330 49.255 51.605 50.755 También podemos calcular el promedio de cada fila y valor de columna (la función luego itera en la dimensión 3): apply(X = myArr, MARGIN = c(1, 2), FUN = mean) ## [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12] [,13] ## [1,] 49.4 34.0 80.6 44.2 60.2 59.0 63.8 27.2 34.8 50.4 62.4 45.0 40.6 ## [2,] 48.6 43.8 33.2 47.0 76.6 50.4 67.2 70.0 51.2 33.0 42.2 69.6 40.8 ## [3,] 64.6 39.6 46.2 71.8 57.0 45.8 58.2 35.4 59.6 54.2 44.6 59.2 28.0 ## [4,] 31.2 57.6 56.8 36.2 56.0 59.8 59.6 54.8 42.6 43.0 42.4 64.0 46.0 ## [5,] 73.4 55.0 59.8 45.2 59.8 44.8 46.2 36.2 58.4 35.2 65.4 41.4 70.4 ## [6,] 43.4 49.4 30.4 65.6 59.6 31.2 53.4 77.2 41.0 54.6 66.8 28.8 70.2 ## [7,] 53.2 58.8 44.6 52.0 46.8 33.2 34.0 39.8 41.8 40.6 58.0 66.8 54.8 ## [8,] 43.8 17.4 58.0 16.8 42.0 71.8 32.8 34.0 60.8 63.2 53.0 39.2 45.6 ## [9,] 79.0 51.6 68.8 47.0 59.4 53.4 53.0 62.0 50.8 56.8 52.8 19.4 67.8 ## [10,] 35.6 60.0 40.4 51.6 28.6 23.4 66.4 53.6 63.4 53.4 60.6 42.6 38.8 ## [,14] [,15] [,16] [,17] [,18] [,19] [,20] ## [1,] 26.8 63.4 37.2 52.6 52.6 53.8 34.4 ## [2,] 36.8 52.6 65.8 45.8 40.6 53.4 49.8 ## [3,] 33.4 31.8 69.0 58.2 63.0 46.0 40.0 ## [4,] 45.4 30.2 60.8 53.0 47.0 65.6 76.0 ## [5,] 59.6 49.6 48.8 51.8 30.2 59.0 35.0 ## [6,] 59.4 26.8 60.2 52.2 48.0 26.8 49.2 ## [7,] 45.4 39.8 67.2 56.6 74.4 36.4 69.4 ## [8,] 41.0 35.6 45.8 45.2 54.4 44.4 65.2 ## [9,] 23.2 41.0 40.0 46.8 61.6 39.0 48.4 ## [10,] 64.0 36.8 56.8 52.8 37.2 54.4 37.6 9.7.2 lapply Como se indica en la documentación, lapply() devuelve una lista de la misma longitud que X, y cada elemento resulta de la aplicación FUN al elemento X correspondiente. Si X es una list que contiene vector y estamos tratando de obtener el promedio de cada elemento de list, podemos usar la función lapply(): myList &lt;- list( a = sample(1:100, size = 10), b = sample(1:100, size = 10), c = sample(1:100, size = 10), d = sample(1:100, size = 10), e = sample(1:100, size = 10) ) print(myList) ## $a ## [1] 66 80 28 87 5 20 36 16 74 3 ## ## $b ## [1] 4 13 80 25 69 59 48 49 54 81 ## ## $c ## [1] 30 34 73 44 71 74 42 54 16 91 ## ## $d ## [1] 86 17 66 15 57 1 40 59 69 7 ## ## $e ## [1] 64 25 89 66 88 17 77 43 29 42 lapply(myList, FUN = mean) ## $a ## [1] 41.5 ## ## $b ## [1] 48.2 ## ## $c ## [1] 52.9 ## ## $d ## [1] 41.7 ## ## $e ## [1] 54 Al igual que con la función apply(), podemos pasar argumentos adicionales a la función lapply() agregándolos después de la función. Esto es útil, por ejemplo, si nuestra list contiene estos valores faltantes NA y queremos ignorarlos para calcular los promedios (con el argumento na.rm = TRUE). myList &lt;- list( a = sample(c(1:5, NA), size = 10, replace = TRUE), b = sample(c(1:5, NA), size = 10, replace = TRUE), c = sample(c(1:5, NA), size = 10, replace = TRUE), d = sample(c(1:5, NA), size = 10, replace = TRUE), e = sample(c(1:5, NA), size = 10, replace = TRUE) ) print(myList) ## $a ## [1] 5 5 NA 1 NA 4 1 5 3 5 ## ## $b ## [1] NA NA 3 1 5 2 2 5 5 4 ## ## $c ## [1] 5 4 1 3 2 2 4 1 NA 5 ## ## $d ## [1] 2 4 5 NA 1 NA 4 3 3 2 ## ## $e ## [1] 3 NA NA 2 3 4 2 5 5 5 lapply(myList, FUN = mean) ## $a ## [1] NA ## ## $b ## [1] NA ## ## $c ## [1] NA ## ## $d ## [1] NA ## ## $e ## [1] NA lapply(myList, FUN = mean, na.rm = TRUE) ## $a ## [1] 3.625 ## ## $b ## [1] 3.375 ## ## $c ## [1] 3 ## ## $d ## [1] 3 ## ## $e ## [1] 3.625 Para mayor legibilidad o si se debemos realizar varias operaciones dentro del argumento FUN, podemos usar el siguiente script: lapply(myList, FUN = function(i){ mean(i, na.rm = TRUE) }) ## $a ## [1] 3.625 ## ## $b ## [1] 3.375 ## ## $c ## [1] 3 ## ## $d ## [1] 3 ## ## $e ## [1] 3.625 Por ejemplo, si queremos obtener i^2 si el promedio es mayor que 3, y i^3 de lo contrario: lapply(myList, FUN = function(i){ m &lt;- mean(i, na.rm = TRUE) if(m &gt; 3){ return(i^2) }else{ return(i^3) } }) ## $a ## [1] 25 25 NA 1 NA 16 1 25 9 25 ## ## $b ## [1] NA NA 9 1 25 4 4 25 25 16 ## ## $c ## [1] 125 64 1 27 8 8 64 1 NA 125 ## ## $d ## [1] 8 64 125 NA 1 NA 64 27 27 8 ## ## $e ## [1] 9 NA NA 4 9 16 4 25 25 25 9.7.3 sapply La función sapply() es una versión modificada de la función lapply() que realiza la misma operación pero devuelve el resultado en un formato simplificado siempre que sea posible. lapply(myList, FUN = function(i){ mean(i, na.rm = TRUE) }) ## $a ## [1] 3.625 ## ## $b ## [1] 3.375 ## ## $c ## [1] 3 ## ## $d ## [1] 3 ## ## $e ## [1] 3.625 sapply(myList, FUN = function(i){ mean(i, na.rm = TRUE) }) ## a b c d e ## 3.625 3.375 3.000 3.000 3.625 La función sapply() es interesante para recuperar, por ejemplo, el elemento n de cada elemento de una list. La función que se llama para hacer esto es '[['. sapply(myList, FUN = &#39;[[&#39;, 2) ## a b c d e ## 5 NA 4 4 NA 9.7.4 tapply La función tapply() permite aplicar una función tomando como elemento para iterar una variable existente. Imaginamos información sobre especies representadas por letras mayúsculas (por ejemplo, A, B, C) y valores de mediciones biologicas en diferentes ubicaciones. species &lt;- sample(LETTERS[1:10], size = 1000, replace = TRUE) perf1 &lt;- rnorm(n = 1000, mean = 10, sd = 0.5) perf2 &lt;- rlnorm(n = 1000, meanlog = 10, sdlog = 0.5) perf3 &lt;- rgamma(n = 1000, shape = 10, rate = 0.5) dfSpecies &lt;- data.frame(species, perf1, perf2, perf3) print(head(dfSpecies, n = 10)) ## species perf1 perf2 perf3 ## 1 I 10.552482 37912.909 18.80485 ## 2 J 9.751189 13189.195 18.80356 ## 3 A 10.144902 39912.922 18.69480 ## 4 H 10.148621 7754.008 21.72357 ## 5 E 10.586563 27810.099 29.73283 ## 6 C 9.700371 30946.839 18.74036 ## 7 J 10.647680 11360.460 14.56589 ## 8 F 10.292551 33135.372 19.02871 ## 9 B 10.276133 23966.861 19.81957 ## 10 J 10.425206 44413.271 12.48840 Podemos obtener fácilmente un resumen de las mediciones para cada especie con la función tapply() y la función summary(). tapply(dfSpecies$perf1, INDEX = dfSpecies$species, FUN = summary) ## $A ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 8.705 9.632 10.021 9.981 10.363 11.176 ## ## $B ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 8.937 9.663 10.045 10.044 10.423 11.475 ## ## $C ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 9.224 9.791 10.005 10.082 10.419 11.478 ## ## $D ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 8.956 9.669 9.957 9.951 10.238 11.188 ## ## $E ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 7.722 9.701 10.045 9.993 10.375 11.033 ## ## $F ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 8.638 9.623 9.906 9.904 10.257 11.108 ## ## $G ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 9.025 9.625 10.035 10.036 10.419 11.251 ## ## $H ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 8.812 9.715 10.016 10.023 10.341 11.345 ## ## $I ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 8.834 9.704 10.023 10.029 10.290 11.219 ## ## $J ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 8.673 9.738 10.061 10.058 10.429 11.369 También podemos obtener el valor promedio de cada mediciones combinando una función sapply() con la función tapply() y usando la función mean(). sapply(2:4, FUN = function(i){ tapply(dfSpecies[,i], INDEX = dfSpecies$species, FUN = mean) }) ## [,1] [,2] [,3] ## A 9.981495 25144.20 21.38752 ## B 10.043625 26366.71 19.57132 ## C 10.082289 24220.55 19.64893 ## D 9.951089 26190.32 20.08122 ## E 9.992532 24903.84 20.86645 ## F 9.903630 24182.43 19.31994 ## G 10.035897 23646.77 20.75494 ## H 10.023432 24584.59 19.60410 ## I 10.029309 24588.44 19.78836 ## J 10.057717 24406.67 20.25933 9.7.5 mapply La función mapply() es una versión de la función sapply() que usa múltiples argumentos. Por ejemplo, si tenemos una lista de dos elementos 1:5 y 5:1 y queremos agregar 10 al primer elemento y 100 al segundo elemento: mapply(FUN = function(i, j){i+j}, i = list(1:5, 5:1), j = c(10, 100)) ## [,1] [,2] ## [1,] 11 105 ## [2,] 12 104 ## [3,] 13 103 ## [4,] 14 102 ## [5,] 15 101 9.8 Conclusión Felicitaciones, hemos llegado al final de este capítulo sobre algoritmos. Recordemos este mensaje clave: cuando una operación debe realizarse más de dos veces en un script y repetir el código que ya se ha escrito, es un signo que nos debe llevar a utilizar un bucle. Sin embargo, siempre que sea posible, se recomienda no usar los bucles tradicionales for(), while(), y repeat(), sino preferir operaciones sobre vectores o bucles de la familia apply. Esto puede ser difícil de integrar al principio, pero veremos que nuestros scripts serán más fáciles de mantener y leer, y mucho más eficientes si seguimos estos hábitos. "],["project.html", " 10 Gestión de proyectos con R 10.1 Gestionando archivos y directorios de trabajo. 10.2 Gestión de versiones de script 10.3 Gestion de documentacion 10.4 Conclusión", " 10 Gestión de proyectos con R Ahora que hemos visto los conceptos básicos de R, todavía tenemos que abordar un elemento decisivo para el buen funcionamiento de nuestras actividades científicas con R: gestión de proyectos. Consiste en integrar sus desarrollos en un entorno y con una lógica orientada a facilitar su trabajo y aumentar así su eficiencia. Esta es solo una manera de hacer dentro de las infinitas posibilidades, a adaptar para todos y cada uno. 10.1 Gestionando archivos y directorios de trabajo. Entre los archivos de entrada (es decir, los archivos que contienen nuestros datos en bruto), los archivos de salida (por ejemplo, con la función write()), los gráficos (siguiente capítulo) y los muchos scripts asociados con un proyecto, se necesita un mínimo de organización para ser eficaz y reanudar rápidamente su proyecto. La solución más sencilla es estructurar su entorno de trabajo en carpetas según cada categoría de archivo. Por ejemplo, con una carpeta myProject para el proyecto, que contiene las carpetas myFiles para los archivos de entrada, una carpeta myScripts para el script R y una carpeta myOutputs para los archivos salida (por ejemplo, gráficos y análisis). ## -myProject ## |-myFiles ## |-|-data01.csv ## |-|-data02.csv ## |-myScripts ## |-|-myFirstScript.R ## |-myOutputs ## |-|-dataOut01.csv ## |-|-figure01.pdf 10.2 Gestión de versiones de script El trabajo en un script es iterativo: incluso si los objetivos se definen desde el principio, volveremos a trabajar algunas partes para obtener, por ejemplo, información adicional, o para optimizar esta o aquella función, o hacer un script generalizable para comunicarlo a La comunidad científica o simplemente un colega. A veces, lo que veremos como una mejora finalmente será un error, y volver al estado inicial puede ser difícil. Así que tenemos que gestionar las versiones. En la mayoría de los laboratorios hay servicios de control de versiones, el más conocido es GIT (https://git-scm.com/) y Subversion (https://subversion.apache.org/). Cuando GIT o Subversion están disponibles, se recomienda usarlos. Si no tenemos acceso a estos servicios, hay servicios en línea gratuitos como GitHub (https://github.com/; este libro utiliza GitHub). Hay muchas otras soluciones como GitLab (https://about.gitlab.com/), Bitbucket (https://bitbucket.org/), SourceForge (https://sourceforge.net/), GitKraken (https://gitkraken.com/), o Launchpad (https://launchpad.net/). El uso de estos diferentes servicios de versiones está fuera del alcance de este libro. Para los principiantes o para proyectos que no requieren trabajo colaborativo en scripts, una alternativa es administrar sus versiones manualmente. Por ejemplo, una solución es agregar un número al final de su nombre de archivo de script (por ejemplo, myFirstScript_01.R). Tan pronto como se realice una modificación importante en este script, bastará con guardarlo con un nuevo nombre (p. Ej., MyFirstScript_02.R) y colocar el script antiguo en una carpeta aparte para no desordenar el espacio de trabajo y hacer errores de version. En caso de problemas, podemos volver fácilmente al script anterior y reanudar nuestro trabajo. ## -myProject ## |-myFiles ## |-|-data01.csv ## |-|-data02.csv ## |-myScripts ## |-|-myFirstScript04.R ## |-|-ARCHIVES ## |-|-|-myFirstScript01.R ## |-|-|-myFirstScript02.R ## |-|-|-myFirstScript03.R ## |-myOutputs ## |-|-dataOut01.csv ## |-|-figure01.pdf 10.3 Gestion de documentacion La documentación de su código es esencial para volver fácilmente al trabajo o comunicar su trabajo con colegas y la comunidad científica. Un código bien documentado será comprensible por un número mayor y, por lo tanto, se utilizará más. Por eso es importante adoptar buenas técnicas y practicas. Ya hemos visto que hay varias formas de escribir su código con R porque es un lenguaje bastante permisivo. El primer paso hacia un código legible y reproducible es adoptar un estilo de código claro y coherente y  ¡hecho para humanos! Porque incluso si nuestro código está destinado a ser ejecutado por máquinas, debe seguir siendo comprensible de todas las personas que lo consultarán. Es por ejemplo poner espacios después de las comas, o usar la identación. Por supuesto, la legibilidad del código debe equilibrarse con la optimización del código para grandes conjuntos de datos, pero en la mayoría de los casos podemos asociar un código claro y optimizado. Entonces, el primer paso de la documentación y su administración es escribir primero su código pensando en las personas que lo leerán y lo reproducirán. El segundo paso es comentar su código. Los comentarios son esenciales cuando privilegiamos el código optimizado para el rendimiento pero que pierde en legibilidad. Los comentarios son superfluos si el código está bien escrito y los objetos y funciones están bien nombrados. Esto significa que los comentarios no deben usarse para explicar un código mal escrito, sino que desdemos desde el principio escribir bien nuestro código. Los comentarios son útiles para proporcionar elementos contextuales (por ejemplo, la elección de un método sobre otro en la literatura). El lugar de los comentarios puede estar al final de las líneas o en líneas separadas. Para un proyecto pequeño en R es esencial que cada script comience con una descripción de sus contenidos para que podamos saber rápidamente de qué se trata. Eso es lo que hicimos al principio de este libro: # ------------------------------------------------------------ # Aquí hay un script para adquirir los conceptos básicos # con R # fecha de creación : 25/06/2018 # autor : François Rebaudo # ------------------------------------------------------------ # [1] Creación del objeto número de repeticiones. # ------------------------------------------------------------ nbrRep &lt;- 5 # [2] calculos simples # ------------------------------------------------------------ pi * nbrRep^2 Aquí los comentarios que siguen al encabezado no son necesarios porque el nombre del objeto se entiende por sí mismo. Nuestro archivo se convierte en: # ------------------------------------------------------------ # Aquí hay un script para adquirir los conceptos básicos # con R # fecha de creación : 25/06/2018 # autor : François Rebaudo # ------------------------------------------------------------ nbrRep &lt;- 5 pi * nbrRep^2 Para un proyecto grande con muchas funciones para ser utilizado por otros usuarios, es preferible que la documentación del código esté separada, en un archivo de ayuda específico. Este es el caso de todos los paquetes R! Para gestionar la documentación de un paquete (y por lo tanto de todas las funciones), de nuevo hay muchas posibilidades. Lo más común es usar el paquete R roxigen2. Sin entrar en detalles, aquí hay algunos ejemplos de la documentación del paquete. #&#39; Add together two numbers #&#39; #&#39; @param x A number #&#39; @param y A number #&#39; @return The sum of \\code{x} and \\code{y} #&#39; @examples #&#39; add(1, 1) #&#39; add(10, 1) add &lt;- function(x, y) { x + y } #&#39; Sum of vector elements. #&#39; #&#39; `sum` returns the sum of all the values present in its arguments. #&#39; #&#39; This is a generic function: methods can be defined for it directly #&#39; or via the [Summary()] group generic. For this to work properly, #&#39; the arguments `...` should be unnamed, and dispatch is on the #&#39; first argument. sum &lt;- function(..., na.rm = TRUE) {} Esto nos permite escribir la documentación de cada función junto a la función. El paquete roxigen2 generará a partir de estos comentarios un documento de ayuda accesible con la función '?'. A menos que escribamos un nuevo paquete, los comentarios simples serán suficientes, y el desarrollo de un paquete está fuera del alcance de este libro. 10.4 Conclusión Felicitaciones. Este capítulo marca el final de la primera parte de este libro. Ahora tenemos lo básico para llevar a cabo nuestros proyectos con R. En la siguiente parte veremos los gráficos y cómo hacer figuras en el marco de los artículos científicos. "],["graph1.html", " 11 Gráficos simples 11.1 plot 11.2 hist 11.3 barplot 11.4 boxplot 11.5 Otros gráficos 11.6 Conclusión", " 11 Gráficos simples 11.1 plot El primer tipo de gráfico que veremos es la nube de puntos. En un diagrama de dispersión, cada punto está representado por su valor en x e y. La función para hacer un diagrama de dispersión es plot(). myX &lt;- rnorm(50, mean = 0, sd = 1) myY &lt;- rnorm(50, mean = 10, sd = 1) plot(x = myX, y = myY) Al igual que con todos los tipos de gráficos, podemos agregar una leyenda en los ejes x e y. plot(x = myX, y = myY, xlab = &quot;X&quot;, ylab = &quot;Y&quot;) También podemos definir los límites de los ejes X e Y. plot(x = myX, y = myY, xlab = &quot;X&quot;, ylab = &quot;Y&quot;, xlim = c(-3, 3), ylim = c(7, 13)) El tipo de punto se puede establecer con el argumento pch que puede tomar un carácter o un número del 1 al 25. plot(x = rep(seq(1:5), 5), y = rep(seq(1:5), each = 5), pch = 1:25) plot(x = myX, y = myY, pch = c(&quot;a&quot;, &quot;@&quot;, &quot;#&quot;, &quot;1&quot;, &quot;=&quot;, &quot;-&quot;, &quot;_&quot;, &quot;o&quot;, &quot;O&quot;, &quot;0&quot;, letters[1:15])) El tamaño de los puntos se puede definir con el argumento cex. plot(x = myX, y = myY, cex = seq(from = 0.5, to = 3, length.out = 50)) El color de los puntos se puede definir con el argumento col. Volveremos a los colores en un próximo capítulo. myX &lt;- rnorm(100, mean = 0, sd = 1) myY &lt;- rnorm(100, mean = 10, sd = 1) plot(x = myX, y = myY, cex = seq(from = 0.5, to = 3, length.out = 100), pch = 16, col = sample(colors(), 100)) Para representar nuestros puntos, el color y el tamaño de los puntos pueden representar información adicional. Aquí representaremos por un gradiente de tamaño la variable myY y por un gradiente de color la variablemyX. myX &lt;- rnorm(100) myY &lt;- rnorm(100) dfGraph &lt;- data.frame(myX, myY) dfGraph &lt;- dfGraph[order(dfGraph$myX),] dfGraph$myCol &lt;- colorRampPalette(c(&quot;blue&quot;, &quot;red&quot;))(100) dfGraph &lt;- dfGraph[order(dfGraph$myY),] dfGraph$myCex &lt;- seq(from = 0.5, to = 3, length.out = 100) plot(x = dfGraph$myX, y = dfGraph$myY, cex = dfGraph$myCex, pch = 16, col = dfGraph$myCol, xlab = &quot;&quot;, ylab = &quot;&quot;) R ofrece la posibilidad de conectar puntos de nube de puntos de diferentes maneras. Las diferentes opciones están disponibles en la ayuda de las funciones plot() y plot.default(). myX &lt;- 1:20 myY &lt;- rnorm(20, mean = 10, sd = 1) plot(x = myX, y = myY, type = &#39;b&#39;) # &#39;p&#39;, &#39;l&#39;, &#39;b&#39;, &#39;c&#39;, &#39;o&#39;, &#39;h&#39;, &#39;s&#39;, &#39;S&#39;, &#39;n&#39; Una última opción muy útil es el argumento panel.first que permite realizar una operación gráfica en una capa debajo de nuestro gráfico. Aquí hay un ejemplo ilustrativo con una cuadrícula hecha con y sin panel.first. La cuadrícula se realiza gracias a la función grid(). Para poner los gráficos lado a lado usaremos mfrow. par(mfrow = c(1, 2)) plot(x = myX, y = myY, type = &#39;b&#39;, pch = 16, cex = 3) grid(lwd = 3, lty = 1) plot(x = myX, y = myY, type = &#39;b&#39;, pch = 16, cex = 3, panel.first = grid(lwd = 3, lty = 1)) par(mfrow = c(1, 1)) La función par() proporciona acceso a parámetros gráficos. Entre estos parámetros hay mfrow que permite dividir el espacio gráfico como una matriz. mfrow toma como argumentos un vector numérico de tamaño 2: el primer elemento corresponde al número de líneas y el segundo elemento al número de columnas. El parámetro mar controla los márgenes en la parte inferior, izquierda, superior y derecha, respectivamente, utilizando un vector digital de tamaño 4. Después de cambiar la configuración de gráficos predeterminada, se recomienda restablecerlos para que no afecte a los futuros gráficos. Los valores predeterminados para mfrow son c(1, 1) y mar = c (4, 4, 4, 4). Podemos restablecer estos valores predeterminados como antes, redefiniendo cada parámetro. También podemos guardar los valores actuales (en un objeto op) de antemano, modificarlos para los propósitos de nuestros gráficos y luego recuperar los valores contenidos en el objeto op. Aquí usamos lapply para hacer rápidamente cuatro gráficos. op &lt;- par(no.readonly = TRUE) par(mfrow = c(2, 2), mar = c(2, 2, 1, 1)) graph4 &lt;- lapply(1:4, function(i){ plot(x = rnorm(100), y = rnorm(100), col = i, pch = 16) }) par(op) Es útil incluir líneas verticales u horizontales para representar valores particulares. Estas líneas se pueden agregar con la función abline(). myX &lt;- rnorm(100) myY &lt;- rnorm(100) plot(x = myX, y = myY, xlim = c(-4, 4), ylim = c(-4, 4), pch = 16, cex = 1.5, col = sample(colors(), size = 100), panel.first = { grid() abline(v = c(min(myX), max(myX)), lty = 2) abline(h = c(min(myY), max(myY)), lty = 2) abline(v = mean(myX), lty = 1) abline(h = mean(myY), lty = 1) }) 11.2 hist Para hacer un histograma usamos la función hist(). Esta es una función gráfica útil para visualizar rápidamente la distribución de un conjunto de datos. op &lt;- par(no.readonly = TRUE) par(mfrow = c(2, 2), mar = c(2, 2, 1, 1)) myX &lt;- list( rnorm(1000), rgamma(1000, shape = 1), sample(1:100, size = 1000, replace = TRUE), rbeta(1000, shape1 = 1, shape2 = 2) ) myTitle &lt;- c(&quot;Normal&quot;, &quot;Gamma&quot;, &quot;Uniform&quot;, &quot;Beta&quot;) tr &lt;- lapply(1:4, function(i){ hist(myX[[i]], col = heat.colors(15), main = myTitle[i] ) }) par(op) 11.3 barplot El gráfico de barras se realiza utilizando la función barplot(). myX &lt;- c(4, 5, 8) barplot(myX, names.arg = c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;)) Cuando el objeto enviado a esta función es un vector, entonces la función barplot() devuelve un gráfico de barras simple. Cuando es un matrix entonces las barras son múltiples. op &lt;- par(no.readonly = TRUE) par(mfrow = c(1, 2), mar = c(2, 2, 1, 1)) myX &lt;- matrix(c(4, 5, 8, 4, 6, 2), nrow = 2) barplot(myX, names.arg = c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;)) myX &lt;- matrix(c(4, 5, 8, 4, 6, 2, 3, 4, 5), nrow = 3) barplot(myX, names.arg = c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;)) par(op) La función barplot() también se puede usar para representar el equivalente de un histograma. Esto puede ser útil para representar la distribución de una variable en función del eje x el eje y. En el siguiente ejemplo tenemos n puntos tomados aleatoriamente en una distribución normal con la configuración mean = 0 y sd = 1 (myX &lt;- rnorm(n)). Estos puntos son para ser mostrado en azul o en rojo (el color azul se codifica con el valor 4 y el color rojo con el valor 2, discutiremos en un capítulo posterior). La eleccion aleatoria del color se realiza con la función sample() (myCol &lt;- sample(c(4, 2), size = n, replace = TRUE)). Aquí queremos representar una nube de puntos con puntos rojos o azules, y histogramas de los ejes X y Y para ver la distribución de puntos (con un degradado de color de azul a rojo dependiendo La proporción de puntos de color en cada categoría con un degradado de color con 100 valores entre azul y rojo ; Mycolors &lt;- colorRampPalette (c(\"azul\", \"rojo\"))(100)). Para hacer el histograma, cortaremos los datos con la función cut(), especificando que queremos que las separaciones se realicen entre -4 y 4 en pasos de 1 (myYCut &lt;- cut(myY, breaks = -4:4)). Para contar el número de puntos en cada categoría y para cada color, solo usamos la función table() (myYCutCol &lt;- table(myCol, myYCut)). En esta tabla, la primera línea corresponde al primer color encontrado en el conjunto de datos y la segunda línea al otro color. Es por eso que necesitamos cambiar el dibujo aleatorio de los colores para que la primera línea siempre corresponda a azul y la segunda línea a rojo: myCol &lt;- c(2, sample(c(4, 2), size = (n - 1), replace = TRUE)). Luego podemos calcular la proporción de rojo dividiendo la primera línea por la suma de las dos líneas que representaremos en porcentaje multiplicando por 100: myXCutCol[1,] / (myXCutCol[1,] + myXCutCol[2,]) * 100. Para que este número coincida con un color, solo mantendremos su parte entera con la función round(). Si el porcentaje es cero o si el resultado no es posible debido a una división por cero, debemos reemplazarlo con 1 para que corresponda a un color en nuestro gradiente que va de 1 a 100 (xCol[is.na(xCol) | xCol == 0] &lt;- 1). Todo lo que nos queda es organizar el espacio gráfico con la función layout() que toma como argumento una matriz cuyos valores y su posición corresponderán al diseño de los diferentes gráficos que queremos lograr. El gráfico 1 corresponde al gráfico de barras superior, el gráfico 2 a la nube de puntos y el gráfico 3 al gráfico de barras derecho. n &lt;- 50 myX &lt;- rnorm(n) myY &lt;- rnorm(n) myCol &lt;- c(2, sample(c(4, 2), size = (n - 1), replace = TRUE)) myColors &lt;- colorRampPalette(c(&quot;blue&quot;, &quot;red&quot;))(100) myYCut &lt;- cut(myY, breaks = -4:4) myXCut &lt;- cut(myX, breaks = -4:4) myYCutCol &lt;- table(myCol, myYCut) myXCutCol &lt;- table(myCol, myXCut) xCol &lt;- round( myXCutCol[1,] / (myXCutCol[1,] + myXCutCol[2,]) * 100 ) xCol[is.na(xCol) | xCol == 0] &lt;- 1 yCol &lt;- round( myYCutCol[1,] / (myYCutCol[1,] + myYCutCol[2,]) * 100 ) yCol[is.na(yCol) | yCol == 0] &lt;- 1 op &lt;- par(no.readonly = TRUE) par(mar = c(2, 3, 1, 1)) layout(matrix(c(1, 1, 0, 2, 2, 3, 2, 2, 3), ncol = 3, byrow = TRUE)) barplot(table(myXCut), las = 1, col = myColors[xCol]) plot(x = myX, y = myY, col = myCol, pch = 16, xlim = c(-4, 4), ylim = c(-4, 4), cex = 1.5, panel.first = grid()) barplot(table(myYCut), las = 1, horiz = TRUE, col = myColors[yCol]) par(op) Luego podemos integrar este script en una función para, por ejemplo, estudiar el efecto de la variable n. graphBarplotCol &lt;- function(n){ myX &lt;- rnorm(n) myY &lt;- rnorm(n) myCol &lt;- c(2, sample(c(4, 2), size = (n - 1), replace = TRUE)) myColors &lt;- colorRampPalette(c(&quot;blue&quot;, &quot;red&quot;))(100) myYCut &lt;- cut(myY, breaks = -4:4) myXCut &lt;- cut(myX, breaks = -4:4) myYCutCol &lt;- table(myCol, myYCut) myXCutCol &lt;- table(myCol, myXCut) xCol &lt;- round( myXCutCol[1,] / (myXCutCol[1,] + myXCutCol[2,]) * 100 ) xCol[is.na(xCol) | xCol == 0] &lt;- 1 yCol &lt;- round( myYCutCol[1,] / (myYCutCol[1,] + myYCutCol[2,]) * 100 ) yCol[is.na(yCol) | yCol == 0] &lt;- 1 op &lt;- par(no.readonly = TRUE) par(mar = c(2, 3, 1, 1)) layout(matrix(c(1, 1, 0, 2, 2, 3, 2, 2, 3), ncol = 3, byrow = TRUE)) barplot(table(myXCut), las = 1, col = myColors[xCol]) plot(x = myX, y = myY, col = myCol, pch = 16, xlim = c(-4, 4), ylim = c(-4, 4), cex = 1.5, panel.first = grid()) barplot(table(myYCut), las = 1, horiz = TRUE, col = myColors[yCol]) par(op) } graphBarplotCol(n = 1000) Por supuesto, un barplot puede tomar valores positivos o negativos. barplot(rnorm(20), horiz = TRUE, col = rainbow(20)) El barplot también se puede usar para hacer una pirámide de edades (hay funciones para realizar las las pirámides de edades, aquí el objetivo es educativo). gender &lt;- data.frame( m = cut(sample(1:75, 1000, replace = TRUE), breaks = seq(from = 0, to = 80, by = 10)), f = cut(sample(1:75, 1000, replace = TRUE), breaks = seq(from = 0, to = 80, by = 10)) ) op &lt;- par(no.readonly = TRUE) par(mfrow = c(1, 2), mar = c(2, 1, 2, 1)) barplot(-table(gender$f), horiz = TRUE, col = &quot;salmon&quot;) barplot(table(gender$m), horiz = TRUE, col = &quot;lightblue&quot;) par(op) 11.4 boxplot Los diagramas de caja son gráficos muy comunes con R porque ofrecen una buena vista de un conjunto de datos al representar los valores extremos (valores atípicos), la mediana, los cuartiles, los mínimos y los máximos. La función boxplot() se aplica a uno o más vector. df &lt;- data.frame( box1 = rnorm(1000), box2 = rgamma(1000, shape = 1), box3 = sample(-3:3, size = 1000, replace = TRUE), box4 = rbeta(1000, shape1 = 1, shape2 = 2) ) boxplot(df, col = c(rgb(0, 94, 255, maxColorValue = 255), rgb(255, 0, 174, maxColorValue = 255), rgb(255, 136, 0, maxColorValue = 255), rgb(119, 255, 0, maxColorValue = 255))) Si una variable es de tipo factor, la función boxplot() facilita la representación de cada categoría. También funciona con variables numéricas, pero se debe tener cuidado de no tener demasiados valores diferentes para que el gráfico permanezca legible. df$cat &lt;- sample(c(&quot;w&quot;, &quot;x&quot;, &quot;y&quot;, &quot;z&quot;), size = 1000, replace = TRUE) boxplot(df$box3 ~ df$cat, col = c(rgb(0, 94, 255, maxColorValue = 255), rgb(255, 0, 174, maxColorValue = 255), rgb(255, 136, 0, maxColorValue = 255), rgb(119, 255, 0, maxColorValue = 255)), ylab = &quot;Box3&quot;) df$cat2 &lt;- sample(1:3, size = 1000, replace = TRUE) boxplot(df$box4 ~ df$cat*df$cat2, col = c( rgb(0, 94, 255, maxColorValue = 255), rgb(255, 0, 174, maxColorValue = 255), rgb(255, 136, 0, maxColorValue = 255), rgb(119, 255, 0, maxColorValue = 255)), ylab = &quot;Box4&quot;) El boxplot puede representarse horizontal o verticalmente. df$cat &lt;- sample(c(&quot;w&quot;, &quot;x&quot;, &quot;y&quot;, &quot;z&quot;), size = 1000, replace = TRUE) boxplot(df$box2 ~ df$cat, horizontal = TRUE, col = c(rgb(255, 110, 0, maxColorValue = 255), rgb(230, 255, 0, maxColorValue = 255), rgb(0, 178, 255, maxColorValue = 255), rgb(166, 0, 255, maxColorValue = 255)), xlab = &quot;Box2&quot;) 11.5 Otros gráficos Hay muchos otros gráficos, pero los que acabamos de ver son la base. Para obtener más información e ideas para representar sus datos, podemos consultar el hermoso sitio https://www.data-to-viz.com/ o la galería gráfica R https://www.r-graph-gallery.com/ (la mayoría de los gráficos se realizan con el paquete ggplot2 que veremos más adelante). Para obtener más ideas, también podemos usar la demostración del paquete graphics usando el comando demo('graphics') (la tecla Enter se usa para mostrar los gráficos). 11.6 Conclusión Felicitaciones, hemos llegado al final de este capítulo sobre gráficos simples. Ahora sabemos cómo hacer que los gráficos principales plot(), hist(), barplot(), y boxplot(). A lo largo de este capítulo, hemos utilizado diferentes colores y diferentes formas de representar los colores: es hora de formalizar el uso y la gestión de los colores. ¡Este es el tema del próximo capítulo! "],["graph2.html", " 12 Gestión del color 12.1 colors() 12.2 rgb() 12.3 Paletas de colores 12.4 Conclusión", " 12 Gestión del color Hemos visto diferentes formas de usar los colores: con su nombre (por ejemplo, \"salmón\"), con un número del 1 al 8, con la función rgb() (para rojo / red, verde / green, azul / blue), y con la función colors(). Hay otros pero estos son los principales. El uso de los números del 1 al 8 corresponde a negro, rojo, verde, azul, cian, magenta, amarillo y gris. Este uso es útil para visualizar rápidamente nuestros resultados, pero proporciona gráficos generales visualmente promedio. Es preferable evitar estos colores para comunicar nuestros gráficos o para construir figuras en revistas científicas. barplot(sample(10:15, 8, replace = TRUE), col = 1:8, names.arg = 1:8) 12.1 colors() Para elegir colores más agradables y resaltar nuestros resultados, una opción es elegir de la lista de colores pregrabados en R. Podemos acceder a la lista de colores con la función colors() head(colors(), n = 20) ## [1] &quot;white&quot; &quot;aliceblue&quot; &quot;antiquewhite&quot; &quot;antiquewhite1&quot; ## [5] &quot;antiquewhite2&quot; &quot;antiquewhite3&quot; &quot;antiquewhite4&quot; &quot;aquamarine&quot; ## [9] &quot;aquamarine1&quot; &quot;aquamarine2&quot; &quot;aquamarine3&quot; &quot;aquamarine4&quot; ## [13] &quot;azure&quot; &quot;azure1&quot; &quot;azure2&quot; &quot;azure3&quot; ## [17] &quot;azure4&quot; &quot;beige&quot; &quot;bisque&quot; &quot;bisque1&quot; Podemos usar estos colores con sus nombres (por ejemplo, \"white\", \"azure3\"), o con su número (por ejemplo, white = colors()[1], azure3 = colors()[16]). # adapted from http://www.r-graph-gallery.com/42-colors-names/ op &lt;- par(no.readonly = TRUE) par(mar = c(0, 0, 0, 0)) plot(0, type = &quot;n&quot;, xlim = c(0, 1), ylim = c(0, 1), axes = FALSE, xlab = &quot;&quot;, ylab = &quot;&quot;) numRow &lt;- 26 numCol &lt;- 26 rect( xleft = rep((0:(numCol - 1)/numCol), numRow), ybottom = sort(rep((0:(numRow - 1)/numRow),numCol), decreasing = TRUE), xright = rep((1:numCol/numCol), numRow), ytop = sort(rep((1:numRow/numRow), numCol), decreasing = TRUE), border = grey(0.5), col = colors()[seq(1, numRow*numCol)]) myLabels &lt;- c(as.character(1:657), rep(&quot;&quot;, numRow*numCol - 657)) text( x = rep((0:(numCol - 1)/numCol), numRow) + 0.02, y = sort(rep((0:(numRow - 1)/numRow), numCol), decreasing = TRUE) + 0.02, labels = myLabels, cex = 0.6) par(op) 12.2 rgb() Otra opción es crear nuestros propios colores con la función rgb(), que toma la cantidad de rojo, verde y azul como argumentos. De forma predeterminada, estos valores se encuentran entre 0 y 1. Esta configuración predeterminada se puede cambiar con el argumento maxColorValue para, por ejemplo, tener valores entre 0 y 255 (maxColorValue = 255, estándar para la representación del color RGB) . Vamos a reanudar nuestra función para representar la distribución de puntos en un diagrama de dispersión por medio de barplot con este tiempo tres colores de puntos (rojo, verde, azul) y un barplot cuyo color corresponderá a la cantidad de cada color con la función rgb(). graphBarplotCol &lt;- function(n){ myX &lt;- rnorm(n) myY &lt;- rnorm(n) myCol &lt;- c(2, 3, 4, sample(2:4, size = (n - 3), replace = TRUE)) myYCut &lt;- cut(myY, breaks = -4:4) myXCut &lt;- cut(myX, breaks = -4:4) myYCutCol &lt;- table(myCol, myYCut) myXCutCol &lt;- table(myCol, myXCut) rColX &lt;- myXCutCol[1,] / (myXCutCol[1,] + myXCutCol[2,] + myXCutCol[3,]) gColX &lt;- myXCutCol[2,] / (myXCutCol[1,] + myXCutCol[2,] + myXCutCol[3,]) bColX &lt;- myXCutCol[3,] / (myXCutCol[1,] + myXCutCol[2,] + myXCutCol[3,]) rColX[is.na(rColX)] &lt;- 0 gColX[is.na(gColX)] &lt;- 0 bColX[is.na(bColX)] &lt;- 0 rColY &lt;- myYCutCol[1,] / (myYCutCol[1,] + myYCutCol[2,] + myYCutCol[3,]) gColY &lt;- myYCutCol[2,] / (myYCutCol[1,] + myYCutCol[2,] + myYCutCol[3,]) bColY &lt;- myYCutCol[3,] / (myYCutCol[1,] + myYCutCol[2,] + myYCutCol[3,]) rColY[is.na(rColY)] &lt;- 0 gColY[is.na(gColY)] &lt;- 0 bColY[is.na(bColY)] &lt;- 0 op &lt;- par(no.readonly = TRUE) par(mar = c(2, 3, 1, 1)) layout(matrix(c(1, 1, 0, 2, 2, 3, 2, 2, 3), ncol = 3, byrow = TRUE)) barplot(table(myXCut), las = 1, col = rgb(rColX, gColX, bColX)) plot(x = myX, y = myY, col = myCol, pch = 16, xlim = c(-4, 4), ylim = c(-4, 4), cex = 1.5, panel.first = grid()) barplot(table(myYCut), las = 1, horiz = TRUE, col = rgb(rColY, gColY, bColY)) par(op) } graphBarplotCol(n = 50) Con la función rgb() podemos representar 256^3 colores, o 167 777 216 colores diferentes. Nuestro objetivo, sin embargo, es hacer gráficos que sean divertidos de leer y que hagan un buen uso de nuestros resultados científicos. Por lo tanto, debemos elegir los colores adecuados para nuestro propósito. Por eso utilizaremos paletas de colores. 12.3 Paletas de colores Las paletas son esquemas de color representados como un vector con colores en formato hexadecimal (valor devuelto por la función rgb()). myPal &lt;- c( rgb(0, 94, 255, maxColorValue = 255), rgb(255, 0, 174, maxColorValue = 255), rgb(255, 136, 0, maxColorValue = 255), rgb(119, 255, 0, maxColorValue = 255)) print(myPal) ## [1] &quot;#005EFF&quot; &quot;#FF00AE&quot; &quot;#FF8800&quot; &quot;#77FF00&quot; boxplot(matrix(rnorm(100), ncol = 5), col = myPal, axes = FALSE) axis(1) axis(2) Hay paletas de colores incluidos en R: terrain.colors(), heat.colors(), topo.colors(), cm.colors(), rainbow(). op &lt;- par(no.readonly = TRUE) par(mfrow = c(2, 3), mar = c(0, 0, 2, 0)) boxplot(matrix(rnorm(1000), ncol = 10), main = &quot;terrain.colors()&quot;, col = terrain.colors(10), axes = FALSE) boxplot(matrix(rnorm(1000), ncol = 10), main = &quot;heat.colors()&quot;, col = heat.colors(10), axes = FALSE) boxplot(matrix(rnorm(1000), ncol = 10), main = &quot;topo.colors()&quot;, col = topo.colors(10), axes = FALSE) boxplot(matrix(rnorm(1000), ncol = 10), main = &quot;cm.colors()&quot;, col = cm.colors(10), axes = FALSE) boxplot(matrix(rnorm(1000), ncol = 10), main = &quot;rainbow()&quot;, col = rainbow(10), axes = FALSE) par(op) También hay una función colorRampPalette() que nos permite crear un degradado de color. op &lt;- par(no.readonly = TRUE) par(mfrow = c(3, 1), mar = c(0, 0, 0, 0)) boxplot(matrix(rnorm(2500), ncol = 25), col = colorRampPalette(c(&#39;blue&#39;, &#39;red&#39;))(25), axes = FALSE) boxplot(matrix(rnorm(2500), ncol = 25), col = colorRampPalette(c(&#39;blue&#39;, &#39;white&#39;, &#39;red&#39;))(25), axes = FALSE) boxplot(matrix(rnorm(2500), ncol = 25), col = colorRampPalette(c(rgb(255, 136, 0, maxColorValue = 255), rgb(0, 94, 255, maxColorValue = 255)))(25), axes = FALSE) par(op) También podemos crear nuestras propias paletas utilizando sitios web de selección de colores como http://paletton.com/ o https://coolors.co/ (hay muchos más), y luego utilizarlos en R copiando en un vector los valores hexadecimales o rgb. R es un lenguaje de programación muy poderoso. Podemos imaginar muchas formas de crear paletas automáticamente de acuerdo con varios criterios. Por ejemplo, podemos importar una imagen cuyos tonos nos parezcan relevantes, luego extraer la información de cada uno de los puntos y luego seleccionar los colores dominantes a través de una agrupación tipo kmeans. Eso es lo que hace la siguiente función. Primero, cargaremos los paquetes raster,rgdal y jpeg que se utilizarán para manipular nuestra imagen en R. pkgCheck &lt;- function(x){ if (!require(x, character.only = TRUE)){ install.packages(x, dependencies = TRUE) if(!require(x, character.only = TRUE)) { stop() } } } pkgCheck(&quot;raster&quot;) ## Le chargement a nécessité le package : raster ## Le chargement a nécessité le package : sp pkgCheck(&quot;rgdal&quot;) ## Le chargement a nécessité le package : rgdal ## rgdal: version: 1.5-19, (SVN revision 1092) ## Geospatial Data Abstraction Library extensions to R successfully loaded ## Loaded GDAL runtime: GDAL 3.0.4, released 2020/01/28 ## Path to GDAL shared files: C:/Users/nous/Documents/R/win-library/4.0/rgdal/gdal ## GDAL binary built with GEOS: TRUE ## Loaded PROJ runtime: Rel. 6.3.1, February 10th, 2020, [PJ_VERSION: 631] ## Path to PROJ shared files: C:/Users/nous/Documents/R/win-library/4.0/rgdal/proj ## Linking to sp version:1.4-5 ## To mute warnings of possible GDAL/OSR exportToProj4() degradation, ## use options(&quot;rgdal_show_exportToProj4_warnings&quot;=&quot;none&quot;) before loading rgdal. pkgCheck(&quot;jpeg&quot;) ## Le chargement a nécessité le package : jpeg Luego usaremos la función kmeans() para realizar grupos de colores usando los valores RGB de cada punto en nuestra imagen. Aquí tenemos dos métodos posibles, el primero usa la función kmeans() para los tres valores RGB, y el segundo usa la función kmeans() para cada valor RGB individualmente (esta segunda función proporciona una paleta que puede ser bastante alejado de los colores de la imagen original). createPal &lt;- function(photo, met = 1, graph = TRUE, k = 9){ if(met == 1){ colR &lt;- getValues(raster(photo, band = 1)) colG &lt;- getValues(raster(photo, band = 2)) colB &lt;- getValues(raster(photo, band = 3)) kMeans &lt;- kmeans(data.frame(colR, colG, colB), centers = k) kCol &lt;- rgb(kMeans$centers, maxColorValue = 255)[order(table( kMeans$cluster), decreasing = TRUE)] if(graph == TRUE){ op &lt;- par(no.readonly = TRUE) par(mfrow = c (1, 2), mar = c(0, 2, 2, 0)) myJpg &lt;- readJPEG(&quot;./myFiles/photoKmeans.jpg&quot;, native = TRUE) plot(0:1, 0:1, type = &quot;n&quot;, ann = FALSE, axes = FALSE) rasterImage(myJpg, 0, 0, 1, 1) barplot(table(kMeans$cluster)[order(table(kMeans$cluster), decreasing = TRUE)], col = kCol, names.arg = NA) par(op) } return(kCol) } else { if(met == 2){ kColR &lt;- kmeans(x = getValues(raster(photo, band = 1)), centers = k) kColG &lt;- kmeans(x = getValues(raster(photo, band = 2)), centers = k) kColB &lt;- kmeans(x = getValues(raster(photo, band = 3)), centers = k) kCol &lt;- (rgb(kColR$centers, kColG$centers, kColB$centers, maxColorValue = 255)) if(graph == TRUE){ op &lt;- par(no.readonly = TRUE) par(mfrow = c (1, 2), mar = c(0, 2, 2, 0)) myJpg &lt;- readJPEG(&quot;./myFiles/photoKmeans.jpg&quot;, native = TRUE) plot(0:1, 0:1, type = &quot;n&quot;, ann = FALSE, axes = FALSE) rasterImage(myJpg, 0, 0, 1, 1) plot(x = 1:k, y = rep(1, k), ylim = c(0, 1), xlim = c(0, k), axes = FALSE, xlab = &quot;&quot;, ylab = &quot;&quot;, type = &quot;n&quot;) for(i in 1:k){ polygon(x = c(i-1, i, i, i-1), y = c(0, 0, 1, 1), col = kCol[i]) text(x = i - 0.5, y = 0.5, labels = as.character(kCol[i]), srt = 90) } par(op) } return(kCol) } else { print(paste0(&quot;No method &quot;, met, &quot;.&quot;)) return(rgb(0, 0, 0)) } } } myPalMet1 &lt;- createPal(photo = &quot;./myFiles/photoKmeans.jpg&quot;, met = 1, graph = TRUE, k = 5) myPalMet2 &lt;- createPal(photo = &quot;./myFiles/photoKmeans.jpg&quot;, met = 2, graph = TRUE, k = 5) La función nos devuelve los colores de la paleta con un gráfico de barras que representa el número de puntos de la imagen en cada uno de los grupos de colores. Ahora podemos usar nuestra nueva paleta para hacer nuestros gráficos. makeImpact &lt;- function(myPal, numP = 300, impact = 0.33, multCex = 3){ myX &lt;- sample(0:1000, size = numP, replace = TRUE)/1000 myY &lt;- sample(0:1000, size = numP, replace = TRUE)/1000 distImpact &lt;- sqrt((myX - impact)^2 + (myY - impact)^2) dfXY &lt;- data.frame(myX, myY, distImpact) plot(x = dfXY$myX, y = dfXY$myY, axes = FALSE, xlab = &quot;&quot;, ylab = &quot;&quot;, cex = dfXY$distImpact*multCex, col = myPal, pch = 16) } op &lt;- par(no.readonly = TRUE) par(mfrow = c (1, 2), mar = c(0, 0, 0, 0)) makeImpact(myPal = myPalMet1, numP = 3000, impact = 0.33) makeImpact(myPal = myPalMet2, numP = 3000, impact = 0.66) par(op) 12.4 Conclusión Felicitaciones ! Este es el final de este capítulo sobre la gestión del color. Ahora sabemos cómo usar colores y paletas, y cómo guiar la selección de colores para resaltar nuestros resultados. En el siguiente capítulo veremos algunos ejemplos de paquetes de gráficos y las últimas tendencias, como los gráficos dinámicos. "],["graph3.html", " 13 Paquetes gráficos 13.1 Los paquetes con paletas 13.2 ggplot2 package 13.3 Gráficos interactivos y dinámicos con Plotly 13.4 Conclusión", " 13 Paquetes gráficos 13.1 Los paquetes con paletas 13.1.1 RColorBrewer El paquete RColorBrewer es un paquete de referencia porque contiene paletas adicionales a las disponibles en la versión básica de R. Una vez que el paquete está instalado, solo llamamos a las paletas para utilizarlas. Aquí están las paletas disponibles y un ejemplo de uso. pkgCheck &lt;- function(x){ if (!require(x, character.only = TRUE)){ install.packages(x, dependencies = TRUE) if(!require(x, character.only = TRUE)) { stop() } } } pkgCheck(&quot;RColorBrewer&quot;) ## Le chargement a nécessité le package : RColorBrewer display.brewer.all() boxplot(matrix(rnorm(1000), ncol = 10), col = brewer.pal(10, &quot;Paired&quot;), axes = FALSE) 13.1.2 palettesForR El paquete palettesForR es otro paquete que contiene paletas listas para usar de los proyectos Gimp y Inkscape. Una vez que el paquete está instalado, solo llamamos a las paletas para utilizarlas. Las muchas paletas disponibles se enumeran en la ayuda del paquete (hay 48 paletas). Aquí hay un ejemplo de uso. pkgCheck &lt;- function(x){ if (!require(x, character.only = TRUE)){ install.packages(x, dependencies = TRUE) if(!require(x, character.only = TRUE)) { stop() } } } pkgCheck(&quot;palettesForR&quot;) ## Le chargement a nécessité le package : palettesForR showPalette(Echo_gpl) groupTest &lt;- sample(1:3, size = 100, replace = TRUE) valueTest &lt;- sample(1:7, size = 100, replace = TRUE) tableTest &lt;- table(groupTest, valueTest) barplot(tableTest, col = Echo_gpl, axes = FALSE, beside = TRUE) groupTest &lt;- sample(1:3, size = 100, replace = TRUE) valueTest &lt;- sample(1:7, size = 100, replace = TRUE) tableTest &lt;- table(groupTest, valueTest) barplot(tableTest, col = Tango_gpl, axes = FALSE, beside = TRUE) 13.1.3 Otros paquetes Hay muchos paquetes que contienen paletas. Por ejemplo : viridis (https://CRAN.R-project.org/package=viridis) jcolors (https://CRAN.R-project.org/package=jcolors) scico (https://CRAN.R-project.org/package=scico)  13.2 ggplot2 package El paquete ggplot2 es una alternativa a las funciones básicas de R para realizar gráficos. Se basa en La Gramática de Gráficos Leland Wilkinson y permite gráficos en capas, por lo general con un resultado superior si consideramos el aspecto estético en comparacion con las funciones básicas de R. Si para explorar un conjunto de datos ggplot2 es a veces más potente, nuestros gráficos nunca vienen solas y se acompañan de análisis estadísticos que a menudo exigen un trabajo minucioso sobre la gestión de datos. Una vez que nuestras hipótesis de trabajo estan probadas estadísticamente, resulta fácil realizar gráficos cual que sea su nivel de complejidad (con las funciones básicas o con ggplot2). Además veremos en el siguiente capítulo que desde la gráfica a la figura en el artículo científico, hay una serie de tratamientos a realizar y el manejo de los parámetros estéticos se puede hacer de forma independiente de R. Así que ggplot2 es un paquete interesante porque ofrece una alternativa con una filosofía diferente en la construcción de gráficos, pero no reemplaza lo que hemos aprendido hasta ahora. En la práctica podemos utilizar uno u otro en función de los datos y de las manipulaciones que queremos hacer. Para volver a ggplot2, empezamos con un ejemplo con los datos iris. pkgCheck &lt;- function(x){ if (!require(x, character.only = TRUE)){ install.packages(x, dependencies = TRUE) if(!require(x, character.only = TRUE)) { stop() } } } pkgCheck(&quot;ggplot2&quot;) ## Le chargement a nécessité le package : ggplot2 data(iris) # ggplot2 p &lt;- ggplot(data = iris, aes(x = Sepal.Length, y = Sepal.Width)) p + geom_point() + ggtitle(&quot;ggplot2&quot;) # base plot(x = iris$Sepal.Length, y = iris$Sepal.Width, main = &quot;base&quot;, pch = 16) Ahora separemos la información según las especies de flores. # ggplot2 p &lt;- ggplot(data = iris, aes(x = Sepal.Length, y = Sepal.Width, colour = Species)) p + geom_point() + ggtitle(&quot;ggplot2&quot;) # base plot(x = iris$Sepal.Length, y = iris$Sepal.Width, main = &quot;base&quot;, pch = 16, col = iris$Species) Parece haber una relación entre el ancho y el largo de los sépalos por especie. # linear regressions lmFits &lt;- lapply(1:3, function(i){ fitSp1 &lt;- lm(iris$Sepal.Width[as.numeric(iris$Species) == i] ~ iris$Sepal.Length[as.numeric(iris$Species) == i]) fStat1 &lt;- summary(fitSp1)$fstatistic rSq1 &lt;- summary(fitSp1)$r.squared pVal1 &lt;- summary(fitSp1)$coefficients[2, 4] stat1 &lt;- paste0(&quot;F=&quot;, round(fStat1[1], digits = 2), &quot;; DF=&quot;, fStat1[2], &quot;/&quot;, fStat1[3], &quot;; r-sq=&quot;, round(rSq1, digits = 2), &quot;; p-val=&quot;, round(pVal1, digits = 6)) return(list(fitSp1, stat1)) }) # ggplot2 p &lt;- ggplot(data = iris, aes(x = Sepal.Length, y = Sepal.Width, colour = Species)) p &lt;- p + geom_point() + ggtitle(&quot;ggplot2&quot;) + stat_smooth(method = &quot;lm&quot;, se = FALSE) p &lt;- p + annotate(geom = &quot;text&quot;, x = 6, y = 2.250, label = lmFits[[1]][[2]], colour = 2) p &lt;- p + annotate(geom = &quot;text&quot;, x = 6, y = 2.125, label = lmFits[[2]][[2]], colour = 3) p &lt;- p + annotate(geom = &quot;text&quot;, x = 6, y = 2.000, label = lmFits[[3]][[2]], colour = 4) p ## `geom_smooth()` using formula &#39;y ~ x&#39; # base plot(x = iris$Sepal.Length, y = iris$Sepal.Width, main = &quot;base&quot;, pch = 16, col = iris$Species) abline(lmFits[[1]][[1]], col = 1) abline(lmFits[[2]][[1]], col = 2) abline(lmFits[[3]][[1]], col = 3) text(x = 5.5, y = 2.2, labels = lmFits[[1]][[2]], pos = 4) text(x = 5.5, y = 2.1, labels = lmFits[[2]][[2]], pos = 4, col = 2) text(x = 5.5, y = 2.0, labels = lmFits[[3]][[2]], pos = 4, col = 3) Podemos ver en estos ejemplos que los gráficos con ggplot2 comienzan con una llamada a la función ggplot(), en la cual el primer argumento datos coincide con nuestros datos (generalmente un data.frame), y El segundo argumento aes() es la información que queremos usar. Por convención, esta información se almacena en un objeto p. Luego agregaremos capas adicionales usando +. En las capas podemos agregar aspectos geométricos (el tipo de gráfico, por ejemplo, geom_point()), estadísticas (por ejemplo, stat_smooth()), anotaciones (por ejemplo, annotate()), y otras cosas relacionadas con los ejes, los colores,  La documentación completa se puede consultar en la dirección https://ggplot2.tidyverse.org/ (hoja de resumen: https://github.com/rstudio/cheatsheets/blob/master/data-visualization-2.1.pdf). Muchas extensiones a ggplot2 están disponibles en http://www.ggplot2-exts.org/gallery/. 13.3 Gráficos interactivos y dinámicos con Plotly Plotly es un paquete para gráficos interactivos y dinámicos. Esto puede ser particularmente útil para los resultados que se difunden a través de Internet. El paquete se instala como cualquier otro con install.packages(\"plotly\"). El paquete es gratuito y de código abierto. Este ejemplo se ha copiado del libro de Carson Sievert (https://plotly-book.cpsievert.me). El código usado para hacer este gráfico está licenciado bajo la licencia de Estados Unidos Creative Commons Attribution-NonCommercial-NoDerivs 3.0 (Carson Sievert; https://creativecommons.org/licenses/by-nc-nd/3.0/us/). 13.4 Conclusión Este capítulo nos permitió ver otras opciones gráficas y, en particular, los paquetes ggplot2 y plotly. Existen libros específicos (en inglés) que cubren todos los aspectos de estos paquetes, aquí el objetivo es saber que existen estas opciones para usarlos si es necesario. Los sitios web Data to Viz y r-graph gallery (https://www.data-to-viz.com; https://www.r-graph-gallery.com/) son buenos recursos para tener ideas de las posibilidades que ofrece R en cuanto a representaciones gráficas. El siguiente capítulo analiza los procesos necesarios para transformar un gráfico R en una figura publicable en un artículo científico. Hasta muy pronto ! "],["graph4.html", " 14 De la gráfica a la figura en un artículo científico 14.1 Inkscape 14.2 The Gimp 14.3 Tabla de referencia", " 14 De la gráfica a la figura en un artículo científico Una vez que se han obtenido nuestros resultados, es esencial publicarlos. Solo al publicar nuestros resultados estamos involucrados en la ciencia. Esto puede hacerse a través de comunicaciones en congresos, a través de carteles o (y esto es lo más común), a través de artículos científicos. En los artículos científicos, los resultados gráficos toman la forma de figuras que a menudo son el resultado de uno o más gráficos. Figuras siguen criterios muy específicos dictados por la revista. Tomemos este ejemplo adaptado y traducido de la guía para autores de PLoS: Los archivos deben estar en formato TIFF (con compresión LZW y de una sola capa) o EPS. Las dimensiones deben ser de 789 a 2250 píxeles y una altura máxima de 2625 píxeles para una resolución de 300 ppp (entre 6.68 y 19.05 cm de ancho - máximo 13.2 cm para alinear en una columna - y máximo 22.23 cm de alto). La fuente debe ser Arial, Times o Symbol y tener un tamaño de entre 8 y 12 puntos. Resulta difícil (pero posible) respetar todas estas limitaciones con R. Por eso utilizaremos software libres para transformar nuestros gráficos en figuras. Usaremos Inkscape para el diseño y Gimp para la transformación en los formatos requeridos. Cuando tomamos una foto, cada píxel toma un valor que definirá el color del píxel, por lo que al acercar una foto veremos aparecer los píxeles (perdemos el foco). Es una imagen matricial. En una imagen vector, los elementos están codificados en forma de segmentos, no perdemos calidad porque cada elemento retiene sus coordenadas (Figura 14.1). La ventaja de las imágenes vectoriales es que se puede modificar los elementos de la imagen sin perder calidad. Eso es lo que vamos a hacer con Inkscape. La ventaja de las imágenes ráster es que se puede elegir entre muchos formatos (incluido TIFF). Esto es lo que vamos a hacer con Gimp. Figure 14.1: Imagen matricial/raster y vector. 14.1 Inkscape Figure 14.2: Logo Inkscape (https://inkscape.org). Inkscape es un software de dibujo vectorial disponible en Windows, Mac OSX y Linux. Es un software gratuito y de código abierto bajo licencia GPL. Podemos descargarlo en la siguiente dirección https://inkscape.org. Inkscape ya está instalado por defecto en muchas distribuciones de Linux. Explicar toda la funcionalidad de Inkscape está más allá del alcance de este libro, pero podemos encontrar muchos tutoriales en línea para dominar rápidamente esta herramienta. Brevemente, para seguir la guía de construcción de una figura de una revista cientifica, primero construiremos nuestra figura cruda bajo R, luego la exportaremos a PDF usando la función pdf(). pdf(&quot;miFigura.pdf&quot;) plot(0) dev.off() Luego solo tenemos que importar nuestro pdf en Inkscape para modificarlo. Por defecto, el PDF se agrupará en un solo elemento. Para acceder a los subelementos de nuestra figura, podemos seleccionarlos con el atajo Ctrl + Shift + g. Es aconsejable agregar un fondo blanco a nuestra figura para evitar la transparencia (un simple rectángulo blanco sin bordes servirá). Una vez que nuestra figura esté lista para ser exportada, debemos guardarla en un archivo PNG con el acceso directo Ctrl + Shift + e, y luego abrir el PNG con The Gimp. 14.2 The Gimp Figure 14.3: Logo Gimp (https://www.gimp.org/). Gimp es un software de dibujo matricial disponible en Windows, Mac OSX y Linux. Es un software gratuito y de código abierto bajo licencia GPL. Podemos descargarlo en la siguiente dirección: https://www.gimp.org/. Gimp significa GNU Image Manipulation Program. Gimp ya está instalado por defecto en muchas distribuciones de Linux. Importaremos nuestro archivo PNG y luego simplemente lo exportaremos a otro formato con el acceso directo Ctrl + Shift + e. Luego, una ventana propondrá elegir el nuevo formato, por ejemplo, TIFF con compresión LZW. Nuestra figura está lista para la revista de nuestra eleccion. 14.3 Tabla de referencia Aquí hay una tabla de referencia (Table 14.1) con algunas revistas que ilustran la diversidad de formatos para figuras científicas. Table 14.1: Tabla de referencia para figuras en revistas cientificas. Revista Ancho Altura Formato Resolucion Fuente Tamano PLoS 6.68-19.05 max 22.23 TIFF, EPS 300-600 dpi Arial, Times, Symbol 9-12 PNAS 8.7; 11.4; 17.8 max 22.5 TIF, EPS 300 dpi Arial, Helvetica, Times, Symbol, Mathematical Pi, European Pi min 6-8 Science 9; 12.7; 18.4 NA AI, EPS, PDF, TIF, JPEG 300 dpi Helvetica panel 10, axis 6-9, font 5 "],["studyCase1.html", " 15 Analizar datos de loggers de temperatura", " 15 Analizar datos de loggers de temperatura En estudios de biología, ecología, o agronomía, frecuentemente usamos datos de temperatura de dataloggers. En este estudio vamos a ver como analizar esos datos usando datos de temperatura del altiplano Boliviano cerca de la ciudad de El Alto. El primer paso es transformar los datos del datalogger en un formato que sea fácil de leer para R. Usaremos un archivo CSV y la función read.table(). El archivo se puede descargar desde el sitio web del libro en GitHub (https://github.com/frareb/myRBook_SP/blob/master/myFiles/E05C13.csv ; el archivo se puede leer desde su destino en GitHub https://raw.githubusercontent.com/frareb/myRBook_SP/master/myFiles/E05C13.csv). bdd &lt;- read.table(&quot;myFiles/E05C13.csv&quot;, skip = 1, header = TRUE, sep = &quot;,&quot;, dec = &quot;.&quot;, stringsAsFactors = FALSE) # Desde GitHub: # bdd &lt;- read.table(&quot;https://raw.githubusercontent.com/frareb/myRBook_SP/master/myFiles/E05C13.csv&quot;, # skip = 1, header = TRUE, sep = &quot;,&quot;, dec = &quot;.&quot;, stringsAsFactors = FALSE) colnames(bdd) &lt;- c(&quot;id&quot;, &quot;date&quot;, &quot;temp&quot;) head(bdd) ## id date temp ## 1 1 11/12/15 23:00:00 4.973 ## 2 2 11/12/15 23:30:00 4.766 ## 3 3 11/13/15 00:00:00 4.844 ## 4 4 11/13/15 00:30:00 4.844 ## 5 5 11/13/15 01:00:00 5.076 ## 6 6 11/13/15 01:30:00 5.282 tail(bdd) ## id date temp ## 32781 32781 09/25/17 21:00:00 7.091 ## 32782 32782 09/25/17 21:30:00 6.914 ## 32783 32783 09/25/17 22:00:00 6.813 ## 32784 32784 09/25/17 22:30:00 6.611 ## 32785 32785 09/25/17 23:00:00 6.331 ## 32786 32786 09/25/17 23:30:00 5.385 str(bdd) ## &#39;data.frame&#39;: 32786 obs. of 3 variables: ## $ id : int 1 2 3 4 5 6 7 8 9 10 ... ## $ date: chr &quot;11/12/15 23:00:00&quot; &quot;11/12/15 23:30:00&quot; &quot;11/13/15 00:00:00&quot; &quot;11/13/15 00:30:00&quot; ... ## $ temp: num 4.97 4.77 4.84 4.84 5.08 ... Podemos observar que la fecha esta al formato character, y que contiene la fecha con el mes, el día, y el año separados con /, un espacio, y la hora con horas de 0 a 24, minutos, y segundos, separados con : (ejemplo: 11/12/15 23:00:00 para el 12 de Noviembre de 2015 a las 11 de la noche). Vamos a separar la información en varios objetos para ver todas las opciones segun el tipo de datos que se puede tener. Primero vamos a separar la fecha de la hora. Para esto vamos a usar la función strsplit() usando como separador el espacio entre la fecha y la hora. strsplit(&quot;11/12/15 23:00:00&quot;, split = &quot; &quot;) ## [[1]] ## [1] &quot;11/12/15&quot; &quot;23:00:00&quot; Como indican los corchetes dobles, la función devuelve un objeto en el formato list. Nosotros queremos el vector que corresponde al primer elemento de la list entonces vamos a añadir [[1]]. strsplit(&quot;11/12/15 23:00:00&quot;, split = &quot; &quot;)[[1]] ## [1] &quot;11/12/15&quot; &quot;23:00:00&quot; El primer elemento del vector es la fecha. Para tener todas las fechas vamos a hacer un bucle con la función sapply(). bddDay &lt;- sapply(strsplit(bdd[, 2], split = &quot; &quot;), &quot;[[&quot;, 1) head(bddDay) ## [1] &quot;11/12/15&quot; &quot;11/12/15&quot; &quot;11/13/15&quot; &quot;11/13/15&quot; &quot;11/13/15&quot; &quot;11/13/15&quot; A continuación vamos a necesitar las fechas en el formato Date. Entonces necesitamos transformar el objeto en el formato Date con la función as.Date(). bddDay &lt;- as.Date(sapply(strsplit(bdd[, 2], split = &quot; &quot;), &quot;[[&quot;, 1), format = &quot;%m/%d/%y&quot;) head(bddDay) ## [1] &quot;2015-11-12&quot; &quot;2015-11-12&quot; &quot;2015-11-13&quot; &quot;2015-11-13&quot; &quot;2015-11-13&quot; ## [6] &quot;2015-11-13&quot; Vamos a añadir la information al formato Date en nuestro objeto bdd. Con la función str(), podemos ver que el formato de bdd$day es Date. bdd$day &lt;- bddDay str(bdd) ## &#39;data.frame&#39;: 32786 obs. of 4 variables: ## $ id : int 1 2 3 4 5 6 7 8 9 10 ... ## $ date: chr &quot;11/12/15 23:00:00&quot; &quot;11/12/15 23:30:00&quot; &quot;11/13/15 00:00:00&quot; &quot;11/13/15 00:30:00&quot; ... ## $ temp: num 4.97 4.77 4.84 4.84 5.08 ... ## $ day : Date, format: &quot;2015-11-12&quot; &quot;2015-11-12&quot; ... Si necesitamos la información del horario, usaremos el formato POSIX con la función as.POSIXct(). Vamos a añadir la information al formato POSIX en nuestro objeto bdd. Con la función str(), podemos ver que el formato de bdd$posix es POSIXct. bddPosix &lt;- as.POSIXct(bdd$date, format = &quot;%m/%d/%y %H:%M:%S&quot;) head(bddPosix) ## [1] &quot;2015-11-12 23:00:00 CET&quot; &quot;2015-11-12 23:30:00 CET&quot; ## [3] &quot;2015-11-13 00:00:00 CET&quot; &quot;2015-11-13 00:30:00 CET&quot; ## [5] &quot;2015-11-13 01:00:00 CET&quot; &quot;2015-11-13 01:30:00 CET&quot; bdd$posix &lt;- bddPosix str(bdd) ## &#39;data.frame&#39;: 32786 obs. of 5 variables: ## $ id : int 1 2 3 4 5 6 7 8 9 10 ... ## $ date : chr &quot;11/12/15 23:00:00&quot; &quot;11/12/15 23:30:00&quot; &quot;11/13/15 00:00:00&quot; &quot;11/13/15 00:30:00&quot; ... ## $ temp : num 4.97 4.77 4.84 4.84 5.08 ... ## $ day : Date, format: &quot;2015-11-12&quot; &quot;2015-11-12&quot; ... ## $ posix: POSIXct, format: &quot;2015-11-12 23:00:00&quot; &quot;2015-11-12 23:30:00&quot; ... En las funciones as.Date() y as.POSIXct() tenemos que especificar el formato en el cual esta indicado la fecha con el argumento format(format = \"%m/%d/%y\" y format = \"%m/%d/%y %H:%M:%S\"). código Valor %a dia de la semana abreviado %A dia de la semana %b mes abreviado %B nombre completo del mes %d dia del mes (decimal) %j dia del año (decimal) %m mes (decimal) %y año con dos dígitos %Y año con cuatro dígitos %U semana del año desde el domingo (decimal) %W semana del año desde el lunes (decimal) %H hora 24 %I hora 12 %M minuto %S segundo Podemos visualizar los datos con la función plot(). plot(x = bdd$day, y = bdd$temp, type = &#39;l&#39;, ylim = c(-15, 40), xlab = &quot;Fecha&quot;, ylab = &quot;Temperatura (°C)&quot;) Podemos simplificar la información calculando únicamente las temperaturas mínimas, promedias, y máximas del dia con la función tapply(). tempDayMean &lt;- tapply(bdd$temp, INDEX = bdd$day, FUN = mean) tempDayMin &lt;- tapply(bdd$temp, INDEX = bdd$day, FUN = min) tempDayMax &lt;- tapply(bdd$temp, INDEX = bdd$day, FUN = max) plot(x = as.Date(names(tempDayMean), format = &quot;%Y-%m-%d&quot;), y = tempDayMean, type = &#39;l&#39;, ylim = c(-15, 40), xlab = &quot;Fecha&quot;, ylab = &quot;Temperatura (°C)&quot;) points(as.Date(names(tempDayMin), format = &quot;%Y-%m-%d&quot;), y = tempDayMin, type = &#39;l&#39;, col = 4) points(as.Date(names(tempDayMax), format = &quot;%Y-%m-%d&quot;), y = tempDayMax, type = &#39;l&#39;, col = 2) legend(&quot;topright&quot;, legend = c(&quot;min&quot;, &quot;max&quot;, &quot;promedio&quot;), lty = 1, lwd = 2, col = c(4, 2, 1)) Podemos representar la misma información por semana. Para esto vamos a usar la información de los datos en el formato POSIXct para transformala en semanas. anoSem &lt;- format(bdd$posix, format = &quot;%Y-%W&quot;) head(anoSem) ## [1] &quot;2015-45&quot; &quot;2015-45&quot; &quot;2015-45&quot; &quot;2015-45&quot; &quot;2015-45&quot; &quot;2015-45&quot; Y despues hacer el gráfico. tempWeekMean &lt;- tapply(bdd$temp, INDEX = format(bdd$posix, format = &quot;%Y-%W-1&quot;), FUN = mean) tempWeekMin &lt;- tapply(bdd$temp, INDEX = format(bdd$posix, format = &quot;%Y-%W-1&quot;), FUN = min) tempWeekMax &lt;- tapply(bdd$temp, INDEX = format(bdd$posix, format = &quot;%Y-%W-1&quot;), FUN = max) plot(x = as.Date(names(tempWeekMean), format = &quot;%Y-%W-%u&quot;), y = tempWeekMean, type = &#39;l&#39;, ylim = c(-15, 40), xlab = &quot;Fecha&quot;, ylab = &quot;Temperatura (°C)&quot;) points(x = as.Date(names(tempWeekMin), format = &quot;%Y-%W-%u&quot;), y = tempWeekMin, type = &#39;l&#39;, col = 4) points(x = as.Date(names(tempWeekMax), format = &quot;%Y-%W-%u&quot;), y = tempWeekMax, type = &#39;l&#39;, col = 2) legend(&quot;topright&quot;, legend = c(&quot;min&quot;, &quot;max&quot;, &quot;promedio&quot;), lty = 1, lwd = 2, col = c(4, 2, 1)) Para no perder la información sobre la variabilidad de la temperatura podemos hacer boxplot en lugar de plot. boxplot(bdd$temp ~ format(bdd$posix, format = &quot;%Y-%m&quot;), las = 3) Podemos elegir colores para representar la temperatura promedia. Para esto podemos normalizar la temperatura en numeros integrados entre 1 y 101 y hacer corresponder los numeros en una escala de color del azul al rojo. tempMonthMean &lt;- tapply(bdd$temp, INDEX = format(bdd$posix, format = &quot;%Y-%m&quot;), FUN = mean) myCol &lt;- colorRampPalette(c(&quot;blue&quot;, &quot;red&quot;))(101) tempMeanDayPos &lt;- round( (tempMonthMean - min(tempMonthMean)) / (max(tempMonthMean) - min(tempMonthMean))*100) + 1 boxplot(bdd$temp ~ format(bdd$posix, format = &quot;%Y-%m&quot;), las = 3, col = myCol[tempMeanDayPos]) Para los que usan ggplot2: pkgCheck &lt;- function(x){ if (!require(x, character.only = TRUE)){ install.packages(x, dependencies = TRUE) if(!require(x, character.only = TRUE)) { stop() } } } pkgCheck(&quot;ggplot2&quot;) tempMonthMean &lt;- tapply(bdd$temp, INDEX = format(bdd$posix, format = &quot;%Y-%m&quot;), FUN = mean) myCol &lt;- colorRampPalette(c(&quot;blue&quot;, &quot;red&quot;))(101) tempMeanDayPos &lt;- round( (tempMonthMean - min(tempMonthMean)) / (max(tempMonthMean) - min(tempMonthMean))*100) + 1 p01 &lt;- ggplot(data = bdd, aes( x = posix, y = temp, group = format(bdd$posix, format = &quot;%Y-%m&quot;))) + geom_boxplot(outlier.colour = &quot;black&quot;, fill = myCol[tempMeanDayPos]) p01 ## Warning: Use of `bdd$posix` is discouraged. Use `posix` instead. ## Warning: Removed 4 rows containing missing values (stat_boxplot). También podemos calcular la diferencia entre la temperatura máxima y la temperatura mínima (variación de temperatura diurna). tempDayTR &lt;- tempDayMax - tempDayMin plot(x = as.Date(names(tempDayMean), format = &quot;%Y-%m-%d&quot;), y = tempDayTR, type = &#39;l&#39;, ylim = c(5, 45), xlab = &quot;Fecha&quot;, ylab = &quot;Variación de temperatura diurna (°C)&quot;) Otra posibilidad es de agrupar los datos para tener la temperatura promedia de un día con la función aggregate() (como alternativa a la función tapply). tempHourMean &lt;- aggregate(x = bdd$temp, by = list(format(bdd$posix, format = &quot;%H:%M&quot;)), FUN = mean) tempHourMin &lt;- aggregate(x = bdd$temp, by = list(format(bdd$posix, format = &quot;%H:%M&quot;)), FUN = min) tempHourMax &lt;- aggregate(x = bdd$temp, by = list(format(bdd$posix, format = &quot;%H:%M&quot;)), FUN = max) hours &lt;- seq(from = 0, to = 23.5, by = 0.5) plot(x = hours, y = tempHourMean[, 2], type = &#39;l&#39;, ylim = c(-15, 40), xlab = &quot;&quot;, ylab = &quot;Temperatura (°C)&quot;, lwd = 2, xaxt = &quot;n&quot;, panel.first = { abline(v = hours, col = &quot;gray&quot;, lty = 2) abline(h = 0, lty = 2) }) axis(side = 1, at = hours, labels = tempHourMean[, 1], las = 2) points(x = hours, y = tempHourMin[, 2], type = &#39;l&#39;, col = 4, lwd = 2) points(x = hours, y = tempHourMax[, 2], type = &#39;l&#39;, col = 2, lwd = 2) Tambien podemos calcular las temperaturas de los dias para cada mes. meses &lt;- c(&quot;Enero&quot;, &quot;Febrero&quot;, &quot;Marzo&quot;, &quot;Abril&quot;, &quot;Mayo&quot;, &quot;Junio&quot;, &quot;Julio&quot;, &quot;Agosto&quot;, &quot;Septiembre&quot;, &quot;Octubre&quot;, &quot;Noviembre&quot;, &quot;Diciembre&quot;) hours &lt;- seq(from = 0, to = 23.5, by = 0.5) bddMonth &lt;- format(bdd$day, format = &quot;%m&quot;) tempDayEachMonth &lt;- lapply(sort(unique(bddMonth)), function(myMonth){ bddX &lt;- bdd[bddMonth == myMonth, ] tempHourMean &lt;- aggregate(x = bddX$temp, by = list(format(bddX$posix, format = &quot;%H:%M&quot;)), FUN = mean) tempHourMin &lt;- aggregate(x = bddX$temp, by = list(format(bddX$posix, format = &quot;%H:%M&quot;)), FUN = min) tempHourMax &lt;- aggregate(x = bddX$temp, by = list(format(bddX$posix, format = &quot;%H:%M&quot;)), FUN = max) return(data.frame(tempHourMean, tempHourMin, tempHourMax)) }) # for (i in seq_along(tempDayEachMonth)){ # para todos los meses for (i in 1:2){ # solo para Enero y Febrero plot(x = hours, y = tempDayEachMonth[[i]][, 2], type = &#39;l&#39;, ylim = c(-15, 40), xlab = &quot;&quot;, ylab = &quot;Temperatura (°C)&quot;, lwd = 2, main = meses[i], xaxt = &quot;n&quot;, panel.first = { abline(v = hours, col = &quot;gray&quot;, lty = 2) abline(h = 0, lty = 2) }) axis(side = 1, at = hours, labels = tempHourMean[, 1], las = 2) points(x = hours, y = tempDayEachMonth[[i]][, 4], type = &#39;l&#39;, col = 4, lwd = 2) points(x = hours, y = tempDayEachMonth[[i]][, 6], type = &#39;l&#39;, col = 2, lwd = 2) } O todo en un mismo grafico, y la variación de temperatura diurna para cada mes. plot(x = hours, y = tempDayEachMonth[[1]][, 2], type = &#39;n&#39;, ylim = c(-10, 35), xlab = &quot;&quot;, ylab = &quot;Temperatura promedia (°C)&quot;, xaxt = &quot;n&quot;, panel.first = { abline(v = hours, col = &quot;gray&quot;, lty = 2) abline(h = 0, lty = 2) }) axis(side = 1, at = hours, labels = tempHourMean[, 1], las = 2) myColors &lt;- c(&quot;#A6CEE3&quot;, &quot;#1F78B4&quot;, &quot;#B2DF8A&quot;, &quot;#33A02C&quot;, &quot;#FB9A99&quot;, &quot;#E31A1C&quot;, &quot;#FDBF6F&quot;, &quot;#FF7F00&quot;, &quot;#CAB2D6&quot;, &quot;#6A3D9A&quot;, &quot;#FFFF99&quot;, &quot;#B15928&quot;) for (i in seq_along(tempDayEachMonth)){ points(x = hours, y = tempDayEachMonth[[i]][, 2], type = &#39;l&#39;, col = myColors[i], lwd = 2) } legend(&quot;topright&quot;, ncol = 4, legend = meses, col = myColors, lty = 1, lwd = 2, cex = 0.8) plot(x = hours, y = tempDayEachMonth[[1]][, 2], type = &#39;n&#39;, ylim = c(0, 30), xlab = &quot;&quot;, ylab = &quot;Variación de temperatura diurna (°C)&quot;, xaxt = &quot;n&quot;, panel.first = { abline(v = hours, col = &quot;gray&quot;, lty = 2) abline(h = 0, lty = 2) }) axis(side = 1, at = hours, labels = tempHourMean[, 1], las = 2) myColors &lt;- c(&quot;#A6CEE3&quot;, &quot;#1F78B4&quot;, &quot;#B2DF8A&quot;, &quot;#33A02C&quot;, &quot;#FB9A99&quot;, &quot;#E31A1C&quot;, &quot;#FDBF6F&quot;, &quot;#FF7F00&quot;, &quot;#CAB2D6&quot;, &quot;#6A3D9A&quot;, &quot;#FFFF99&quot;, &quot;#B15928&quot;) for (i in seq_along(tempDayEachMonth)){ points(x = hours, y = tempDayEachMonth[[i]][, 6] - tempDayEachMonth[[i]][, 4], type = &#39;l&#39;, col = myColors[i], lwd = 2) } legend(&quot;topright&quot;, ncol = 4, legend = meses, col = myColors, lty = 1, lwd = 2, cex = 0.8) También podemos representar las temperaturas diarias con gráficos ridgeline y el package ggplot2 (https://www.data-to-viz.com/graph/ridgeline.html). pkgCheck &lt;- function(x){ if (!require(x, character.only = TRUE)){ install.packages(x, dependencies = TRUE) if(!require(x, character.only = TRUE)) { stop() } } } pkgCheck(&quot;ggplot2&quot;) pkgCheck(&quot;ggridges&quot;) ## Le chargement a nécessité le package : ggridges pkgCheck(&quot;viridis&quot;) ## Le chargement a nécessité le package : viridis ## Le chargement a nécessité le package : viridisLite meanTemps &lt;- unlist(lapply(tempDayEachMonth, &quot;[[&quot;, 2)) labelMonth &lt;- rep(meses, each = 48) dfTemps &lt;- data.frame(month = labelMonth, value = meanTemps, stringsAsFactors = FALSE) dfTemps$month &lt;- factor(dfTemps$month, levels = rev(meses)) p &lt;- ggplot(data = dfTemps, aes(y = month, x = value, fill = ..x..)) p &lt;- p + geom_density_ridges_gradient(stat=&quot;binline&quot;) p &lt;- p + scale_fill_viridis(name = &quot;Temp. [°C]&quot;, option = &quot;C&quot;) p &lt;- p + xlab(&quot;Temperature&quot;) + ylab(&quot;&quot;) + theme( legend.position=&quot;none&quot;, panel.spacing = unit(0.1, &quot;lines&quot;), strip.text.x = element_text(size = 8) ) p ## `stat_binline()` using `bins = 30`. Pick better value with `binwidth`. "]]
