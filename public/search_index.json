[
["index.html", "Aprender R: iniciación y perfeccionamiento 1 Preámbulo", " Aprender R: iniciación y perfeccionamiento François Rebaudo 2018-11-29 1 Preámbulo Este libro está incompleto por el momento y está viendo su versión preliminar. Muchos capítulos ya están en línea, así que no dude en consultarlos y comenzar su iniciación o su perfeccionamiento en el lenguaje de programación R. Si tiene algún comentario, sugerencia o si identifica errores, no dude en enviarme un correo electrónico (francois.rebaudo@ird.fr), o si está familiarizado con GitHub en el sitio web del proyecto (https://github.com/frareb/myRBook_SP). Este libro es colaborativo, se basa en su participación. Este libro también está disponible en francés (http://myrbookfr.netlify.com/) Últimas modificaciones: 29/11/2018 Capítulo Gráficos simples 09/11/2018 Capítulo Gestión de proyectos con R La primera parte de este libro sobre conceptos básicos está completa 08/11/2018 algorítmico (5/6) next y break algorítmico (6/6) Los bucles de la familia apply 19/10/2018 algorítmico (3/6) el bucle for algorítmico (4/6) el bucle while algorítmico (4’/6) el bucle repeat 28/09/2018 algorítmico (1/6) Pruebas lógicas con if algorítmico (2/6) Pruebas lógicas con switch 17/09/2018 Introducción 10/09/2018 Importar y exportar datos (parte 2-3/3): Guardar y exportar datos 06/09/2018 Importar y exportar datos (parte 1/3): Leer datos desde un archivo 30/08/2018 Nuevo estudio de caso: dataloggers Modificaciones de Marc G. sobre el tipo de datos numeric y los entornos de desarrollo 24/08/2018 Capítulo sobre las funciones (3/3) 27/07/2018 Capítulo sobre las funciones (2/3) 25/07/2018 Capítulo sobre las funciones (1/3) 17/07/2018 edición y corrección del español (Susi L.) tercera parte del capítulo Contenedores de datos: El contenedor data.frame cuarta parte del capítulo Contenedores de datos: El contenedor matrix quinta parte del capítulo Contenedores de datos: El contenedor array 16/07/2018 edición y corrección del español (Estefanía Q.) 12/07/2018 segunda parte del capítulo Contenedores de datos: El contenedor list 06/07/2018 edición y corrección del español (Camila B.) primera parte del capítulo Contenedores de datos: El contenedor vector 04/07/2018 tabla de contenidos con los próximos capítulos error de tipografía en Elegir un entorno de desarrollo 02/07/2018 tres capítulos en línea (primeros pasos, elegir un entorno de desarrollo, tipos de datos) "],
["remerciements.html", " 2 Agradecimientos", " 2 Agradecimientos Agradezco a todos los colaboradores que ayudaron a mejorar este libro con sus consejos, sugerencias de cambios y correcciones (en orden alfabético): ## Colaboradores : Camila Benavides Frias (Bolivia) Marc Girondot (France ; UMR 8079 ESE) Susi Loza Herrera (Bolivia) Estefania Quenta Herrera (Bolivia) Las versiones de gitbook, html y epub de este libro usan los iconos de fuente abierta de Font Awesome (https://fontawesome.com). La versión en PDF utiliza los iconos del proyecto Tango disponibles en openclipart (https://openclipart.org/). Este libro fue escrito con el paquete R bookdown (https://bookdown.org/). El código fuente está disponible en GitHub (https://github.com/frareb/myRBook_SP). La versión en línea se aloja y actualiza a través de Netlify (http://netlify.com/). "],
["licence.html", " 3 Licencia", " 3 Licencia Licencia Reconocimiento-NoComercial-SinObraDerivada 3.0 España (CC BY-NC-ND 3.0 ES ; https://creativecommons.org/licenses/by-nc-nd/3.0/es/) Esto es un resumen inteligible para humanos (y no un sustituto) de la licencia. Usted es libre de: Compartir — copiar y redistribuir el material en cualquier medio o formato. El licenciador no puede revocar estas libertades mientras cumpla con los términos de la licencia. Bajo las condiciones siguientes: Reconocimiento — Debe reconocer adecuadamente la autoría, proporcionar un enlace a la licencia e indicar si se han realizado cambios&lt;. Puede hacerlo de cualquier manera razonable, pero no de una manera que sugiera que tiene el apoyo del licenciador o lo recibe por el uso que hace. NoComercial — No puede utilizar el material para una finalidad comercial. SinObraDerivada — Si remezcla, transforma o crea a partir del material, no puede difundir el material modificado. No hay restricciones adicionales — No puede aplicar términos legales o medidas tecnológicas que legalmente restrinjan realizar aquello que la licencia permite. Avisos: No tiene que cumplir con la licencia para aquellos elementos del material en el dominio público o cuando su utilización esté permitida por la aplicación de una excepción o un límite. No se dan garantías. La licencia puede no ofrecer todos los permisos necesarios para la utilización prevista. Por ejemplo, otros derechos como los de publicidad, privacidad, o los derechos morales pueden limitar el uso del material. "],
["intro.html", " 4 Introducción 4.1 ¿Por qué aprender R? 4.2 Este libro 4.3 Lectura adicional en español", " 4 Introducción 4.1 ¿Por qué aprender R? Porque R se ha convertido en una herramienta esencial para el análisis y la gestión de datos científicos, y en este contexto se vuelve esencial dominar al menos los conceptos básicos. El éxito de R no es una coincidencia: R es un software que todos pueden obtener libremente garantizando la transparencia y la reproducibilidad de los resultados científicos (sujeto a cumplir con algunas reglas que abordará este libro). R también se basa en una comunidad muy activa con varios miles de módulos adicionales (paquetes) para realizar el análisis estadístico más avanzado. 4.2 Este libro El propósito de este libro es proporcionar a los estudiantes y aquellos que deseen aprender sobre R una base sólida para luego implementar sus propios proyectos científicos y la valoración de sus resultados. Hay muchos libros dedicados a R, pero ninguno cubre los elementos básicos de este lenguaje con el fin de hacer que los resultados científicos sean publicables y reproducibles. En general, este libro está dirigido a toda la comunidad científica y en particular a aquellos interesados en las ciencias de la vida, y los ejemplos en este libro se basarán en estudios de biología. Este libro nació de la solicitud de los estudiantes de las universidades que colaboran con el IRD en América del Sur. Por lo tanto, su primera versión está escrita en español (hay pocos documentos de calidad en R en español). Comencé su traducción al francés en 2018 y hoy ambas versiones coevolucionan con contenido que puede variar (por ejemplo, para estudios de casos). 4.3 Lectura adicional en español R para Principiantes, Emmanuel Paradis (https://cran.r-project.org/doc/contrib/rdebuts_es.pdf) "],
["premiersPas.html", " 5 Primeros pasos 5.1 Instalar R 5.2 R como calculadora 5.3 El concepto de objeto 5.4 Los scripts 5.5 Conclusión", " 5 Primeros pasos 5.1 Instalar R El programa para instalar el software R se puede descargar desde el sitio web de R: https://www.r-project.org/. En el sitio web de R, primero es necesario elegir un espejo CRAN (servidor desde el cual se debe descargar R, y desde el más cercano a su ubicación geográfica), luego descargue el archivo base. Los usuarios de Linux pueden preferir un sudo apt-get install r-base. El software R se puede descargar de muchos servidores CRAN (Comprehensive R Archive Network) de todo el mundo. Estos servidores se llaman espejos. La elección del espejo es manual. 5.2 R como calculadora Una vez que se inicia el programa, aparece una ventana cuya apariencia puede variar dependiendo de su sistema operativo (Figura 5.1). Esta ventana se llama consola. Figure 5.1: Captura de pantalla de la consola R en Windows. La consola corresponde a la interfaz donde se interpretará el código, es decir, donde el código será transformado en lenguaje de máquina, ejecutado por la computadora y retransmitido en forma legible por humanos. Esto es análogo a lo que sucede en una calculadora (Figura 5.2). Así es como se usará R más adelante en esta sección. A lo largo de este libro, los ejemplos del código R aparecerán sobre un fondo gris. Se pueden copiar y pegar directamente en la consola, aunque es mejor reproducir los ejemplos escribiéndolos en la consola (o más adelante en los scripts) para una mejor comprensión del manejo del programa R. El resultado de lo que se envía en la consola también aparecerá en un fondo gris con ## delante del código para hacer la distinción entre el código y el resultado del código. Figure 5.2: Captura de pantalla de la consola R al lado de la calculadora de Windows. 5.2.1 Los operadores aritméticos 5 + 5 ## [1] 10 Si escribimos 5 + 5 en la consola y luego Enter, el resultado aparece precedido por el número [1] entre corchetes. Este número corresponde al número del resultado (en nuestro caso, solo hay un resultado, volveremos a este aspecto más adelante). También podemos observar en este ejemplo el uso de espacios antes y después del signo +. Estos espacios no son necesarios, pero permiten que el código sea más legible para los humanos (es decir, más agradable de leer tanto para nosotros como para las personas con las que queremos compartir nuestro código). Los operadores aritméticos disponibles en R se resumen en la tabla 5.1. Table 5.1: Operadores aritméticos. Label Operador adición + resta - multiplicación * división / potencia ^ módulo %% cociente decimal %/% Clásicamente, las multiplicaciones y divisiones tienen prioridad sobre las adiciones y sustracciones. Si es necesario, podemos usar paréntesis. 5 + 5 * 2 ## [1] 15 (5 + 5) * 2 ## [1] 20 (5 + 5) * (2 + 2) ## [1] 40 (5 + 5) * ((2 + 2) / 3)^2 ## [1] 17.77778 El operador módulo corresponde al resto de la división euclidiana. Se usa en ciencias de la computación, por ejemplo, para saber si un número es par o impar (un número módulo 2 devolverá 1 si es impar y 0 si es par). 451 %% 2 ## [1] 1 288 %% 2 ## [1] 0 (5 + 5 * 2) %% 2 ## [1] 1 ((5 + 5) * 2) %% 2 ## [1] 0 R también incorpora algunas constantes que incluyen pi. Además, el signo infinito está representado por Inf. pi ## [1] 3.141593 pi * 5^2 ## [1] 78.53982 1/0 ## [1] Inf El estilo del código es importante porque el código está destinado a ser leído por nosotros y por otras personas. Para tener un estilo legible, se recomienda colocar espacios antes y después de los operadores aritméticos, excepto “*”, “/” y “^”, aunque a veces es útil agregarlos como es el caso en nuestro ejemplos. 5.2.2 Los operadores comparativos Sin embargo, R es mucho más que una simple calculadora porque permite otro tipo de operadores: operadores de comparación, para comparar los valores (Table 5.2). Table 5.2: Operadores de comparación. Label Operador más pequeño que &lt; mayor que &gt; más pequeño o igual a &lt;= más grande o igual a &gt;= igual a == diferente de != Por ejemplo, si queremos saber si un numero es más grande que otro, podemos escribir: 5 &gt; 3 ## [1] TRUE R devuelve TRUE si la comparación es verdadera y FALSE si la comparación es falsa. 5 &gt; 3 ## [1] TRUE 2 &lt; 1.5 ## [1] FALSE 2 &lt;= 2 ## [1] TRUE 3.2 &gt;= 1.5 ## [1] TRUE Podemos combinar operadores aritméticos con operadores de comparación. (5 + 8) &gt; (3 * 45/2) ## [1] FALSE En la comparación (5 + 8) &gt; (3 * 45/2) no se necesitan paréntesis, pero permiten que el código sea más fácil de leer. Un operador de comparación particular es igual a. Veremos en la siguiente sección que el signo = está reservado para otro uso: permite asignar un valor a un objeto. El operador de comparación igual a debe ser diferente, por eso R usa ==. 42 == 53 ## [1] FALSE 58 == 58 ## [1] TRUE Otro operador particular es diferente de. Se usa con un signo de admiración seguido de igual, !=. Este operador permite obtener la respuesta opuesta a ==. 42 == 53 ## [1] FALSE 42 != 53 ## [1] TRUE (3 + 2) != 5 ## [1] FALSE 10/2 == 5 ## [1] TRUE R usa TRUE y FALSE, que también son valores que se pueden probar con operadores de comparación. Pero R también asigna un valor a TRUE y FALSE: TRUE == TRUE ## [1] TRUE TRUE &gt; FALSE ## [1] TRUE 1 == TRUE ## [1] TRUE 0 == FALSE ## [1] TRUE TRUE + 1 ## [1] 2 FALSE + 1 ## [1] 1 (FALSE + 1) == TRUE ## [1] TRUE El valor de TRUE es 1 y el valor de FALSE es 0. Veremos más adelante cómo usar esta información en los próximos capítulos. R es también un lenguaje relativamente permisivo, significa que admite cierta flexibilidad en la forma de escribir el código. Debatir sobre la idoneidad de esta flexibilidad está fuera del alcance de este libro, pero podemos encontrar en el código R en Internet o en otras obras el atajo T para TRUE y F for FALSE. T == TRUE ## [1] TRUE F == FALSE ## [1] TRUE T == 1 ## [1] TRUE F == 0 ## [1] TRUE (F + 1) == TRUE ## [1] TRUE Aunque esta forma de referirse a TRUE y FALSE por T y F está bastante extendida, en este libro siempre usaremos TRUE y FALSE para que el código sea más fácil de leer. Como mencionado anterioramente, el objetivo de un código no solo es ser funcional sino también fácil de leer y volver a leer. 5.2.3 Los operadores lógicos Hay un último tipo de operador, los operadores lógicos. Estos son útiles para combinar operadores de comparación (Table 5.3). Table 5.3: Operadores lógicos. Label Operador no es ! y &amp; o | o exclusivo xor() !TRUE ## [1] FALSE !FALSE ## [1] TRUE ((3 + 2) == 5) &amp; ((3 + 3) == 5) ## [1] FALSE ((3 + 2) == 5) &amp; ((3 + 3) == 6) ## [1] TRUE (3 &lt; 5) &amp; (5 &lt; 5) ## [1] FALSE (3 &lt; 5) &amp; (5 &lt;= 5) ## [1] TRUE El operador lógico xor() es o exclusivo. Es decir, uno de los dos argumentos de la función xor() debe ser verdadero, pero no ambos. Más adelante volveremos a las funciones y sus argumentos, pero recuerde que identificamos una función por sus paréntesis que contienen argumentos separados por comas. xor((3 + 2) == 5, (3 + 3) == 6) ## [1] FALSE xor((3 + 2) == 5, (3 + 2) == 6) ## [1] TRUE xor((3 + 3) == 5, (3 + 2) == 6) ## [1] FALSE xor((3 + 3) == 5, (3 + 3) == 6) ## [1] TRUE Se recomienda que las comas , sean seguidas de un espacio para que el código sea más agradable de leer. 5.2.4 Ayuda a los operadores El archivo de ayuda en inglés sobre operadores aritméticos se puede obtener con el comando ?'+'. El de los operadores de comparación con el comando ?'==' y el de los operadores lógicos con el comando ?'&amp;'. 5.3 El concepto de objeto Un aspecto importante de la programación con R, pero también la programación en general es la noción de objeto. Como se indica en la página web de wikipedia (https://ia.wikipedia.org/wiki/Objecto_(informatica)), en ciencias de la computación, un objeto es un contenedor, es decir, algo que contendrá información. La información contenida en un objeto puede ser muy diversa, pero por el momento contendremos en un objeto el número 5. Para hacer esto (y para reutilizarlo más adelante), debemos darle un nombre a nuestro objeto. En R, los nombres de los objetos no deben contener caracteres especiales como ^ $ ? | + () [] {}, entre otros. No deben comenzar con un número ni contener espacios. El nombre del objeto debe ser representativo de lo que contiene, sin ser demasiado corto ni demasiado largo. Imagine que nuestro número 5 corresponde al número de repeticiones de un experimento. Nos gustaría darle un nombre que se refiera a numero y repeticiones, que podríamos reducir a nbr y rep, respectivamente (nbr para number en ingles). Hay varias posibilidades que son bastante comunes bajo R: la separación mediante guión bajo (underscore): nbr_rep la separación mediante el carácter punto: nbr.rep el uso de letras minúsculas: nbrrep el estilo lowerCamelCase que consiste en una primera palabra en minúscula y la primera letra de las siguientes palabras con una letra mayúscula: nbrRep el estilo UpperCamelCase donde cada palabra comienza con una letra mayúscula: NbrRep Todas estas formas de nombrar un objeto son equivalentes. En este libro usaremos el estilo lowerCamelCase. En general, debemos evitar los nombres que son demasiado largos, como miNumeroDeRepeticionesDeMiExperimento o demasiado cortos como nR, y los nombres que no permiten identificar los contenidos como miVariable o miNumero, asi que nombres como a o b. El objetivo es de tener una idea de lo que hay en cada objeto en base a su nombre. Hay diferentes maneras de definir un nombre para los objetos que crearemos con R. En este libro, utilizamos el estilo lowerCamelCase. Lo importante no es la elección del estilo, sino la consistencia en su elección. El objetivo es tener un código funcional, pero también un código que sea fácil y agradable de leer para nosotros y para los demás. Ahora que hemos elegido un nombre para nuestro objeto, debemos crearlo y hacer que R entienda que nuestro objeto debe contener el número 5. Hay tres maneras de crear un objeto bajo R: con &lt;- con = o con -&gt; nbrRep &lt;- 5 nbrRep = 5 5 -&gt; nbrRep En este libro siempre usaremos la forma &lt;- para coherencia y también porque es la forma más común. nbrRep &lt;- 5 Acabamos de crear un objeto nbrRep y establecerlo con el valor 5. Este objeto ahora está disponible en nuestro entorno de computación y puede ser utilizado. Algunos ejemplos : nbrRep + 2 ## [1] 7 nbrRep * 5 - 45/56 ## [1] 24.19643 pi * nbrRep^2 ## [1] 78.53982 El valor asociado con nuestro objeto nbrRep se puede modificar de la misma manera que cuando se creó: nbrRep &lt;- 5 nbrRep + 2 ## [1] 7 nbrRep &lt;- 10 nbrRep + 2 ## [1] 12 nbrRep &lt;- 5 * 2 + 7/3 nbrRep + 2 ## [1] 14.33333 El uso de objetos tiene sentido cuando tenemos operaciones complejas para realizar y hace que el código sea más agradable de leer y entender. (5 + 9^2 - 1/18) / (32 * 45/8 + 3) ## [1] 0.4696418 termino01 &lt;- 5 + 9^2 - 1/18 termino02 &lt;- 32 * 45/8 + 3 termino01 / termino02 ## [1] 0.4696418 5.4 Los scripts R es un lenguaje de programación denominado lenguaje de scripting. Esto se refiere al hecho de que la mayoría de los usuarios escribirán pequeñas piezas de código en lugar de programas completos. R se puede usar como una simple calculadora, y en este caso no será necesario mantener un historial de las operaciones que se han realizado. Pero si las operaciones a implementar son largas y complejas, puede ser necesario e interesante guardar lo que se ha hecho para poder continuar más adelante. El archivo en el que se almacenarán las operaciones es lo que comúnmente se llama el script. Un script, por lo tanto, es un archivo que contiene una sucesión de información comprensible por R y que es posible ejecutar. 5.4.1 Crear un script y documentarlo Para crear un nuevo script basta con abrir un documento vacío de texto, que será editado por un editor de texto como el bloc de notas en Windows o Mac OSX, o Gedit o incluso nano en Linux. Por convención, este archivo toma la extensión “.r” o “.R” (lo mas comun). Esta última convención se usará en este libro (“miArchivo.R”). Desde la interfaz gráfica de R, es posible crear un nuevo script en Mac OS y Windows a través de file, luego new script y save as. Al igual que el nombre de los objetos, el nombre del script es importante para que podamos identificar fácilmente su contenido. Por ejemplo, podríamos crear un archivo formRConceptsBase.R que contenga los objetos que acabamos de crear y los cálculos que hicimos. Pero incluso con nombres de objetos y archivos bien definidos, será difícil recordar el significado de este archivo sin la documentación que acompaña a este script. Para documentar un script utilizaremos comentarios. Los comentarios son elementos que R identificará como tales y no se ejecutarán. Para especificar a R que vamos a hacer un comentario, debemos usar el carácter octothorpe (corsé o numeral) #. Los comentarios se pueden insertar en una nueva línea o al final de la línea. # creación objeto número de repeticiones nbrRep &lt;- 5 # Comentario de fin de línea Todo lo que hay despues del simbolo numeral # no sera ejecutado. Significa que podriamos usar comentarios como ### o #comentario, aun que se recomienda hacer comentarios con un solo simbolo numeral seguido por un espacio y despues su comentario: # mi comentario. Los comentarios también se pueden usar para hacer que una línea ya no se ejecute. En este caso no queremos ejecutar la secunda linea: nbrRep &lt;- 5 # nbrRep + 5 Para volver a la documentación del script, se recomienda comenzar cada uno de nuestros scripts con una breve descripción de su contenido, luego cuando el script sea extenso, estructurarlo en diferentes partes para facilitar su lectura. # ------------------------------------------------------------ # Aquí hay un script para adquirir los conceptos básicos # con R # fecha de creación : 27/06/2018 # autor : François Rebaudo # ------------------------------------------------------------ # [1] creación del objeto número de repeticiones # ------------------------------------------------------------ nbrRep &lt;- 5 # [2] cálculos simples # ------------------------------------------------------------ pi * nbrRep^2 ## [1] 78.53982 Para ir más allá en el estilo del código, una guía completa de recomendaciones está disponible en línea en el sitio web tidyverse (en ingles ; http://style.tidyverse.org/). 5.4.2 Ejecutar un script Como tenemos un script, no trabajamos directamente en la consola. Pero solo la consola puede entender el código R y devolvernos los resultados que queremos obtener. Por ahora, la técnica más simple es copiar y pegar las líneas que queremos ejecutar desde nuestro script hasta la consola. A partir de ahora, ya no utilizaremos editores de texto como bloc de notas, sino editores especializados para la creación de scripts R. Sera es el objetivo del siguiente capítulo. 5.5 Conclusión Felicitaciones, hemos llegado al final de este primer capítulo sobre la base de R. Sabemos: Instalar R Usar R como una calculadora Crear objetos y utilisarlos para los calculos aritméticos, comparativos y logicos Elejir nombres pertinentes para los objetos Crear un nuevo script Elejir un nombre pertinente para el archivo del script Ejecutar el codigo de un script Documentar los scripts con comentarios Usar un estilo de código para que sea agradable de leer y facil de entender "],
["IDE.html", " 6 Elegir un entorno de desarrollo 6.1 Editores de texto y entorno de desarrollo 6.2 RStudio 6.3 Notepad++ avec Npp2R 6.4 Geany 6.5 Otras soluciones 6.6 Conclusión", " 6 Elegir un entorno de desarrollo 6.1 Editores de texto y entorno de desarrollo Hay muchos editores de texto, el capítulo anterior permitió introducir algunos de los más simples como el bloc de notas de Windows. Sin embargo, los límites de estos editores han hecho tediosa la tarea de escribir un script. De hecho, incluso estructurando su script con comentarios, sigue siendo difícil entenderlo. Aquí es donde entran los editores de texto especializados para facilitar la escritura y la lectura de scripts. El editor de texto para R más común es Rstudio, pero hay muchos más. Hacer una lista exhaustiva de todas las soluciones disponibles está más allá del alcance de este libro, por lo que nos centraremos en las tres soluciones que utilizo a diario: Notepad++, Rstudio y Geany. No necesita instalar más de un editor de texto. Aquí recomendamos RStudio para principiantes a R. 6.2 RStudio Figure 6.1: Logo RStudio. 6.2.1 Instalar RStudio El programa para instalar el software RStudio se encuentra en la parte Products del sitio web de RStudio (https://www.rstudio.com/). Instalaremos RStudio para uso local (en nuestra computadora), por lo que la versión que nos interesa es Desktop. Usaremos la versión Open Source que es gratuita. Luego, seleccionamos la versión que corresponde a nuestro sistema operativo (Windows, Mac OS, Linux), descargamos el archivo correspondiente y lo ejecutamos para comenzar la instalación. Podemos mantener las opciones predeterminadas durante la instalación. 6.2.2 Un script con RStudio Podemos abrir RStudio. En la primera apertura, la interfaz se divide en dos con la consola R a la izquierda que vimos en el capítulo anterior (Figura 6.2). Para abrir un nuevo script, vamos al menú Archivo (o File), Nuevo archivo (o New File), R script. Por defecto, este archivo tiene el nombre Untitled1. Hemos visto en el capítulo anterior la importancia de dar un nombre pertinente a nuestros scripts, por lo que lo cambiaremos de nombre a selecEnvDev.R, en el menú Archivo (o File), con la opción Guardar como … (o Save As…). Podemos notar que el lado izquierdo de RStudio ahora está dividido en dos, con la consola en la parte inferior de la pantalla y el script en la parte superior. Figure 6.2: Captura de pantalla de RStudio en Windows: pantalla por defecto. Luego podemos comenzar a escribir nuestro script con los comentarios que describan lo que vamos a encontrar allí, y agregar un cálculo simple. Una vez que hayamos copiado o escrito un código, podemos guardar nuestro script con el comando CTRL + S o yendo a Archivo (o File, luego Guardar (o Save). # ------------------------------------------------------------ # Un script para seleccionar su entorno de desarrollo # fecha de creación : 27/06/2018 # autor : François Rebaudo # ------------------------------------------------------------ # [1] cálculos simples # ------------------------------------------------------------ nbrRep &lt;- 5 pi * nbrRep^2 ## [1] 78.53982 Para ejecutar nuestro script, simplemente seleccionamos las líneas que deseamos ejecutar y usamos la combinación de teclas CTRL + ENTER. El resultado aparece en la consola (Figura 6.3). Figure 6.3: Captura de pantalla de RStudio en Windows: ejecutar nuestro script con CTRL + ENTER. Podemos ver que, de forma predeterminada, en la parte del script, los comentarios aparecen en verde, los números en azul y el resto del código en negro. En la parte de la consola, lo que se ejecutó aparece en azul y los resultados de la ejecución en negro. También podemos observar que en la parte del código cada línea tiene un número correspondiente al número de línea a la izquierda sobre un fondo gris. Este es el resaltado de preferencias de sintaxis predeterminado con RStudio. Estas preferencias de sintaxis pueden modificarse yendo al menú Herramientas (o Tools), Opciones globales … (o Global Options…), Aspecto (o Appearance), y luego seleccionando otro tema del Editor de tema: (o Editor theme:). Elegiremos el tema Cobalt, luego OK (Figura 6.4). Figure 6.4: Captura de pantalla de RStudio en Windows: cambiar preferencias de sintaxis. Sabemos cómo crear un nuevo script, guardarlo, ejecutar su contenido y cambiar la apariencia de RStudio. Veremos los muchos otros beneficios de RStudio a lo largo de este libro, ya que es el entorno de desarrollo que se utilizará. Sin embargo, seremos especialmente cuidadosos de que todos los scripts desarrollados a lo largo de este libro se ejecuten de la misma manera, independientemente del entorno de desarrollo utilizado. 6.3 Notepad++ avec Npp2R Figure 6.5: Logo Notepad++ 6.3.1 Instalar Notepad++ (solamente para Windows) El programa para instalar Notepad ++ se puede encontrar en la pestaña Downloads (https://notepad-plus-plus.org/download/). Podemos elegir entre la versión de 32-bit y la de 64-bit (64-bit si no sabe qué versión elegir). Notepad++ es suficiente para escribir un script, pero es aún más poderoso con Notepad++ to R (Npp2R) que permite ejecutar automáticamente nuestros scripts en una consola localmente en nuestra computadora o remotamente en un servidor. 6.3.2 Instalar Npp2R El programa para instalar Npp2R está alojado en el sitio de Sourceforge (https://sourceforge.net/projects/npptor/). Npp2R debe instalarse después de Notepad++. 6.3.3 Un script con Notepad++ Al abrir por primera vez, Notepad++ muestra un archivo vacío new 1 (Figura 6.6). Figure 6.6: Captura de pantalla de Notepad++ en Windows: pantalla por defecto. Como ya hemos creado un script para probarlo con RStudio, lo abriremos de nuevo con Notepad++. En Archivo, seleccionamos Abrir … luego elijemos el script selecEnvDev.R creado previamente. Una vez que el script está abierto, vamos a Idioma, luego R, y de nuevo R. Aparece el resaltado de sintaxis (Figura 6.7). Figure 6.7: Captura de pantalla de Notepad++ en Windows: ejecutar nuestro script con F8. La ejecución del script solo se puede realizar si se está ejecutando Npp2R. Para hacerlo, es necesario ejecutar el programa Npp2R desde el prompt de Windows. Un icono debe aparecer en la parte inferior de su pantalla demostrando que Npp2R está prendido. La ejecución automática del código de Notepad++ se realiza seleccionando el código para ejecutar y luego usando el comando F8. Si el comando no funciona, puede ser necesario reiniciar la computadora. Si el comando funciona, se abrirá una nueva ventana con una consola que ejecuta las líneas deseadas (Figura 6.8). Figure 6.8: Captura de pantalla de Notepad++ en Windows: la consola con F8. Al igual que con RStudio, el resaltado de sintaxis se puede cambiar desde el menú Configuración, y se puede seleccionar un nuevo tema (por ejemplo, Solarized en la Figura 6.9) Figure 6.9: Captura de pantalla de Notepad++ en Windows con el tema Solarized. Comparado con otros editores de texto, Notepad++ tiene la ventaja de ser muy liviano, rapido y ofrece una amplia gama de opciones para personalizar la escritura de códigos. 6.4 Geany Figure 6.10: Logo Geany 6.4.1 Instalar Geany (para Linux, Mac OSX y Windows) El programa para instalar Geany se puede encontrar en la pestaña Downloads en el menú de la izquierda Releases de la página web (https://www.geany.org/). Luego solo descargamos el ejecutable para Windows o el dmg para Mac OSX. Los usuarios de Linux preferirán un sudo apt-get install geany. 6.4.2 Un script con Geany Al abrir por primera vez, como para RStudio y Notepad++, se crea un archivo vacío (Figura 6.11). Figure 6.11: Captura de pantalla de Geany en Windows: pantalla por defecto. Podemos abrir nuestro script con Archivo, Abrir (Figura 6.12). Figure 6.12: Captura de pantalla de Geany en Windows: abrir un script. Para ejecutar nuestro script, la versión de Geany para Windows no tiene un terminal incorporado, lo que hace que su uso sea limitado bajo este sistema operativo. La ejecución de un script se puede hacer abriendo R en una ventana separada y copiando y pegando las líneas que se ejecutarán. En Linux y Mac OSX, podemos abrir R en el terminal en la parte inferior de la ventana de Geany con el comando R. Podemos configurar Geany para una combinación de teclas para ejecutar el código seleccionado (por ejemplo CTRL + R). Para esto hay que permitir el envío de selección al terminal (send_selection_unsafe = true) in archivo geany.conf y elegir el comando para enviar al terminal (en Editar, Preferencias, Combinaciones). Para cambiar el tema de Geany, hay una colección de temas disponibles en GitHub (https://github.com/geany/geany-themes/). El tema se puede cambiar a través del menú Ver, cambiar Esquema del color … (un ejemplo con el tema Solarized Figura @ref(Fig: screenCapGeany03)). Figure 6.13: Captura de pantalla de Geany en Windows: cambiar esquema de color. 6.5 Otras soluciones Hay muchas otras soluciones, algunas especializadas para R como Tinn-R (https://sourceforge.net/projects/tinn-r/), y otras más generales para programación como Atom (https://atom.io/), Sublime Text (https://www.sublimetext.com/), Vim (https://www.vim.org/), Gedit (https://wiki.gnome.org/Apps/Gedit), GNU Emacs (https://www.gnu.org/software/emacs/), Jupyter (http://jupyter.org), o Brackets (http://brackets.io/) y Eclipse (http://www.eclipse.org/). 6.6 Conclusión Felicitaciones, llegamos al final de este capítulo sobre el entorno de desarrollo para el uso de R. Hasta ahora sabemos: Instalar RStudio, Geany o Notepad++ Reconocer y elegir nuestro entorno de preferencia A partir de acá podremos concentrarnos en el lenguaje de programación R en un ambiente, facilitando el trabajo de lectura y de escritura del código. Esto ya es un gran paso para manejar R. "],
["dataType1.html", " 7 Tipos de datos 7.1 El tipo numeric 7.2 El tipo character 7.3 El tipo factor 7.4 El tipo logical 7.5 Acerca de NA 7.6 Conclusión", " 7 Tipos de datos Vimos anteriormente cómo crear un objeto. Un objeto es como una caja en la que almacenaremos información. Hasta ahora solo hemos almacenado números, pero en este capítulo veremos que es posible almacenar otra información y nos detendremos en los tipos más comunes. En este capítulo utilizaremos funciones sobre las cuales volveremos más adelante. 7.1 El tipo numeric El tipo numeric es lo que hemos hecho hasta ahora, almacenando números. Hay dos tipos principales de números en R: enteros (integer) y números decimales (double). Por defecto, R considera todos los números como números decimales y asigna el tipo double. Para verificar el tipo de datos utilizaremos la función typeof() que toma como argumento un objeto (o directamente la información que queremos probar). También podemos usar la función is.double() que devolverá TRUE si el número está en formato double y FALSE en caso contrario. La función genérica is.numeric() devolverá TRUE si el objeto está en formato numeric y FALSE en caso contrario. nbrRep &lt;- 5 typeof(nbrRep) ## [1] &quot;double&quot; typeof(5.32) ## [1] &quot;double&quot; is.numeric(5) ## [1] TRUE is.double(5) ## [1] TRUE Si queremos decirle a R que vamos a trabajar con un entero, entonces necesitamos convertir nuestro número decimal en un entero con la función as.integer(). También podemos usar la función is.integer() que devolverá TRUE si el número está en formato integer y FALSE en caso contrario. nbrRep &lt;- as.integer(5) typeof(nbrRep) ## [1] &quot;integer&quot; typeof(5.32) ## [1] &quot;double&quot; typeof(as.integer(5.32)) ## [1] &quot;integer&quot; as.integer(5.32) ## [1] 5 as.integer(5.99) ## [1] 5 is.numeric(nbrRep) ## [1] TRUE Vemos aquí que convertir un número como 5.99 a integer solo devolverá la parte entera, 5. is.integer(5) ## [1] FALSE is.numeric(5) ## [1] TRUE is.integer(as.integer(5)) ## [1] TRUE is.numeric(as.integer(5)) ## [1] TRUE La suma de un número entero integer y un número decimal double devuelve un número decimal. sumIntDou &lt;- as.integer(5) + 5.2 typeof(sumIntDou) ## [1] &quot;double&quot; sumIntInt &lt;- as.integer(5) + as.integer(5) typeof(sumIntInt) ## [1] &quot;integer&quot; Para resumir, el tipo numeric contiene dos subtipos, los tipos integer para enteros y el tipo double para los números decimales. Por defecto, R asigna el tipo double a los números. Tenga cuidado, hay una trampa para usar la función is.integer(). No nos dice si el número es un número entero, pero si es de tipo integer. De hecho, uno puede almacenar un entero en una variable de tipo doble. Los números almacenados en una variable de tipo integer son codificados en 32 bits y, por lo tanto, pueden tomar valores entre 0 y 2^32-1 = 4294967295. Hay otra forma de decirle a R que un número es un número entero, usando el sufijo L. Por ejemplo, 5L es lo mismo que as.integer(5). El origen del sufijo L, que se remonta a una época en que las computadoras usaban palabras de 16 bits y 32 bits, era un tipo Largo. ¡Ahora las computadoras usan palabras de 64 bits y 32 bits es bastante corta! No podemos dejar esta sección sin mencionar las funciones round() ceiling() trunc() o floor() que devuelven la parte entera de un número, pero déjelo en el tipo double. Para obtener más información, podemos usar la ayuda de R con ? Ronda. {R} roundDou &lt;- round (5.2) typeof (roundDou) ` 7.2 El tipo character El tipo character es texto. De hecho, R permite trabajar con texto. Para especificar a R que la información contenida en un objeto está en formato de texto (o generalmente para todos los textos), usamos las comillas dobles (&quot;) o las comillas simples ('). myText &lt;- &quot;azerty&quot; myText2 &lt;- &#39;azerty&#39; myText3 &lt;- &#39;azerty uiop qsdfg hjklm&#39; typeof(myText3) ## [1] &quot;character&quot; Tanto las comillas dobles y simples son útiles en nuestro texto. También podemos escapar un carácter especial como comillas gracias al signo de barra invertida \\. myText &lt;- &quot;a &#39;ze&#39; &#39;rt&#39; y&quot; print(myText) ## [1] &quot;a &#39;ze&#39; &#39;rt&#39; y&quot; myText2 &lt;- &#39;a &quot;zert&quot; y&#39; print(myText2) ## [1] &quot;a \\&quot;zert\\&quot; y&quot; myText3 &lt;- &#39;azerty uiop qsdfg hjklm&#39; print(myText3) ## [1] &quot;azerty uiop qsdfg hjklm&quot; myText4 &lt;- &quot;qwerty \\&quot; azerty &quot; print(myText4) ## [1] &quot;qwerty \\&quot; azerty &quot; myText5 &lt;- &quot;qwerty \\\\ azerty &quot; print(myText5) ## [1] &quot;qwerty \\\\ azerty &quot; De forma predeterminada, cuando creamos un objeto, su contenido no es devuelto por la consola. En Internet o en muchos libros podemos encontrar el nombre del objeto en una línea para devolver sus contenidos: myText &lt;- &quot;a &#39;ze&#39; &#39;rt&#39; y&quot; myText ## [1] &quot;a &#39;ze&#39; &#39;rt&#39; y&quot; En este libro, no lo usaremos de esta manera y preferiremos el uso de la función print(), que permite mostrar en la consola el contenido de un objeto. El resultado es el mismo, pero el código es más fácil de leer y más explícito sobre lo que hace. myText &lt;- &quot;a &#39;ze&#39; &#39;rt&#39; y&quot; print(myText) ## [1] &quot;a &#39;ze&#39; &#39;rt&#39; y&quot; nbrRep &lt;- 5 print(nbrRep) ## [1] 5 También podemos poner números en formato de texto, pero no debemos olvidar poner comillas para especificar el tipo character o usar la funciónas.character(). Una operación entre un texto y un número devuelve un error. Por ejemplo, si agregamos 10 a 5, R nos dice que un argumento de la función + no es un tipo numeric y que, por lo tanto, la operación no es posible. Tampoco podemos agregar texto a texto, pero veremos más adelante cómo concatenar dos cadenas de texto. myText &lt;- &quot;qwerty&quot; typeof(myText) ## [1] &quot;character&quot; myText2 &lt;- 5 typeof(myText2) ## [1] &quot;double&quot; myText3 &lt;- &quot;5&quot; typeof(myText3) ## [1] &quot;character&quot; myText2 + 10 ## [1] 15 as.character(5) ## [1] &quot;5&quot; # myText3 + 10 # Error in myText3 + 10 : non-numeric argument to binary operator # &quot;a&quot; + &quot;b&quot; # Error in &quot;a&quot; + &quot;b&quot; : non-numeric argument to binary operator Para resumir, el tipo character permite el ingreso de texto, podemos reconocerlo con comillas simples o dobles. 7.3 El tipo factor El tipo factor corresponde a los factores. Los factores son una elección dentro de una lista finita de posibilidades. Por ejemplo, los países son factores porque existe una lista finita de países en el mundo en un momento dado. Un factor puede definirse con la función factor() o transformarse utilizando la función as.factor(). Al igual que con otros tipos de datos, podemos usar la función is.factor() para verificar el tipo de datos. Para obtener una lista de todas las posibilidades, existe la función levels() (esta función tendrá más sentido cuando nos acerquemos a los tipos de contenedores de información). factor01 &lt;- factor(&quot;aaa&quot;) print(factor01) ## [1] aaa ## Levels: aaa typeof(factor01) ## [1] &quot;integer&quot; is.factor(factor01) ## [1] TRUE levels(factor01) ## [1] &quot;aaa&quot; Un factor se puede transformar en texto con la función as.character() pero también en número con as.numeric(). Al cambiar al tipo numeric, cada factor toma el valor de su posición en la lista de posibilidades. En nuestro caso, solo hay una posibilidad, por lo que la función as.numeric() devolverá 1: factor01 &lt;- factor(&quot;aaa&quot;) as.character(factor01) ## [1] &quot;aaa&quot; as.numeric(factor01) ## [1] 1 7.4 El tipo logical El tipo logical corresponde a los valores TRUE y FALSE (y NA) que ya hemos visto con los operadores de comparación. aLogic &lt;- TRUE print(aLogic) ## [1] TRUE typeof(aLogic) ## [1] &quot;logical&quot; is.logical(aLogic) ## [1] TRUE aLogic + 1 ## [1] 2 as.numeric(aLogic) ## [1] 1 as.character(aLogic) ## [1] &quot;TRUE&quot; 7.5 Acerca de NA El valor NA se puede usar para especificar que no hay datos o datos faltantes. Por defecto, NA es logical, pero se puede usar para texto o números. print(NA) ## [1] NA typeof(NA) ## [1] &quot;logical&quot; typeof(as.integer(NA)) ## [1] &quot;integer&quot; typeof(as.character(NA)) ## [1] &quot;character&quot; NA == TRUE ## [1] NA NA == FALSE ## [1] NA NA &gt; 1 ## [1] NA NA + 1 ## [1] NA 7.6 Conclusión Felicitaciones, hemos llegado al final de este capítulo sobre los tipos de datos. Ahora sabemos: Reconocer y hacer objetos en los principales tipos de datos Transformar tipos de datos de un tipo a otro Este capítulo es la base para el próximo capítulo sobre contenedores de datos. "],
["dataType2.html", " 8 Contenedores de datos 8.1 El contenedor vector 8.2 El contenedor list 8.3 El contenedor data.frame 8.4 El contenedor matrix 8.5 El contenedor array 8.6 Conclusión", " 8 Contenedores de datos Hasta ahora hemos creado objetos simples que contienen solo un valor. Sin embargo, pudimos ver que un objeto tenía atributos diferentes, como su valor, pero también el tipo de datos contenidos (e.g., numeric, character). Ahora vamos a ver que hay diferentes tipos de contenedores para almacenar datos múltiples. 8.1 El contenedor vector En R, un vector es una combinación de datos con la particularidad de que todos los datos contenidos en un vector son del mismo tipo. Podemos almacenar por ejemplo múltiples elementos del tipo character o numeric en un vector, pero no ambos. El contenedor vector es importante porque es el elemento básico de R. 8.1.1 Crear un vector Para crear un vector utilizaremos la función c() que permite combinar elementos en un vector. Los elementos para combinar deben estar separados por comas. miVec01 &lt;- c(1, 2, 3, 4) # un vector de 4 elementos de tipo numeric ; double print(miVec01) ## [1] 1 2 3 4 typeof(miVec01) ## [1] &quot;double&quot; is.vector(miVec01) ## [1] TRUE La funcion is.vector() permite verificar el tipo de contenedor. miVec02 &lt;- c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;) print(miVec02) ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; typeof(miVec02) ## [1] &quot;character&quot; is.vector(miVec02) ## [1] TRUE miVec03 &lt;- c(TRUE, FALSE, FALSE, TRUE) print(miVec03) ## [1] TRUE FALSE FALSE TRUE typeof(miVec03) ## [1] &quot;logical&quot; is.vector(miVec03) ## [1] TRUE miVecNA &lt;- c(1, NA, 3, NA, 5) print(miVecNA) ## [1] 1 NA 3 NA 5 typeof(miVecNA) ## [1] &quot;double&quot; is.vector(miVecNA) ## [1] TRUE miVec04 &lt;- c(1, &quot;a&quot;) print(miVec04) ## [1] &quot;1&quot; &quot;a&quot; typeof(miVec04) ## [1] &quot;character&quot; is.vector(miVec04) ## [1] TRUE Si combinamos diferentes tipos de datos, R intentará transformar los elementos en un tipo de forma predeterminada. Si como aquí en el objeto miVec03 tenemos los tipos character y numeric, R convertirá todos los elementos en character. miVec05 &lt;- c(factor(&quot;abc&quot;), &quot;def&quot;) print(miVec05) ## [1] &quot;1&quot; &quot;def&quot; typeof(miVec05) ## [1] &quot;character&quot; miVec06 &lt;- c(TRUE, &quot;def&quot;) print(miVec06) ## [1] &quot;TRUE&quot; &quot;def&quot; typeof(miVec06) ## [1] &quot;character&quot; miVec07 &lt;- c(factor(&quot;abc&quot;), 55) print(miVec07) ## [1] 1 55 typeof(miVec07) ## [1] &quot;double&quot; miVec08 &lt;- c(TRUE, 55) print(miVec08) ## [1] 1 55 typeof(miVec08) ## [1] &quot;double&quot; También podemos combinar objetos existentes dentro de un vector. miVec09 &lt;- c(miVec02, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;) print(miVec09) ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; miVec10 &lt;- c(&quot;aaa&quot;, &quot;aa&quot;, miVec09, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;) print(miVec10) ## [1] &quot;aaa&quot; &quot;aa&quot; &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; miVec11 &lt;- c(789, miVec01 , 564) print(miVec11) ## [1] 789 1 2 3 4 564 8.1.2 Hacer operaciones con un vector También podemos realizar operaciones en un vector. print(miVec01) ## [1] 1 2 3 4 miVec01 + 1 ## [1] 2 3 4 5 miVec01 - 1 ## [1] 0 1 2 3 miVec01 * 2 ## [1] 2 4 6 8 miVec01 /10 ## [1] 0.1 0.2 0.3 0.4 Las operaciones de un vector a otro también son posibles, pero se debe tener cuidado para asegurar que el número de elementos en un vector sea el mismo que el otro, de lo contrario R realizará el cálculo comenzando desde el inicio del vector mas pequeño. Aquí hay un ejemplo para ilustrar lo que R hace: miVec12 &lt;- c(1, 1, 1, 1, 1, 1, 1, 1, 1) print(miVec12) ## [1] 1 1 1 1 1 1 1 1 1 miVec13 &lt;- c(10, 20, 30) print(miVec13) ## [1] 10 20 30 miVec12 + miVec13 # vectores de diferentes tamaños: atención al resultado ## [1] 11 21 31 11 21 31 11 21 31 miVec14 &lt;- c(10, 20, 30, 40, 50, 60, 70, 80, 90) print(miVec14) ## [1] 10 20 30 40 50 60 70 80 90 miVec12 + miVec14 # los vectores tienen el mismo tamaño ## [1] 11 21 31 41 51 61 71 81 91 miVec15 &lt;- c(1, 1, 1, 1) print(miVec15) ## [1] 1 1 1 1 miVec15 + miVec13 # vectores de diferentes tamaños y no múltiples ## Warning in miVec15 + miVec13: la taille d&#39;un objet plus long n&#39;est pas ## multiple de la taille d&#39;un objet plus court ## [1] 11 21 31 11 8.1.3 Acceder a los valores de un vector Suele pasar que sea necesario poder acceder a los valores de un vector, es decir, recuperar un valor o un grupo de valores dentro de un vector. Para acceder a un elemento de un vector usamos los corchetes []. Entre los corchetes, podemos usar un número correspondiente al número del elemento en el vector. miVec20 &lt;- c(10, 20, 30, 40, 50, 60, 70, 80, 90) miVec21 &lt;- c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;, &quot;g&quot;, &quot;h&quot;, &quot;i&quot;) print(miVec20) ## [1] 10 20 30 40 50 60 70 80 90 print(miVec21) ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; &quot;i&quot; print(miVec20[1]) ## [1] 10 print(miVec21[3]) ## [1] &quot;c&quot; También podemos usar la combinación de diferentes elementos (otro vector). print(miVec20[c(1, 5, 9)]) ## [1] 10 50 90 print(miVec21[c(4, 3, 1)]) ## [1] &quot;d&quot; &quot;c&quot; &quot;a&quot; print(miVec21[c(4, 4, 3, 4, 3, 2, 5)]) ## [1] &quot;d&quot; &quot;d&quot; &quot;c&quot; &quot;d&quot; &quot;c&quot; &quot;b&quot; &quot;e&quot; También podemos seleccionar elementos usando un operador de comparación o un operador lógico. print(miVec20[miVec20 &gt;= 50]) ## [1] 50 60 70 80 90 print(miVec20[(miVec20 &gt;= 50) &amp; ((miVec20 &lt; 80))]) ## [1] 50 60 70 print(miVec20[miVec20 != 50]) ## [1] 10 20 30 40 60 70 80 90 print(miVec20[miVec20 == 30]) ## [1] 30 print(miVec20[(miVec20 == 30) | (miVec20 == 50)]) ## [1] 30 50 print(miVec21[miVec21 == &quot;a&quot;]) ## [1] &quot;a&quot; Otra característica interesante es la posibilidad de condicionar los elementos a seleccionar en base a otro vector. print(miVec21[miVec20 &gt;= 50]) ## [1] &quot;e&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; &quot;i&quot; print(miVec21[(miVec20 &gt;= 50) &amp; ((miVec20 &lt; 80))]) ## [1] &quot;e&quot; &quot;f&quot; &quot;g&quot; print(miVec21[miVec20 != 50]) ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; &quot;i&quot; print(miVec21[miVec20 == 30]) ## [1] &quot;c&quot; print(miVec21[(miVec20 == 30) | (miVec20 == 50)]) ## [1] &quot;c&quot; &quot;e&quot; print(miVec21[(miVec20 == 30) | (miVec21 == &quot;h&quot;)]) ## [1] &quot;c&quot; &quot;h&quot; También es posible excluir ciertos elementos en lugar de seleccionarlos. print(miVec20[-1]) ## [1] 20 30 40 50 60 70 80 90 print(miVec21[-5]) ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; &quot;i&quot; print(miVec20[-c(1, 2, 5)]) ## [1] 30 40 60 70 80 90 print(miVec21[-c(1, 2, 5)]) ## [1] &quot;c&quot; &quot;d&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; &quot;i&quot; Los elementos de un vector también se pueden seleccionar sobre la base de un vector tipo logical. En este caso, solo se seleccionarán elementos con un valor TRUE. miVec22 &lt;- c(TRUE, TRUE, FALSE, TRUE, FALSE, TRUE, FALSE, TRUE, TRUE) print(miVec21[miVec22]) ## [1] &quot;a&quot; &quot;b&quot; &quot;d&quot; &quot;f&quot; &quot;h&quot; &quot;i&quot; 8.1.4 Dar nombres a los elementos de un vector Los elementos de un vector se pueden nombrar para referenciarlos y luego selectionarlos. La función names() recupera los nombres de los elementos de un vector. miVec23 &lt;- c(aaa = 10, bbb = 20, ccc = 30, ddd = 40, eee = 50) print(miVec23) ## aaa bbb ccc ddd eee ## 10 20 30 40 50 print(miVec23[&quot;bbb&quot;]) ## bbb ## 20 print(miVec23[c(&quot;bbb&quot;, &quot;ccc&quot;, &quot;bbb&quot;)]) ## bbb ccc bbb ## 20 30 20 names(miVec23) ## [1] &quot;aaa&quot; &quot;bbb&quot; &quot;ccc&quot; &quot;ddd&quot; &quot;eee&quot; 8.1.5 Editar los elementos de un vector Para modificar un vector, operamos de la misma manera que para modificar un objeto simple, con el signo &lt;- y el elemento o los elementos a modificar entre corchetes. print(miVec21) ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; &quot;i&quot; miVec21[3] &lt;- &quot;zzz&quot; print(miVec21) ## [1] &quot;a&quot; &quot;b&quot; &quot;zzz&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; &quot;i&quot; miVec21[(miVec20 &gt;= 50) &amp; ((miVec20 &lt; 80))] &lt;- &quot;qwerty&quot; print(miVec21) ## [1] &quot;a&quot; &quot;b&quot; &quot;zzz&quot; &quot;d&quot; &quot;qwerty&quot; &quot;qwerty&quot; &quot;qwerty&quot; &quot;h&quot; ## [9] &quot;i&quot; print(miVec23) ## aaa bbb ccc ddd eee ## 10 20 30 40 50 miVec23[&quot;ccc&quot;] &lt;- miVec23[&quot;ccc&quot;] + 100 print(miVec23) ## aaa bbb ccc ddd eee ## 10 20 130 40 50 También podemos cambiar los nombres asociados con los elementos de un vector. print(miVec23) ## aaa bbb ccc ddd eee ## 10 20 130 40 50 names(miVec23)[2] &lt;- &quot;bb_bb&quot; print(miVec23) ## aaa bb_bb ccc ddd eee ## 10 20 130 40 50 Podemos hacer mucho más con un vector y volveremos a su manejo y operaciones posibles en el capítulo sobre funciones. 8.2 El contenedor list El segundo tipo de contenedor que vamos a presentar es el contenedor list, que es también el segundo contenedor después del tipovector debido a su importancia en la programación con R. El contenedor de tipo list le permite almacenar listas de elementos. Contrariamente a lo que vimos antes con el tipo vector, los elementos del tipo list pueden ser diferentes (por ejemplo, un vector de tipo numeric, luego un vector de tipo character). Los elementos del tipo list también pueden ser contenedores diferentes (por ejemplo, un vector, luego una list). El tipo de contenedor list tendrá mas sentido cuando hayamos estudiado los bucles y funciones de la familia apply. 8.2.1 Crear una list Para crear una list usaremos la función list(), que toma elementos (objetos) como argumentos. miList01 &lt;- list() print(miList01) ## list() miList02 &lt;- list(5, &quot;qwerty&quot;, c(4, 5, 6), c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)) print(miList02) ## [[1]] ## [1] 5 ## ## [[2]] ## [1] &quot;qwerty&quot; ## ## [[3]] ## [1] 4 5 6 ## ## [[4]] ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; miList03 &lt;- list(5, &quot;qwerty&quot;, list(c(4, 5, 6), c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;))) print(miList03) ## [[1]] ## [1] 5 ## ## [[2]] ## [1] &quot;qwerty&quot; ## ## [[3]] ## [[3]][[1]] ## [1] 4 5 6 ## ## [[3]][[2]] ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; La función is.list() se usa para probar si hemos creado un objeto de tipo list. is.list(miList02) ## [1] TRUE typeof(miList02) ## [1] &quot;list&quot; 8.2.2 Acceder a los valores de una list Los elementos del contenedor list son identificables por los corchetes dobles [[ ]]. print(miList02) ## [[1]] ## [1] 5 ## ## [[2]] ## [1] &quot;qwerty&quot; ## ## [[3]] ## [1] 4 5 6 ## ## [[4]] ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; En el objeto de tipo list miList02, hay cuatro elementos identificables con [[1]], [[2]], [[3]] y [[4]]. Cada uno de los elementos es de tipo vector. El primer elemento tiene un tamaño de 1 con elementos del tipo double, el segundo elemento tiene un tamaño de 1 con elementos del tipo character, el tercero elemento tiene un tamaño de 3 con elementos del tipo double, y el cuarto elemento tiene un tamaño de 3 con elementos del tipo character. typeof(miList02) ## [1] &quot;list&quot; print(miList02[[1]]) ## [1] 5 typeof(miList02[[1]]) ## [1] &quot;double&quot; print(miList02[[2]]) ## [1] &quot;qwerty&quot; typeof(miList02[[2]]) ## [1] &quot;character&quot; print(miList02[[3]]) ## [1] 4 5 6 typeof(miList02[[3]]) ## [1] &quot;double&quot; print(miList02[[4]]) ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; typeof(miList02[[4]]) ## [1] &quot;character&quot; El acceso al segundo elemento del vector ubicado en la cuarta posición de la list se hace con miList02[[4]][2]. Usamos doble corchetes para el cuarto elemento de la list, luego corchetes simples para el segundo elemento del vector. print(miList02[[4]][2]) ## [1] &quot;b&quot; Como una list puede contener una o más list, podemos acceder a la información buscada combinando corchetes dobles. El objeto miList04 es una list de dos elementos: la list miList02 y la list miList03. El objeto miList03 en sí contiene una list como tercer elemento. Para acceder al primer elemento del vector en la primera posición del elemento en la tercera posición del segundo elemento del list miList04, podemos usar miList04[[2]][[3]][[1]][1]. No hay límite en cuanto a la profundidad de list pero en la práctica raramente hay necesidad de hacer list de list de list. miList04 &lt;- list(miList02, miList03) print(miList04) ## [[1]] ## [[1]][[1]] ## [1] 5 ## ## [[1]][[2]] ## [1] &quot;qwerty&quot; ## ## [[1]][[3]] ## [1] 4 5 6 ## ## [[1]][[4]] ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; ## ## ## [[2]] ## [[2]][[1]] ## [1] 5 ## ## [[2]][[2]] ## [1] &quot;qwerty&quot; ## ## [[2]][[3]] ## [[2]][[3]][[1]] ## [1] 4 5 6 ## ## [[2]][[3]][[2]] ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; print(miList04[[2]][[3]][[1]][1]) ## [1] 4 Para concretar el ejemplo anterior, podemos imaginar especies de barrenadores del maíz (Sesamia nonagrioides y Ostrinia nubilalis), muestreados en diferentes sitios, con diferentes abundancias en cuatro fechas. Aquí daremos nombres a los elementos de las list. bddInsect &lt;- list(Snonagrioides = list(site01 = c(12, 5, 8, 7), site02 = c(5, 23, 4, 41), site03 = c(12, 0, 0, 0)), Onubilalis = list(site01 = c(12, 1, 2, 3), site02 = c(0, 0, 0, 1), site03 = c(1, 1, 2, 3))) print(bddInsect) ## $Snonagrioides ## $Snonagrioides$site01 ## [1] 12 5 8 7 ## ## $Snonagrioides$site02 ## [1] 5 23 4 41 ## ## $Snonagrioides$site03 ## [1] 12 0 0 0 ## ## ## $Onubilalis ## $Onubilalis$site01 ## [1] 12 1 2 3 ## ## $Onubilalis$site02 ## [1] 0 0 0 1 ## ## $Onubilalis$site03 ## [1] 1 1 2 3 Leer una larga línea de código como la línea para crear el objeto bddInsect resulta difícil porque la profundidad de los elementos solo se puede deducir de los paréntesis. Es por eso que vamos a reorganizar el código para que sea más legible mediante el margen adicional. El margen adicional implica poner información en diferentes niveles para que podamos identificar rápidamente los diferentes niveles de un código. Para aplicar el margen adicional se presiona la tecla de tabulación. Volveremos al margen adicional con más detalles en el capítulo sobre bucles. Recordemos por el momento que si una línea de código es demasiado larga, podemos saltar de línea y usar el margen adicional. R leerá todo como una sola línea de código. bddInsect &lt;- list( Snonagrioides = list( site01 = c(12, 5, 8, 7), site02 = c(5, 23, 4, 41), site03 = c(12, 0, 0, 0) ), Onubilalis = list( site01 = c(12, 1, 2, 3), site02 = c(0, 0, 0, 1), site03 = c(1, 1, 2, 3) ) ) Podemos seleccionar los datos de abundancia del segundo sitio de la primera especie como previamente bddInsect[[1]][[2]], o alternativamente usando los nombres de los elementos bddInsect$Snonagrioides$site02. Para hacer esto usamos el signo $, o como alternativa el nombre de los elementos con comillas simples o dobles bddInsect[['Snonagrioides']][['sitio02']]. print(bddInsect[[1]][[2]]) ## [1] 5 23 4 41 print(bddInsect$Snonagrioides$site02) ## [1] 5 23 4 41 print(bddInsect[[&#39;Snonagrioides&#39;]][[&#39;site02&#39;]]) ## [1] 5 23 4 41 En cuanto a los vectores, podemos recuperar los nombres de los elementos con la función names(). names(bddInsect) ## [1] &quot;Snonagrioides&quot; &quot;Onubilalis&quot; names(bddInsect[[1]]) ## [1] &quot;site01&quot; &quot;site02&quot; &quot;site03&quot; Cuando usamos los corchetes dobles [[]] o el signo $, R devuelve el contenido del elemento seleccionado. En nuestro ejemplo, los datos de abundancia están contenidos como un vector, por lo que R devuelve un elemento del tipo vector. Si queremos seleccionar un elemento de una list pero manteniendo el formato list, entonces podemos usar corchetes simples []. print(bddInsect[[1]][[2]]) ## [1] 5 23 4 41 typeof(bddInsect[[1]][[2]]) ## [1] &quot;double&quot; is.list(bddInsect[[1]][[2]]) ## [1] FALSE print(bddInsect[[1]][2]) ## $site02 ## [1] 5 23 4 41 typeof(bddInsect[[1]][2]) ## [1] &quot;list&quot; is.list(bddInsect[[1]][2]) ## [1] TRUE El uso de corchetes simples [] es útil cuando queremos recuperar varios elementos de una list. Por ejemplo, para seleccionar las abundancias de insectos de los primeros dos sitios de la primera especie, usaremos bddInsect [[1]][c(1, 2)] o alternativamente bddInsect[[1]][c(&quot;site01&quot;, &quot;sitio02&quot;)]. print(bddInsect[[1]][c(1, 2)]) ## $site01 ## [1] 12 5 8 7 ## ## $site02 ## [1] 5 23 4 41 print(bddInsect[[1]][c(&quot;site01&quot;, &quot;site02&quot;)]) ## $site01 ## [1] 12 5 8 7 ## ## $site02 ## [1] 5 23 4 41 8.2.3 Editar una list Una list se puede modificar de la misma manera que para el contenedor vector, es decir, haciendo referencia con corchetes al elemento que queremos modificar. print(miList02) ## [[1]] ## [1] 5 ## ## [[2]] ## [1] &quot;qwerty&quot; ## ## [[3]] ## [1] 4 5 6 ## ## [[4]] ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; miList02[[1]] &lt;- 12 print(miList02) ## [[1]] ## [1] 12 ## ## [[2]] ## [1] &quot;qwerty&quot; ## ## [[3]] ## [1] 4 5 6 ## ## [[4]] ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; miList02[[4]] &lt;- c(&quot;d&quot;, &quot;e&quot;, &quot;f&quot;) print(miList02) ## [[1]] ## [1] 12 ## ## [[2]] ## [1] &quot;qwerty&quot; ## ## [[3]] ## [1] 4 5 6 ## ## [[4]] ## [1] &quot;d&quot; &quot;e&quot; &quot;f&quot; miList02[[4]] &lt;- c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, miList02[[4]], &quot;g&quot;, &quot;h&quot;, &quot;i&quot;) print(miList02) ## [[1]] ## [1] 12 ## ## [[2]] ## [1] &quot;qwerty&quot; ## ## [[3]] ## [1] 4 5 6 ## ## [[4]] ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; &quot;i&quot; miList02[[4]][5] &lt;- &quot;eee&quot; print(miList02) ## [[1]] ## [1] 12 ## ## [[2]] ## [1] &quot;qwerty&quot; ## ## [[3]] ## [1] 4 5 6 ## ## [[4]] ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;eee&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; &quot;i&quot; miList02[[3]] &lt;- miList02[[3]] * 10 - 1 print(miList02) ## [[1]] ## [1] 12 ## ## [[2]] ## [1] &quot;qwerty&quot; ## ## [[3]] ## [1] 39 49 59 ## ## [[4]] ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;eee&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; &quot;i&quot; miList02[[3]][2] &lt;- miList02[[1]] * 100 print(miList02) ## [[1]] ## [1] 12 ## ## [[2]] ## [1] &quot;qwerty&quot; ## ## [[3]] ## [1] 39 1200 59 ## ## [[4]] ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;eee&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; &quot;i&quot; print(bddInsect) ## $Snonagrioides ## $Snonagrioides$site01 ## [1] 12 5 8 7 ## ## $Snonagrioides$site02 ## [1] 5 23 4 41 ## ## $Snonagrioides$site03 ## [1] 12 0 0 0 ## ## ## $Onubilalis ## $Onubilalis$site01 ## [1] 12 1 2 3 ## ## $Onubilalis$site02 ## [1] 0 0 0 1 ## ## $Onubilalis$site03 ## [1] 1 1 2 3 bddInsect[[&#39;Snonagrioides&#39;]][[&#39;site02&#39;]] &lt;- c(2, 4, 6, 8) print(bddInsect) ## $Snonagrioides ## $Snonagrioides$site01 ## [1] 12 5 8 7 ## ## $Snonagrioides$site02 ## [1] 2 4 6 8 ## ## $Snonagrioides$site03 ## [1] 12 0 0 0 ## ## ## $Onubilalis ## $Onubilalis$site01 ## [1] 12 1 2 3 ## ## $Onubilalis$site02 ## [1] 0 0 0 1 ## ## $Onubilalis$site03 ## [1] 1 1 2 3 Para combinar dos list, simplemente usamos la función c() que hemos usado para crear un vector. miList0203 &lt;- c(miList02, miList03) print(miList0203) ## [[1]] ## [1] 12 ## ## [[2]] ## [1] &quot;qwerty&quot; ## ## [[3]] ## [1] 39 1200 59 ## ## [[4]] ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;eee&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; &quot;i&quot; ## ## [[5]] ## [1] 5 ## ## [[6]] ## [1] &quot;qwerty&quot; ## ## [[7]] ## [[7]][[1]] ## [1] 4 5 6 ## ## [[7]][[2]] ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; Un objeto de tipo list se puede transformar en vector con la función unlist() si el formato de los elementos de la lista lo permite (un vector solo puede contener elementos del mismo tipo). miList05 &lt;- list(&quot;a&quot;, c(&quot;b&quot;, &quot;c&quot;), &quot;d&quot;) print(miList05) ## [[1]] ## [1] &quot;a&quot; ## ## [[2]] ## [1] &quot;b&quot; &quot;c&quot; ## ## [[3]] ## [1] &quot;d&quot; miVec24 &lt;- unlist(miList05) print(miVec24) ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; miList06 &lt;- list(c(1, 2, 3), c(4, 5, 6, 7), 8, 9, c(10, 11)) print(miList06) ## [[1]] ## [1] 1 2 3 ## ## [[2]] ## [1] 4 5 6 7 ## ## [[3]] ## [1] 8 ## ## [[4]] ## [1] 9 ## ## [[5]] ## [1] 10 11 miVec25 &lt;- unlist(miList06) print(miVec25) ## [1] 1 2 3 4 5 6 7 8 9 10 11 Para agregar un elemento a una list, podemos usar la función c() o los corchetes dobles [[ ]]. print(miList05) ## [[1]] ## [1] &quot;a&quot; ## ## [[2]] ## [1] &quot;b&quot; &quot;c&quot; ## ## [[3]] ## [1] &quot;d&quot; miList05 &lt;- c(miList05, &quot;e&quot;) print(miList05) ## [[1]] ## [1] &quot;a&quot; ## ## [[2]] ## [1] &quot;b&quot; &quot;c&quot; ## ## [[3]] ## [1] &quot;d&quot; ## ## [[4]] ## [1] &quot;e&quot; miList05[[5]] &lt;- c(&quot;fgh&quot;, &quot;ijk&quot;) print(miList05) ## [[1]] ## [1] &quot;a&quot; ## ## [[2]] ## [1] &quot;b&quot; &quot;c&quot; ## ## [[3]] ## [1] &quot;d&quot; ## ## [[4]] ## [1] &quot;e&quot; ## ## [[5]] ## [1] &quot;fgh&quot; &quot;ijk&quot; Para eliminar un elemento de una list, la técnica más rápida es establecer NULL en el elemento que deseamos eliminar. print(miList05) ## [[1]] ## [1] &quot;a&quot; ## ## [[2]] ## [1] &quot;b&quot; &quot;c&quot; ## ## [[3]] ## [1] &quot;d&quot; ## ## [[4]] ## [1] &quot;e&quot; ## ## [[5]] ## [1] &quot;fgh&quot; &quot;ijk&quot; miList05[[2]] &lt;- NULL print(miList05) ## [[1]] ## [1] &quot;a&quot; ## ## [[2]] ## [1] &quot;d&quot; ## ## [[3]] ## [1] &quot;e&quot; ## ## [[4]] ## [1] &quot;fgh&quot; &quot;ijk&quot; 8.3 El contenedor data.frame El contenedor data.frame se puede comparar a una tabla. Este es en realidad un caso especial de list donde todos los elementos de la list tienen el mismo tamaño. 8.3.1 Crear un data.frame Para crear un data.frame usamos la función data.frame() que toma como argumentos los elementos de la tabla que queremos crear. Los elementos son del tipo vector y son todos del mismo tamaño. Podemos dar un nombre a cada columna (vector) de nuestra tabla (data.frame). # crear un data.frame miDf01 &lt;- data.frame( numbers = c(1, 2, 3, 4), logicals = c(TRUE, TRUE, FALSE, TRUE), characters = c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;) ) print(miDf01) ## numbers logicals characters ## 1 1 TRUE a ## 2 2 TRUE b ## 3 3 FALSE c ## 4 4 TRUE d # crear vectores, y el data.frame numbers &lt;- c(1, 2, 3, 4) logicals &lt;- c(TRUE, TRUE, FALSE, TRUE) characters &lt;- c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;) miDf01 &lt;- data.frame(numbers, logicals, characters) print(miDf01) ## numbers logicals characters ## 1 1 TRUE a ## 2 2 TRUE b ## 3 3 FALSE c ## 4 4 TRUE d 8.3.2 Acceder a los elementos de un data.frame El acceso a los diferentes valores de un data.frame se puede hacer de la misma manera que para un contenedor de tipo list. print(miDf01$numbers) # vector ## [1] 1 2 3 4 print(miDf01[[1]]) # vector ## [1] 1 2 3 4 print(miDf01[1]) # list ## numbers ## 1 1 ## 2 2 ## 3 3 ## 4 4 print(miDf01[&quot;numbers&quot;]) # list ## numbers ## 1 1 ## 2 2 ## 3 3 ## 4 4 print(miDf01[[&quot;numbers&quot;]]) # vector ## [1] 1 2 3 4 También podemos usar otra forma que consiste en especificar la línea o las líneas seguidas de una coma (con un espacio después de la coma), y luego la columna o columnas entre corchetes. Si se omite la información de línea o columna, R mostrará todas las líneas o columnas. Nuevamente podemos usar el número correspondiente a un elemento o el nombre del elemento que queremos seleccionar. myRow &lt;- 2 myCol &lt;- 1 print(miDf01[myRow, myCol]) ## [1] 2 print(miDf01[myRow, ]) ## numbers logicals characters ## 2 2 TRUE b print(miDf01[, myCol]) ## [1] 1 2 3 4 myCol &lt;- &quot;numbers&quot; print(miDf01[, myCol]) ## [1] 1 2 3 4 Es posible seleccionar múltiples líneas o columnas. print(miDf01[, c(1, 2)]) ## numbers logicals ## 1 1 TRUE ## 2 2 TRUE ## 3 3 FALSE ## 4 4 TRUE print(miDf01[c(2, 1), ]) ## numbers logicals characters ## 2 2 TRUE b ## 1 1 TRUE a Como cada columna está en formato vector, también podemos hacer una selección que depende del contenido con operadores de comparación y operadores lógicos. miDfSub01 &lt;- miDf01[miDf01$numbers &gt; 2, ] print(miDfSub01) ## numbers logicals characters ## 3 3 FALSE c ## 4 4 TRUE d miDfSub02 &lt;- miDf01[(miDf01$logicals == TRUE) &amp; (miDf01$numbers &lt; 2), ] print(miDfSub02) ## numbers logicals characters ## 1 1 TRUE a miDfSub03 &lt;- miDf01[(miDf01$numbers %% 2) == 0, ] print(miDfSub03) ## numbers logicals characters ## 2 2 TRUE b ## 4 4 TRUE d miDfSub04 &lt;- miDf01[((miDf01$numbers %% 2) == 0) | (miDf01$logicals == TRUE), ] print(miDfSub04) ## numbers logicals characters ## 1 1 TRUE a ## 2 2 TRUE b ## 4 4 TRUE d 8.3.3 Modificar un data.frame Para agregar un elemento a un data.frame, procedemos como para un contenedor de tipo list. Es necesario asegurarse de que el nuevo elemento sea del mismo tamaño que los otros elementos de nuestro data.frame. Por defecto, un nuevo elemento en data.frame toma el nombre de la letra V seguido del número de la columna. Podemos cambiar los nombres de las columnas con la función colnames(). Podemos nombrar las líneas con la función rownames(). newVec &lt;- c(4, 5, 6, 7) miDf01[[4]] &lt;- newVec print(miDf01) ## numbers logicals characters V4 ## 1 1 TRUE a 4 ## 2 2 TRUE b 5 ## 3 3 FALSE c 6 ## 4 4 TRUE d 7 print(colnames(miDf01)) ## [1] &quot;numbers&quot; &quot;logicals&quot; &quot;characters&quot; &quot;V4&quot; colnames(miDf01)[4] &lt;- &quot;newVec&quot; print(miDf01) ## numbers logicals characters newVec ## 1 1 TRUE a 4 ## 2 2 TRUE b 5 ## 3 3 FALSE c 6 ## 4 4 TRUE d 7 print(rownames(miDf01)) ## [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; rownames(miDf01) &lt;- c(&quot;row1&quot;, &quot;row2&quot;, &quot;row3&quot;, &quot;row4&quot;) print(miDf01) ## numbers logicals characters newVec ## row1 1 TRUE a 4 ## row2 2 TRUE b 5 ## row3 3 FALSE c 6 ## row4 4 TRUE d 7 newVec2 &lt;- c(40, 50, 60, 70) miDf01$newVec2 &lt;- newVec2 print(miDf01) ## numbers logicals characters newVec newVec2 ## row1 1 TRUE a 4 40 ## row2 2 TRUE b 5 50 ## row3 3 FALSE c 6 60 ## row4 4 TRUE d 7 70 Como el contenedor de tipo data.frame es un caso especial de list, la selección y modificación se realiza como un contenedor de tipo list. Dado que los elementos de un data.frame son del tipo vector, la selección y la modificación de los elementos de un data.frame se hace como para un contenedor vector. miDf01$newVec2 &lt;- miDf01$newVec2 * 2 print(miDf01) ## numbers logicals characters newVec newVec2 ## row1 1 TRUE a 4 80 ## row2 2 TRUE b 5 100 ## row3 3 FALSE c 6 120 ## row4 4 TRUE d 7 140 miDf01$newVec2 + miDf01$newVec ## [1] 84 105 126 147 miDf01$newVec2[2] &lt;- 0 print(miDf01) ## numbers logicals characters newVec newVec2 ## row1 1 TRUE a 4 80 ## row2 2 TRUE b 5 0 ## row3 3 FALSE c 6 120 ## row4 4 TRUE d 7 140 Un vector se puede transformar en data.frame con la función as.data.frame(). print(newVec2) ## [1] 40 50 60 70 print(as.data.frame(newVec2)) ## newVec2 ## 1 40 ## 2 50 ## 3 60 ## 4 70 is.data.frame(newVec2) ## [1] FALSE is.data.frame(as.data.frame(newVec2)) ## [1] TRUE 8.4 El contenedor matrix El contenedor matrix se puede ver como un vector de dos dimensiones: líneas y columnas. Corresponde a una matriz en matemáticas, y puede contener solo un tipo de datos (logical, numeric, character, …). 8.4.1 Crear una matrix Para crear una matrix primero creamos un vector, luego especificamos el número deseado de líneas y columnas en la función matrix(). vecForMatrix &lt;- c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12) miMat &lt;- matrix(vecForMatrix, nrow = 3, ncol = 4) print(miMat) ## [,1] [,2] [,3] [,4] ## [1,] 1 4 7 10 ## [2,] 2 5 8 11 ## [3,] 3 6 9 12 No tenemos que especificar el número de líneas nrow y el número de columnas ncol. Si usamos uno u otro de estos argumentos, R calculará automáticamente el número correspondiente. miMat &lt;- matrix(vecForMatrix, nrow = 3) print(miMat) ## [,1] [,2] [,3] [,4] ## [1,] 1 4 7 10 ## [2,] 2 5 8 11 ## [3,] 3 6 9 12 miMat &lt;- matrix(vecForMatrix, ncol = 4) print(miMat) ## [,1] [,2] [,3] [,4] ## [1,] 1 4 7 10 ## [2,] 2 5 8 11 ## [3,] 3 6 9 12 Observamos que los diferentes elementos del vector inicial aparecen por columna. Si queremos llenar la matrix empezando por línea, entonces tenemos que dar como valor TRUE al argumento byrow. miMat &lt;- matrix(vecForMatrix, nrow = 3, byrow = TRUE) print(miMat) ## [,1] [,2] [,3] [,4] ## [1,] 1 2 3 4 ## [2,] 5 6 7 8 ## [3,] 9 10 11 12 También podemos dar un nombre a las líneas y columnas de nuestra matrix cuando se crea con el argumento dimnames que toma como valor una list de dos elementos: el nombre de las líneas y luego el nombre de las columnas. También podemos cambiar el nombre de las líneas y columnas a posteriori con las funciones rownames() y colnames(). miMat &lt;- matrix( vecForMatrix, nrow = 3, byrow = TRUE, dimnames = list(c(&quot;r1&quot;, &quot;r2&quot;, &quot;r3&quot;), c(&quot;c1&quot;, &quot;c2&quot;, &quot;c3&quot;, &quot;c4&quot;)) ) print(miMat) ## c1 c2 c3 c4 ## r1 1 2 3 4 ## r2 5 6 7 8 ## r3 9 10 11 12 colnames(miMat) &lt;- c(&quot;col1&quot;, &quot;col2&quot;, &quot;col3&quot;, &quot;col4&quot;) rownames(miMat) &lt;- c(&quot;row1&quot;, &quot;row2&quot;, &quot;row3&quot;) print(miMat) ## col1 col2 col3 col4 ## row1 1 2 3 4 ## row2 5 6 7 8 ## row3 9 10 11 12 Es posible crear una matrix desde un data.frame con la función as.matrix(). Tenemos que verificar que nuestra data.frame contenga solo elementos del mismo tipo (por ejemplo, elementos de tipo numeric). vecForMat01 &lt;- c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12) vecForMat02 &lt;- vecForMat01 * 10 vecForMat03 &lt;- vecForMat01 / 10 dfForMat &lt;- data.frame(vecForMat01, vecForMat02, vecForMat03) print(dfForMat) ## vecForMat01 vecForMat02 vecForMat03 ## 1 1 10 0.1 ## 2 2 20 0.2 ## 3 3 30 0.3 ## 4 4 40 0.4 ## 5 5 50 0.5 ## 6 6 60 0.6 ## 7 7 70 0.7 ## 8 8 80 0.8 ## 9 9 90 0.9 ## 10 10 100 1.0 ## 11 11 110 1.1 ## 12 12 120 1.2 is.matrix(dfForMat) ## [1] FALSE as.matrix(dfForMat) ## vecForMat01 vecForMat02 vecForMat03 ## [1,] 1 10 0.1 ## [2,] 2 20 0.2 ## [3,] 3 30 0.3 ## [4,] 4 40 0.4 ## [5,] 5 50 0.5 ## [6,] 6 60 0.6 ## [7,] 7 70 0.7 ## [8,] 8 80 0.8 ## [9,] 9 90 0.9 ## [10,] 10 100 1.0 ## [11,] 11 110 1.1 ## [12,] 12 120 1.2 is.matrix(as.matrix(dfForMat)) ## [1] TRUE También podemos crear una matrix desde un vector con la función as.matrix() (matriz de una sola columna). as.matrix(vecForMat01) ## [,1] ## [1,] 1 ## [2,] 2 ## [3,] 3 ## [4,] 4 ## [5,] 5 ## [6,] 6 ## [7,] 7 ## [8,] 8 ## [9,] 9 ## [10,] 10 ## [11,] 11 ## [12,] 12 8.4.2 Manipular y hacer operaciones en una matrix Todas las operaciones término a término son posibles con una matrix. # operaciones término a término miMat01 &lt;- matrix(vecForMat01, ncol = 3) miVecOp &lt;- c(1, 10, 100, 1000) miMat01 * miVecOp ## [,1] [,2] [,3] ## [1,] 1 5 9 ## [2,] 20 60 100 ## [3,] 300 700 1100 ## [4,] 4000 8000 12000 miMat01 + miVecOp ## [,1] [,2] [,3] ## [1,] 2 6 10 ## [2,] 12 16 20 ## [3,] 103 107 111 ## [4,] 1004 1008 1012 miMat01 / miMat01 ## [,1] [,2] [,3] ## [1,] 1 1 1 ## [2,] 1 1 1 ## [3,] 1 1 1 ## [4,] 1 1 1 miMat01 - 10 ## [,1] [,2] [,3] ## [1,] -9 -5 -1 ## [2,] -8 -4 0 ## [3,] -7 -3 1 ## [4,] -6 -2 2 Para realizar operaciones algebraicas, podemos usar la función %*%. # operaciones algebraicas miVecConf &lt;- c(1, 10, 100) miMat01 %*% miVecConf ## [,1] ## [1,] 951 ## [2,] 1062 ## [3,] 1173 ## [4,] 1284 miMat02 &lt;- matrix(c(1, 2, 3, 4, 5, 6, 7, 8, 9), ncol = 3) print(miMat02) ## [,1] [,2] [,3] ## [1,] 1 4 7 ## [2,] 2 5 8 ## [3,] 3 6 9 miMat02 %*% miMat02 ## [,1] [,2] [,3] ## [1,] 30 66 102 ## [2,] 36 81 126 ## [3,] 42 96 150 La diagonal de una matrix se puede obtener con la función diag() y el determinante de una matrix con la función det(). print(miMat02) ## [,1] [,2] [,3] ## [1,] 1 4 7 ## [2,] 2 5 8 ## [3,] 3 6 9 diag(miMat02) ## [1] 1 5 9 det(miMat02) ## [1] 0 Suele ser útil poder hacer una transposición de matrix (columnas en líneas o líneas en columnas). Para eso, están las funciones aperm() o t(). la función t() es más genérica y también funciona con data.frame. aperm(miMat01) ## [,1] [,2] [,3] [,4] ## [1,] 1 2 3 4 ## [2,] 5 6 7 8 ## [3,] 9 10 11 12 t(miMat01) ## [,1] [,2] [,3] [,4] ## [1,] 1 2 3 4 ## [2,] 5 6 7 8 ## [3,] 9 10 11 12 8.4.3 Acceder a los elementos de una matrix Tal como hemos hecho con los data.frame, podemos acceder a los elementos de una matrix especificando un número de línea y un número de columna entre corchetes simples [ ], y separados por una coma. Si i es el número de línea y j es el número de columna, entonces miMat01[i, j] devuelve el elemento en la línea i y en la columnaj. miMat01[i,] devuelve todos los elementos de la línea i, y miMat01[, j] todos los elementos de la columna j. Múltiples selecciones son posibles. También podemos acceder a un elemento de acuerdo con su posición en la matrix entre corchetes simples [ ] contando por columna y luego por línea. En nuestro ejemplo, el valor del décimo elemento es 10. i &lt;- 2 j &lt;- 1 print(miMat01[i, j]) ## [1] 2 print(miMat01[i, ]) ## [1] 2 6 10 print(miMat01[, j]) ## [1] 1 2 3 4 print(miMat01[c(1, 2), c(2, 3)]) ## [,1] [,2] ## [1,] 5 9 ## [2,] 6 10 print(miMat01[10]) ## [1] 10 8.5 El contenedor array El contenedor array es una generalización del contenedor de tipo matrix. Donde el tipo matrix tiene dos dimensiones (líneas y columnas), el tipo array tiene un número indefinido de dimensiones. Podemos saber el número de dimensiones de un array (y por lo tanto una matrix) con la función dim(). dim(miMat01) ## [1] 4 3 8.5.1 Crear un array La creación de una array es similar a la de una matrix con una dimensión extra. miVecArr &lt;- c(1, 2, 3, 4, 5, 6, 7, 8, 9) miArray &lt;- array(miVecArr, dim = c(3, 3, 2)) print(miArray) ## , , 1 ## ## [,1] [,2] [,3] ## [1,] 1 4 7 ## [2,] 2 5 8 ## [3,] 3 6 9 ## ## , , 2 ## ## [,1] [,2] [,3] ## [1,] 1 4 7 ## [2,] 2 5 8 ## [3,] 3 6 9 dim(miArray) ## [1] 3 3 2 is.array(miArray) ## [1] TRUE miVecArr02 &lt;- 10 * miVecArr miArray02 &lt;- array(c(miVecArr, miVecArr02), dim = c(3, 3, 2)) print(miArray02) ## , , 1 ## ## [,1] [,2] [,3] ## [1,] 1 4 7 ## [2,] 2 5 8 ## [3,] 3 6 9 ## ## , , 2 ## ## [,1] [,2] [,3] ## [1,] 10 40 70 ## [2,] 20 50 80 ## [3,] 30 60 90 dim(miArray02) ## [1] 3 3 2 is.array(miArray02) ## [1] TRUE Podemos dar nombres a líneas y columnas, pero también a elementos. miArray02 &lt;- array( c(miVecArr, miVecArr02), dim = c(3, 3, 2), dimnames = list( c(&quot;r1&quot;, &quot;r2&quot;, &quot;r3&quot;), c(&quot;c1&quot;, &quot;c2&quot;, &quot;c3&quot;), c(&quot;matrix1&quot;, &quot;matrix2&quot;) ) ) print(miArray02) ## , , matrix1 ## ## c1 c2 c3 ## r1 1 4 7 ## r2 2 5 8 ## r3 3 6 9 ## ## , , matrix2 ## ## c1 c2 c3 ## r1 10 40 70 ## r2 20 50 80 ## r3 30 60 90 8.5.2 Manipular un array La manipulación de un array se hace de la misma manera que para una matrix. Para acceder a los diferentes elementos de un array, simplemente hay que especificar la línea i, la columna j, y la matrix k. i &lt;- 2 j &lt;- 1 k &lt;- 1 print(miArray02[i, j, k]) ## [1] 2 print(miArray02[, j, k]) ## r1 r2 r3 ## 1 2 3 print(miArray02[i, , k]) ## c1 c2 c3 ## 2 5 8 print(miArray02[i, j, ]) ## matrix1 matrix2 ## 2 20 8.6 Conclusión Felicitaciones! Ahora conocemos los principales tipos de objetos que usaremos con R. Un objeto se caracteriza por sus atributos: el tipo de contenedor (vector, data.frame, matrix, array) el tipo de contenido de cada elemento (numeric, logical, character, …) el valor de cada uno de los elementos (5, “qwerty”, TRUE, …) Todos estos objetos se almacenan temporalmente en el entorno global de R (en la memoria RAM de nuestra computadora). El siguiente capítulo tratará las funciones y resaltará uno de los aspectos que hace que R sea tan poderoso para analizar y administrar nuestros datos. "],
["fonctions.html", " 9 Las funciones 9.1 ¿Qué es una función? 9.2 Las funciones más comunes 9.3 Otras funciones útiles 9.4 Algunos ejercicios para practicar 9.5 Escribir una función 9.6 Otras funciones desarrolladas por la comunidad de usuarios: los packages 9.7 Conclusión", " 9 Las funciones 9.1 ¿Qué es una función? Con este capítulo vamos a echar un primer vistazo al poder de R a través de las funciones. Una función es un conjunto de líneas de código para realizar una tarea en particular. Hemos visto muchas funciones en capítulos anteriores, unas simples como la función + para añadir números, o otras más complejas como c() o data.frame() que permiten crear un vector o data.frame. En cualquier caso, se puede reconocer una función gracias a los paréntesis que la siguen en los cuales vamos a ingresar argumentos. Los argumentos corresponden a la información que queremos transmitir a nuestra función para que realice la tarea que queremos lograr. Para funciones simples como +, los paréntesis han sido eliminados para que el código sea más fácil de leer, pero es una función que puede usarse con paréntesis si usamos el signo + entre comillas. Los argumentos son los números que queremos agregar. 5 + 2 ## [1] 7 &#39;+&#39;(5, 2) ## [1] 7 En este capítulo nos enfocaremos en las funciones más comunes. No se trata de aprender todo de memoria, sino de saber que existen estas funciones y de poder consultar más adelante este capítulo como referencia. ¡Con tiempo y práctica eventualmente los sabremos de memoria! Hay más de 1000 funciones en la versión básica de R, y más de 10000 paquetes adicionales que se pueden instalar, cada uno con docenas de funciones. Antes de comenzar a escribir una nueva función, siempre debemos verificar que ya no exista. 9.2 Las funciones más comunes Para trabajar con las funciones, vamos a usar los datos iris que están incluidos con la versión básica de R y que corresponden a la longitud y el ancho de los sépalos y pétalos de diferentes especies de iris. Los datos iris estan en una data.frame de 5 columnas y 150 líneas. Para obtener más información sobre los datos iris, podemos consultar la documentación R con la función help(iris). El acceso a la documentación es el tema de la siguiente sección. 9.2.1 El acceso a la documentación 9.2.1.1 help() La función esencial de R es acceder a la documentación (en ingles). Todas las funciones R tienen documentación. Podemos acceder a la documentación con la función help() o usando el atajo ?. help(matrix) # equivalente a ?matrix La documentación siempre está estructurada de la misma manera. Primero tenemos el nombre de la función buscada matrix, seguida entre llaves por el nombre del paquete R cuya función depende. Veremos cómo instalar paquetes adicionales más adelante. Por ahora tenemos los que vienen con la versión básica de R. Aquí podemos ver que la función matrix() depende del paquete base. Podemos ver la etiqueta de la función (Matrices), seguida de los parafos Description, Usage, y Arguments. Algunas veces se agregan los párrafos Details, Note, References y See also. El último párrafo es Ejemplos. La última línea de la documentación permite volver al índice del paquete del que depende la función consultada. Al copiar help(matrix) en nuestra consola R, podemos ver que el párrafo Description indica lo que hace la función. En el caso de help(matrix), hay tres funciones: matrix(), as.matrix() y is.matrix(). # Description # matrix creates a matrix from the given set of values. # as.matrix attempts to turn its argument into a matrix. # is.matrix tests if its argument is a (strict) matrix. El párrafo Usage explica cómo usar la función y cuáles son los valores predeterminados para cada parámetro. # Usage # matrix(data = NA, nrow = 1, ncol = 1, byrow = FALSE, # dimnames = NULL) La función matrix() puede tomar 5 argumentos: data, nrow, ncol, byrow, y dimnames. Podemos ver que por defecto una matrix consistirá de una sola línea y una sola columna, y que la información se completará por columna. El párrafo Arguments detalla los valores y el tipo de contenedor de cada argumento de nuestra función. Por ejemplo, podemos ver que el argumento dimnames debe ser del tipo list. Es por eso que hemos usado este formato en la sección matrix. # Arguments # data an optional data vector (including a list or expression vector). # Non-atomic classed R objects are coerced by as.vector and all # attributes discarded. # nrow the desired number of rows. # ncol the desired number of columns. # byrow logical. If FALSE (the default) the matrix is filled by columns, # otherwise the matrix is filled by rows. # dimnames A dimnames attribute for the matrix: NULL or a list of length 2 # giving the row and column names respectively. An empty list is # treated as NULL, and a list of length one as row names. The # list can be named, and the list names will be used as names for # the dimensions. El párrafo Details proporciona elementos adicionales en la función. El párrafo Examples proporciona ejemplos reproducibles en la consola. ## Example of setting row and column names mdat &lt;- matrix(c(1,2,3, 11,12,13), nrow = 2, ncol = 3, byrow = TRUE, dimnames = list(c(&quot;row1&quot;, &quot;row2&quot;), c(&quot;C.1&quot;, &quot;C.2&quot;, &quot;C.3&quot;))) mdat ## C.1 C.2 C.3 ## row1 1 2 3 ## row2 11 12 13 El nombre de los argumentos no es necesario para que una función sea interpretada correctamente por R. Sin embargo, es mejor usar explicitamente el nombre de los argumentos seguidos por el signo = para que el código sea más legible. # buen ejemplo mdat &lt;- matrix(c(1, 2, 3, 11, 12, 13), nrow = 2, ncol = 3, byrow = TRUE) # mal ejemplo mdat &lt;- matrix(c(1, 2, 3, 11, 12, 13), 2, 3, TRUE) 9.2.1.2 help.search() La función help.search() o ?? permite buscar una expresión en toda la documentación. Es útil cuando buscamos una función sin saber el nombre exacto de la función en R. help.search(&quot;average&quot;) La función help.search() devuelve una página que contiene la lista de páginas donde se encontró la expresión en la forma package-name::function-name. 9.2.2 Ver los datos 9.2.2.1 str() La función str() permite visualizar la estructura interna de un objeto, como se indica en la documentación que podemos consultar con help(str). str(iris) ## &#39;data.frame&#39;: 150 obs. of 5 variables: ## $ Sepal.Length: num 5.1 4.9 4.7 4.6 5 5.4 4.6 5 4.4 4.9 ... ## $ Sepal.Width : num 3.5 3 3.2 3.1 3.6 3.9 3.4 3.4 2.9 3.1 ... ## $ Petal.Length: num 1.4 1.4 1.3 1.5 1.4 1.7 1.4 1.5 1.4 1.5 ... ## $ Petal.Width : num 0.2 0.2 0.2 0.2 0.2 0.4 0.3 0.2 0.2 0.1 ... ## $ Species : Factor w/ 3 levels &quot;setosa&quot;,&quot;versicolor&quot;,..: 1 1 1 1 1 1 1 1 1 1 ... La función str() devuelve el tipo de objeto (data.frame), el número de observaciones (150), el número de variables (5), el nombre de cada variable (Sepal.Length , Sepal.Width, Petal.Length, Petal.Width, y Species), el tipo de cada variable (num,Factor), y los primeros valores de cada una de las variables. Es una función útil para echar un vistazo a un conjunto de datos, pero también para verificar que los datos sean del tipo requirido antes de realizar un análisis estadístico. 9.2.2.2 head() y tail() La función head() devuelve los primeros valores de un objeto, y la función tail() devuelve los últimos valores de un objeto. Por defecto, se devuelven seis valores, el argumento n controla el número de valores a devolver. head(iris) ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 1 5.1 3.5 1.4 0.2 setosa ## 2 4.9 3.0 1.4 0.2 setosa ## 3 4.7 3.2 1.3 0.2 setosa ## 4 4.6 3.1 1.5 0.2 setosa ## 5 5.0 3.6 1.4 0.2 setosa ## 6 5.4 3.9 1.7 0.4 setosa tail(iris) ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 145 6.7 3.3 5.7 2.5 virginica ## 146 6.7 3.0 5.2 2.3 virginica ## 147 6.3 2.5 5.0 1.9 virginica ## 148 6.5 3.0 5.2 2.0 virginica ## 149 6.2 3.4 5.4 2.3 virginica ## 150 5.9 3.0 5.1 1.8 virginica head(iris, n = 2) ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 1 5.1 3.5 1.4 0.2 setosa ## 2 4.9 3.0 1.4 0.2 setosa 9.2.2.3 names() Ya hemos visto la función names(), que permite conocer los nombres de los elementos de un objeto, pero también asignar nombres a los elementos de un objeto como a un matrix, a una list o a un data.frame. names(iris) ## [1] &quot;Sepal.Length&quot; &quot;Sepal.Width&quot; &quot;Petal.Length&quot; &quot;Petal.Width&quot; ## [5] &quot;Species&quot; irisCopy &lt;- iris names(irisCopy) &lt;- c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;) names(irisCopy) ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; 9.2.2.4 cat() et print() La función cat() se usa para mostrar el contenido de un objeto mientras que la función print() devuelve el valor de un objeto con la capacidad de realizar conversiones. cat(names(iris)) ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species print(names(iris)) ## [1] &quot;Sepal.Length&quot; &quot;Sepal.Width&quot; &quot;Petal.Length&quot; &quot;Petal.Width&quot; ## [5] &quot;Species&quot; cat(iris[1, 1]) ## 5.1 print(iris[1, 1]) ## [1] 5.1 print(iris[1, 1], digits = 0) ## [1] 5 9.2.3 Manipular los datos 9.2.3.1 rank() La función rank() devuelve el número de la posición ordenada de cada elemento de un conjunto de elementos. En el caso de elementos del mismo valor, el argumento ties.method hace posible hacer una elección sobre la clasificación. Como con todas las funciones, los detalles están presentes en la documentación. vecManip &lt;- c(10, 20, 30, 70, 60, 50, 40) rank(vecManip) ## [1] 1 2 3 7 6 5 4 vecManip2 &lt;- c(10, 20, 30, 10, 50, 10, 40) rank(vecManip2) ## [1] 2 4 5 2 7 2 6 rank(vecManip2, ties.method = &quot;first&quot;) ## [1] 1 4 5 2 7 3 6 rank(vecManip2, ties.method = &quot;min&quot;) ## [1] 1 4 5 1 7 1 6 print(iris[, 1]) ## [1] 5.1 4.9 4.7 4.6 5.0 5.4 4.6 5.0 4.4 4.9 5.4 4.8 4.8 4.3 5.8 5.7 5.4 ## [18] 5.1 5.7 5.1 5.4 5.1 4.6 5.1 4.8 5.0 5.0 5.2 5.2 4.7 4.8 5.4 5.2 5.5 ## [35] 4.9 5.0 5.5 4.9 4.4 5.1 5.0 4.5 4.4 5.0 5.1 4.8 5.1 4.6 5.3 5.0 7.0 ## [52] 6.4 6.9 5.5 6.5 5.7 6.3 4.9 6.6 5.2 5.0 5.9 6.0 6.1 5.6 6.7 5.6 5.8 ## [69] 6.2 5.6 5.9 6.1 6.3 6.1 6.4 6.6 6.8 6.7 6.0 5.7 5.5 5.5 5.8 6.0 5.4 ## [86] 6.0 6.7 6.3 5.6 5.5 5.5 6.1 5.8 5.0 5.6 5.7 5.7 6.2 5.1 5.7 6.3 5.8 ## [103] 7.1 6.3 6.5 7.6 4.9 7.3 6.7 7.2 6.5 6.4 6.8 5.7 5.8 6.4 6.5 7.7 7.7 ## [120] 6.0 6.9 5.6 7.7 6.3 6.7 7.2 6.2 6.1 6.4 7.2 7.4 7.9 6.4 6.3 6.1 7.7 ## [137] 6.3 6.4 6.0 6.9 6.7 6.9 5.8 6.8 6.7 6.7 6.3 6.5 6.2 5.9 rank(iris[, 1], ties.method = &quot;average&quot;) ## [1] 37.0 19.5 10.5 7.5 27.5 49.5 7.5 27.5 3.0 19.5 49.5 ## [12] 14.0 14.0 1.0 77.0 69.5 49.5 37.0 69.5 37.0 49.5 37.0 ## [23] 7.5 37.0 14.0 27.5 27.5 43.5 43.5 10.5 14.0 49.5 43.5 ## [34] 56.0 19.5 27.5 56.0 19.5 3.0 37.0 27.5 5.0 3.0 27.5 ## [45] 37.0 14.0 37.0 7.5 46.0 27.5 138.0 112.0 135.5 56.0 118.0 ## [56] 69.5 104.0 19.5 121.5 43.5 27.5 82.0 86.5 92.5 62.5 126.5 ## [67] 62.5 77.0 97.5 62.5 82.0 92.5 104.0 92.5 112.0 121.5 132.0 ## [78] 126.5 86.5 69.5 56.0 56.0 77.0 86.5 49.5 86.5 126.5 104.0 ## [89] 62.5 56.0 56.0 92.5 77.0 27.5 62.5 69.5 69.5 97.5 37.0 ## [100] 69.5 104.0 77.0 139.0 104.0 118.0 145.0 19.5 143.0 126.5 141.0 ## [111] 118.0 112.0 132.0 69.5 77.0 112.0 118.0 147.5 147.5 86.5 135.5 ## [122] 62.5 147.5 104.0 126.5 141.0 97.5 92.5 112.0 141.0 144.0 150.0 ## [133] 112.0 104.0 92.5 147.5 104.0 112.0 86.5 135.5 126.5 135.5 77.0 ## [144] 132.0 126.5 126.5 104.0 118.0 97.5 82.0 # help(rank) # ... # Usage # rank(x, na.last = TRUE, # ties.method = c(&quot;average&quot;, &quot;first&quot;, &quot;last&quot;, # &quot;random&quot;, &quot;max&quot;, &quot;min&quot;)) 9.2.3.2 order() La función order() devuelve el número de la reorganización de los elementos en función de su posición. Es muy útil, por ejemplo, para ordenar un data.frame en función de una columna. print(vecManip2) ## [1] 10 20 30 10 50 10 40 rank(vecManip2) ## [1] 2 4 5 2 7 2 6 order(vecManip2) ## [1] 1 4 6 2 3 7 5 print(iris[, 1]) ## [1] 5.1 4.9 4.7 4.6 5.0 5.4 4.6 5.0 4.4 4.9 5.4 4.8 4.8 4.3 5.8 5.7 5.4 ## [18] 5.1 5.7 5.1 5.4 5.1 4.6 5.1 4.8 5.0 5.0 5.2 5.2 4.7 4.8 5.4 5.2 5.5 ## [35] 4.9 5.0 5.5 4.9 4.4 5.1 5.0 4.5 4.4 5.0 5.1 4.8 5.1 4.6 5.3 5.0 7.0 ## [52] 6.4 6.9 5.5 6.5 5.7 6.3 4.9 6.6 5.2 5.0 5.9 6.0 6.1 5.6 6.7 5.6 5.8 ## [69] 6.2 5.6 5.9 6.1 6.3 6.1 6.4 6.6 6.8 6.7 6.0 5.7 5.5 5.5 5.8 6.0 5.4 ## [86] 6.0 6.7 6.3 5.6 5.5 5.5 6.1 5.8 5.0 5.6 5.7 5.7 6.2 5.1 5.7 6.3 5.8 ## [103] 7.1 6.3 6.5 7.6 4.9 7.3 6.7 7.2 6.5 6.4 6.8 5.7 5.8 6.4 6.5 7.7 7.7 ## [120] 6.0 6.9 5.6 7.7 6.3 6.7 7.2 6.2 6.1 6.4 7.2 7.4 7.9 6.4 6.3 6.1 7.7 ## [137] 6.3 6.4 6.0 6.9 6.7 6.9 5.8 6.8 6.7 6.7 6.3 6.5 6.2 5.9 rank(iris[, 1]) ## [1] 37.0 19.5 10.5 7.5 27.5 49.5 7.5 27.5 3.0 19.5 49.5 ## [12] 14.0 14.0 1.0 77.0 69.5 49.5 37.0 69.5 37.0 49.5 37.0 ## [23] 7.5 37.0 14.0 27.5 27.5 43.5 43.5 10.5 14.0 49.5 43.5 ## [34] 56.0 19.5 27.5 56.0 19.5 3.0 37.0 27.5 5.0 3.0 27.5 ## [45] 37.0 14.0 37.0 7.5 46.0 27.5 138.0 112.0 135.5 56.0 118.0 ## [56] 69.5 104.0 19.5 121.5 43.5 27.5 82.0 86.5 92.5 62.5 126.5 ## [67] 62.5 77.0 97.5 62.5 82.0 92.5 104.0 92.5 112.0 121.5 132.0 ## [78] 126.5 86.5 69.5 56.0 56.0 77.0 86.5 49.5 86.5 126.5 104.0 ## [89] 62.5 56.0 56.0 92.5 77.0 27.5 62.5 69.5 69.5 97.5 37.0 ## [100] 69.5 104.0 77.0 139.0 104.0 118.0 145.0 19.5 143.0 126.5 141.0 ## [111] 118.0 112.0 132.0 69.5 77.0 112.0 118.0 147.5 147.5 86.5 135.5 ## [122] 62.5 147.5 104.0 126.5 141.0 97.5 92.5 112.0 141.0 144.0 150.0 ## [133] 112.0 104.0 92.5 147.5 104.0 112.0 86.5 135.5 126.5 135.5 77.0 ## [144] 132.0 126.5 126.5 104.0 118.0 97.5 82.0 order(iris[, 1]) ## [1] 14 9 39 43 42 4 7 23 48 3 30 12 13 25 31 46 2 ## [18] 10 35 38 58 107 5 8 26 27 36 41 44 50 61 94 1 18 ## [35] 20 22 24 40 45 47 99 28 29 33 60 49 6 11 17 21 32 ## [52] 85 34 37 54 81 82 90 91 65 67 70 89 95 122 16 19 56 ## [69] 80 96 97 100 114 15 68 83 93 102 115 143 62 71 150 63 79 ## [86] 84 86 120 139 64 72 74 92 128 135 69 98 127 149 57 73 88 ## [103] 101 104 124 134 137 147 52 75 112 116 129 133 138 55 105 111 117 ## [120] 148 59 76 66 78 87 109 125 141 145 146 77 113 144 53 121 140 ## [137] 142 51 103 110 126 130 108 131 106 118 119 123 136 132 head(iris[order(iris[, 1]),], n = 10) ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 14 4.3 3.0 1.1 0.1 setosa ## 9 4.4 2.9 1.4 0.2 setosa ## 39 4.4 3.0 1.3 0.2 setosa ## 43 4.4 3.2 1.3 0.2 setosa ## 42 4.5 2.3 1.3 0.3 setosa ## 4 4.6 3.1 1.5 0.2 setosa ## 7 4.6 3.4 1.4 0.3 setosa ## 23 4.6 3.6 1.0 0.2 setosa ## 48 4.6 3.2 1.4 0.2 setosa ## 3 4.7 3.2 1.3 0.2 setosa 9.2.3.3 sort() La función sort() se usa para ordenar los elementos de un objeto. No permite la clasificación por más de una variable, como es el caso de order(). print(vecManip2) ## [1] 10 20 30 10 50 10 40 sort(vecManip2) ## [1] 10 10 10 20 30 40 50 print(iris[, 1]) ## [1] 5.1 4.9 4.7 4.6 5.0 5.4 4.6 5.0 4.4 4.9 5.4 4.8 4.8 4.3 5.8 5.7 5.4 ## [18] 5.1 5.7 5.1 5.4 5.1 4.6 5.1 4.8 5.0 5.0 5.2 5.2 4.7 4.8 5.4 5.2 5.5 ## [35] 4.9 5.0 5.5 4.9 4.4 5.1 5.0 4.5 4.4 5.0 5.1 4.8 5.1 4.6 5.3 5.0 7.0 ## [52] 6.4 6.9 5.5 6.5 5.7 6.3 4.9 6.6 5.2 5.0 5.9 6.0 6.1 5.6 6.7 5.6 5.8 ## [69] 6.2 5.6 5.9 6.1 6.3 6.1 6.4 6.6 6.8 6.7 6.0 5.7 5.5 5.5 5.8 6.0 5.4 ## [86] 6.0 6.7 6.3 5.6 5.5 5.5 6.1 5.8 5.0 5.6 5.7 5.7 6.2 5.1 5.7 6.3 5.8 ## [103] 7.1 6.3 6.5 7.6 4.9 7.3 6.7 7.2 6.5 6.4 6.8 5.7 5.8 6.4 6.5 7.7 7.7 ## [120] 6.0 6.9 5.6 7.7 6.3 6.7 7.2 6.2 6.1 6.4 7.2 7.4 7.9 6.4 6.3 6.1 7.7 ## [137] 6.3 6.4 6.0 6.9 6.7 6.9 5.8 6.8 6.7 6.7 6.3 6.5 6.2 5.9 sort(iris[, 1]) ## [1] 4.3 4.4 4.4 4.4 4.5 4.6 4.6 4.6 4.6 4.7 4.7 4.8 4.8 4.8 4.8 4.8 4.9 ## [18] 4.9 4.9 4.9 4.9 4.9 5.0 5.0 5.0 5.0 5.0 5.0 5.0 5.0 5.0 5.0 5.1 5.1 ## [35] 5.1 5.1 5.1 5.1 5.1 5.1 5.1 5.2 5.2 5.2 5.2 5.3 5.4 5.4 5.4 5.4 5.4 ## [52] 5.4 5.5 5.5 5.5 5.5 5.5 5.5 5.5 5.6 5.6 5.6 5.6 5.6 5.6 5.7 5.7 5.7 ## [69] 5.7 5.7 5.7 5.7 5.7 5.8 5.8 5.8 5.8 5.8 5.8 5.8 5.9 5.9 5.9 6.0 6.0 ## [86] 6.0 6.0 6.0 6.0 6.1 6.1 6.1 6.1 6.1 6.1 6.2 6.2 6.2 6.2 6.3 6.3 6.3 ## [103] 6.3 6.3 6.3 6.3 6.3 6.3 6.4 6.4 6.4 6.4 6.4 6.4 6.4 6.5 6.5 6.5 6.5 ## [120] 6.5 6.6 6.6 6.7 6.7 6.7 6.7 6.7 6.7 6.7 6.7 6.8 6.8 6.8 6.9 6.9 6.9 ## [137] 6.9 7.0 7.1 7.2 7.2 7.2 7.3 7.4 7.6 7.7 7.7 7.7 7.7 7.9 9.2.3.4 append() Esta función se usa para agregar un elemento a un vector en una posición determinada por el argumento after. Esta función también es más rápida que su alternativa c(). print(vecManip2) ## [1] 10 20 30 10 50 10 40 append(vecManip2, 5) ## [1] 10 20 30 10 50 10 40 5 append(vecManip2, 5, after = 2) ## [1] 10 20 5 30 10 50 10 40 9.2.3.5 cbind() et rbind() Las funciones cbind() y rbind() permiten combinar elementos por columna o por línea. cbind(vecManip2, vecManip2) ## vecManip2 vecManip2 ## [1,] 10 10 ## [2,] 20 20 ## [3,] 30 30 ## [4,] 10 10 ## [5,] 50 50 ## [6,] 10 10 ## [7,] 40 40 rbind(vecManip2, vecManip2) ## [,1] [,2] [,3] [,4] [,5] [,6] [,7] ## vecManip2 10 20 30 10 50 10 40 ## vecManip2 10 20 30 10 50 10 40 9.2.3.6 paste() et paste0() Estas son dos funciones que usaremos mucho a partir de ahora. Las funciones paste() y paste0() se usan para concatenar cadenas de texto. La función paste0() es equivalente a paste() sin proponer un separador entre los elementos a concatenar. La función paste0() también es más rápida. paste(1, &quot;a&quot;) ## [1] &quot;1 a&quot; paste0(1, &quot;a&quot;) ## [1] &quot;1a&quot; paste(1, &quot;a&quot;, sep = &quot;_&quot;) ## [1] &quot;1_a&quot; paste0(&quot;prefix_&quot;, vecManip2, &quot;_suffix&quot;) ## [1] &quot;prefix_10_suffix&quot; &quot;prefix_20_suffix&quot; &quot;prefix_30_suffix&quot; ## [4] &quot;prefix_10_suffix&quot; &quot;prefix_50_suffix&quot; &quot;prefix_10_suffix&quot; ## [7] &quot;prefix_40_suffix&quot; paste(vecManip2, rank(vecManip2), sep = &quot;_&quot;) ## [1] &quot;10_2&quot; &quot;20_4&quot; &quot;30_5&quot; &quot;10_2&quot; &quot;50_7&quot; &quot;10_2&quot; &quot;40_6&quot; 9.2.3.7 rev() La función rev () devuelve los elementos de un objeto en orden inverso. print(vecManip2) ## [1] 10 20 30 10 50 10 40 rev(vecManip2) ## [1] 40 10 50 10 30 20 10 9.2.3.8 %in%() La función %in%() se puede comparar con un operador de comparación. Esta función toma dos objetos como argumentos y devuelve TRUE o FALSE para cada elemento del primer objeto de acuerdo con su presencia o ausencia en el segundo objeto. Para acceder a la documentación de la función, use help('%in%') (con comillas simples). print(vecManip) ## [1] 10 20 30 70 60 50 40 print(vecManip2) ## [1] 10 20 30 10 50 10 40 vecManip %in% vecManip2 ## [1] TRUE TRUE TRUE FALSE FALSE TRUE TRUE vecManip2 %in% vecManip ## [1] TRUE TRUE TRUE TRUE TRUE TRUE TRUE 9.2.4 Funciones matemáticas Ya hemos visto las funciones +, -, *, /, ^, %% y otros operadores aritméticos. R también tiene funciones matemáticas básicas como exponencial exp(), raíz cuadrada sqrt(), valor absoluto abs(), sinus sin(), coseno cos(), tangente tan(), logaritmo log(), logaritmo base 10 log10(), arco coseno acos(), arco sinus asin(), y arco tangente atan(). print(vecManip2) ## [1] 10 20 30 10 50 10 40 exp(vecManip2) ## [1] 2.202647e+04 4.851652e+08 1.068647e+13 2.202647e+04 5.184706e+21 ## [6] 2.202647e+04 2.353853e+17 sqrt(vecManip2) ## [1] 3.162278 4.472136 5.477226 3.162278 7.071068 3.162278 6.324555 abs(-vecManip2) ## [1] 10 20 30 10 50 10 40 sin(vecManip2) ## [1] -0.5440211 0.9129453 -0.9880316 -0.5440211 -0.2623749 -0.5440211 ## [7] 0.7451132 cos(vecManip2) ## [1] -0.8390715 0.4080821 0.1542514 -0.8390715 0.9649660 -0.8390715 ## [7] -0.6669381 tan(vecManip2) ## [1] 0.6483608 2.2371609 -6.4053312 0.6483608 -0.2719006 0.6483608 ## [7] -1.1172149 log(vecManip2) ## [1] 2.302585 2.995732 3.401197 2.302585 3.912023 2.302585 3.688879 log10(vecManip2) ## [1] 1.000000 1.301030 1.477121 1.000000 1.698970 1.000000 1.602060 acos(vecManip2/100) ## [1] 1.470629 1.369438 1.266104 1.470629 1.047198 1.470629 1.159279 asin(vecManip2/100) ## [1] 0.1001674 0.2013579 0.3046927 0.1001674 0.5235988 0.1001674 0.4115168 atan(vecManip2/100) ## [1] 0.09966865 0.19739556 0.29145679 0.09966865 0.46364761 0.09966865 ## [7] 0.38050638 9.2.5 Estadísticas descriptivas También podemos realizar estadísticas descriptivas de forma muy simple a partir de un conjunto de datos. 9.2.5.1 mean() La función mean() devuelve la media. Para ignorar los valores faltantes NA, hay que afectar el valor TRUE al argumento na.rm(). mean(iris[, 1]) ## [1] 5.843333 vecManip3 &lt;- c(1, 5, 6, 8, NA, 45, NA, 14) mean(vecManip3) ## [1] NA mean(vecManip3, na.rm = TRUE) ## [1] 13.16667 9.2.5.2 sd() La función sd() devuelve la desviación estándar. sd(iris[, 1]) ## [1] 0.8280661 print(vecManip3) ## [1] 1 5 6 8 NA 45 NA 14 sd(vecManip3) ## [1] NA sd(vecManip3, na.rm = TRUE) ## [1] 16.16684 9.2.5.3 max() y min() La función max() devuelve el valor máximo y min() el valor mínimo. max(iris[, 1]) ## [1] 7.9 print(vecManip3) ## [1] 1 5 6 8 NA 45 NA 14 max(vecManip3) ## [1] NA max(vecManip3, na.rm = TRUE) ## [1] 45 min(iris[, 1]) ## [1] 4.3 min(vecManip3) ## [1] NA min(vecManip3, na.rm = TRUE) ## [1] 1 9.2.5.4 quantile() La función quantile() devuelve el cuantil definido por el argumento probs. quantile(iris[, 1]) ## 0% 25% 50% 75% 100% ## 4.3 5.1 5.8 6.4 7.9 quantile(iris[, 1], probs = c(0, 0.25, 0.5, 0.75, 1)) ## 0% 25% 50% 75% 100% ## 4.3 5.1 5.8 6.4 7.9 quantile(iris[, 1], probs = c(0, 0.1, 0.5, 0.9, 1)) ## 0% 10% 50% 90% 100% ## 4.3 4.8 5.8 6.9 7.9 9.2.5.5 summary() La función summary() devuelve un resumen con el mínimo, primer cuartil, mediana, promedio, tercer cuartil y máximo. summary(iris[, 1]) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 4.300 5.100 5.800 5.843 6.400 7.900 9.2.5.6 median() La función median() devuelve la mediana. median(iris[, 1]) ## [1] 5.8 print(vecManip3) ## [1] 1 5 6 8 NA 45 NA 14 median(vecManip3) ## [1] NA median(vecManip3, na.rm = TRUE) ## [1] 7 9.2.5.7 length() La función length() devuelve el tamaño de un objeto (número de elementos). length(iris[, 1]) ## [1] 150 print(vecManip3) ## [1] 1 5 6 8 NA 45 NA 14 length(vecManip3) ## [1] 8 9.2.5.8 nrow() et ncol() La función nrow() devuelve el número de líneas y la función ncol() el número de columnas en un objeto. nrow(iris) ## [1] 150 ncol(iris) ## [1] 5 9.2.5.9 round(), ceiling(), floor(), et trunc() La función round() le permite seleccionar una cierta cantidad de decimales (0 por defecto) round(5.56874258564) ## [1] 6 round(5.56874258564, digits = 2) ## [1] 5.57 La función ceiling() devuelve el entero más pequeño que no es inferior al valor especificado. ceiling(5.9999) ## [1] 6 ceiling(5.0001) ## [1] 6 La función floor() devuelve el entero más grande que no excede el valor especificado. floor(5.9999) ## [1] 5 floor(5.0001) ## [1] 5 La función trunc() devuelve la parte entera del valor especificado. trunc(5.9999) ## [1] 5 trunc(5.0001) ## [1] 5 9.2.5.10 rowSums() et colSums() Las funciones rowSums() y colSums() calculan la suma de filas y columnas. rowSums(iris[, c(1, 2, 3, 4)]) ## [1] 10.2 9.5 9.4 9.4 10.2 11.4 9.7 10.1 8.9 9.6 10.8 10.0 9.3 8.5 ## [15] 11.2 12.0 11.0 10.3 11.5 10.7 10.7 10.7 9.4 10.6 10.3 9.8 10.4 10.4 ## [29] 10.2 9.7 9.7 10.7 10.9 11.3 9.7 9.6 10.5 10.0 8.9 10.2 10.1 8.4 ## [43] 9.1 10.7 11.2 9.5 10.7 9.4 10.7 9.9 16.3 15.6 16.4 13.1 15.4 14.3 ## [57] 15.9 11.6 15.4 13.2 11.5 14.6 13.2 15.1 13.4 15.6 14.6 13.6 14.4 13.1 ## [71] 15.7 14.2 15.2 14.8 14.9 15.4 15.8 16.4 14.9 12.8 12.8 12.6 13.6 15.4 ## [85] 14.4 15.5 16.0 14.3 14.0 13.3 13.7 15.1 13.6 11.6 13.8 14.1 14.1 14.7 ## [99] 11.7 13.9 18.1 15.5 18.1 16.6 17.5 19.3 13.6 18.3 16.8 19.4 16.8 16.3 ## [113] 17.4 15.2 16.1 17.2 16.8 20.4 19.5 14.7 18.1 15.3 19.2 15.7 17.8 18.2 ## [127] 15.6 15.8 16.9 17.6 18.2 20.1 17.0 15.7 15.7 19.1 17.7 16.8 15.6 17.5 ## [141] 17.8 17.4 15.5 18.2 18.2 17.2 15.7 16.7 17.3 15.8 colSums(iris[, c(1, 2, 3, 4)]) ## Sepal.Length Sepal.Width Petal.Length Petal.Width ## 876.5 458.6 563.7 179.9 9.2.5.11 rowMeans() et colMeans() Las funciones rowMeans() y colMeans() calculan el promedio de filas y columnas. rowMeans(iris[, c(1, 2, 3, 4)]) ## [1] 2.550 2.375 2.350 2.350 2.550 2.850 2.425 2.525 2.225 2.400 2.700 ## [12] 2.500 2.325 2.125 2.800 3.000 2.750 2.575 2.875 2.675 2.675 2.675 ## [23] 2.350 2.650 2.575 2.450 2.600 2.600 2.550 2.425 2.425 2.675 2.725 ## [34] 2.825 2.425 2.400 2.625 2.500 2.225 2.550 2.525 2.100 2.275 2.675 ## [45] 2.800 2.375 2.675 2.350 2.675 2.475 4.075 3.900 4.100 3.275 3.850 ## [56] 3.575 3.975 2.900 3.850 3.300 2.875 3.650 3.300 3.775 3.350 3.900 ## [67] 3.650 3.400 3.600 3.275 3.925 3.550 3.800 3.700 3.725 3.850 3.950 ## [78] 4.100 3.725 3.200 3.200 3.150 3.400 3.850 3.600 3.875 4.000 3.575 ## [89] 3.500 3.325 3.425 3.775 3.400 2.900 3.450 3.525 3.525 3.675 2.925 ## [100] 3.475 4.525 3.875 4.525 4.150 4.375 4.825 3.400 4.575 4.200 4.850 ## [111] 4.200 4.075 4.350 3.800 4.025 4.300 4.200 5.100 4.875 3.675 4.525 ## [122] 3.825 4.800 3.925 4.450 4.550 3.900 3.950 4.225 4.400 4.550 5.025 ## [133] 4.250 3.925 3.925 4.775 4.425 4.200 3.900 4.375 4.450 4.350 3.875 ## [144] 4.550 4.550 4.300 3.925 4.175 4.325 3.950 colMeans(iris[, c(1, 2, 3, 4)]) ## Sepal.Length Sepal.Width Petal.Length Petal.Width ## 5.843333 3.057333 3.758000 1.199333 9.2.5.12 aggregate() La función aggregate() permite agrupar los elementos de un objeto de acuerdo con un valor. El argumento by define el elemento sobre el que se realiza la agrupación. Debe ser del tipo list. aggregate(iris[, c(1, 2, 3, 4)], by = list(iris$Species), FUN = mean) ## Group.1 Sepal.Length Sepal.Width Petal.Length Petal.Width ## 1 setosa 5.006 3.428 1.462 0.246 ## 2 versicolor 5.936 2.770 4.260 1.326 ## 3 virginica 6.588 2.974 5.552 2.026 aggregate(iris[, c(1, 2)], by = list(iris$Species), FUN = summary) ## Group.1 Sepal.Length.Min. Sepal.Length.1st Qu. Sepal.Length.Median ## 1 setosa 4.300 4.800 5.000 ## 2 versicolor 4.900 5.600 5.900 ## 3 virginica 4.900 6.225 6.500 ## Sepal.Length.Mean Sepal.Length.3rd Qu. Sepal.Length.Max. ## 1 5.006 5.200 5.800 ## 2 5.936 6.300 7.000 ## 3 6.588 6.900 7.900 ## Sepal.Width.Min. Sepal.Width.1st Qu. Sepal.Width.Median Sepal.Width.Mean ## 1 2.300 3.200 3.400 3.428 ## 2 2.000 2.525 2.800 2.770 ## 3 2.200 2.800 3.000 2.974 ## Sepal.Width.3rd Qu. Sepal.Width.Max. ## 1 3.675 4.400 ## 2 3.000 3.400 ## 3 3.175 3.800 9.2.5.13 range() La función range() devuelve el mínimo y el máximo. range(iris[, 1]) ## [1] 4.3 7.9 print(vecManip3) ## [1] 1 5 6 8 NA 45 NA 14 range(vecManip3) ## [1] NA NA range(vecManip3, na.rm = TRUE) ## [1] 1 45 9.2.5.14 unique() La función unique() devuelve los valores únicos de un objeto (sin duplicados). unique(iris[, 1]) ## [1] 5.1 4.9 4.7 4.6 5.0 5.4 4.4 4.8 4.3 5.8 5.7 5.2 5.5 4.5 5.3 7.0 6.4 ## [18] 6.9 6.5 6.3 6.6 5.9 6.0 6.1 5.6 6.7 6.2 6.8 7.1 7.6 7.3 7.2 7.7 7.4 ## [35] 7.9 print(vecManip3) ## [1] 1 5 6 8 NA 45 NA 14 unique(vecManip3) ## [1] 1 5 6 8 NA 45 14 9.3 Otras funciones útiles No podemos abordar todas las funciones útiles, aquí solo abordaremos ciertas funciones. A lo largo de este libro, se usarán nuevas funciones. Cuando se utiliza una nueva función, nuestro reflejo siempre debe ser el mismo: consultar la documentación con la función help(). 9.3.1 seq_along() La función seq_along() se usa para crear un vector del tamaño del objeto rellenado y tomando como valores los números de 1 a N (N corresponde al número de elementos del objeto). Esta función nos servirá mucho en el capítulo sobre bucles. print(vecManip3) ## [1] 1 5 6 8 NA 45 NA 14 seq_along(vecManip3) ## [1] 1 2 3 4 5 6 7 8 9.3.2 : La función : permite crear una secuencia desde a hacia b por pasos de 1. Ha sido difícil escribir los capítulos anteriores sin usarlo ya que esta función es muy útil. Aquí estan algunos ejemplos. 5:10 ## [1] 5 6 7 8 9 10 head(iris[, c(1, 2, 3, 4)]) ## Sepal.Length Sepal.Width Petal.Length Petal.Width ## 1 5.1 3.5 1.4 0.2 ## 2 4.9 3.0 1.4 0.2 ## 3 4.7 3.2 1.3 0.2 ## 4 4.6 3.1 1.5 0.2 ## 5 5.0 3.6 1.4 0.2 ## 6 5.4 3.9 1.7 0.4 head(iris[, 1:4]) # ;-) ## Sepal.Length Sepal.Width Petal.Length Petal.Width ## 1 5.1 3.5 1.4 0.2 ## 2 4.9 3.0 1.4 0.2 ## 3 4.7 3.2 1.3 0.2 ## 4 4.6 3.1 1.5 0.2 ## 5 5.0 3.6 1.4 0.2 ## 6 5.4 3.9 1.7 0.4 miVec01 &lt;- c(1, 2, 3, 4) miVec01 &lt;- 1:4 # ;-) -10:12 ## [1] -10 -9 -8 -7 -6 -5 -4 -3 -2 -1 0 1 2 3 4 5 6 ## [18] 7 8 9 10 11 12 5:-5 ## [1] 5 4 3 2 1 0 -1 -2 -3 -4 -5 paste(&quot;X&quot;, 1:10, sep = &quot;_&quot;) ## [1] &quot;X_1&quot; &quot;X_2&quot; &quot;X_3&quot; &quot;X_4&quot; &quot;X_5&quot; &quot;X_6&quot; &quot;X_7&quot; &quot;X_8&quot; &quot;X_9&quot; &quot;X_10&quot; 9.3.3 rep() La función rep() permite repetir elementos. miVec12 &lt;- c(1, 1, 1, 1, 1, 1, 1, 1, 1) miVec12 &lt;- rep(1, times = 9) # ;-) rep(&quot;Hola&quot;, times = 3) ## [1] &quot;Hola&quot; &quot;Hola&quot; &quot;Hola&quot; rep(1:3, time = 3) ## [1] 1 2 3 1 2 3 1 2 3 rep(1:3, length.out = 10) ## [1] 1 2 3 1 2 3 1 2 3 1 rep(1:3, each = 3) ## [1] 1 1 1 2 2 2 3 3 3 9.3.4 seq() La función seq() permite crear una secuencia personalizada. seq(from = 0, to = 1, by = 0.2) ## [1] 0.0 0.2 0.4 0.6 0.8 1.0 seq(from = 20, to = 10, length.out = 10) ## [1] 20.00000 18.88889 17.77778 16.66667 15.55556 14.44444 13.33333 ## [8] 12.22222 11.11111 10.00000 letters[seq(from = 1, to = 26, by = 2)] ## [1] &quot;a&quot; &quot;c&quot; &quot;e&quot; &quot;g&quot; &quot;i&quot; &quot;k&quot; &quot;m&quot; &quot;o&quot; &quot;q&quot; &quot;s&quot; &quot;u&quot; &quot;w&quot; &quot;y&quot; rep(seq(from = 1, to = 2, by = 0.5), times = 3) ## [1] 1.0 1.5 2.0 1.0 1.5 2.0 1.0 1.5 2.0 9.3.5 getwd() La función getwd() establece la carpeta de trabajo. Esto corresponde a la ubicación relativa desde la cual R se posiciona para identificar los archivos. Este concepto tendrá sentido cuando veamos cómo importar y exportar datos. getwd() ## [1] &quot;C:/Users/nous/Documents/Francois/TRAVAIL/GitHub/myRbook_SP&quot; 9.3.6 setwd() La función setwd() se usa para definir un nuevo directorio de trabajo (carpeta de trabajo). oldWd &lt;- getwd() print(oldWd) ## [1] &quot;C:/Users/nous/Documents/Francois/TRAVAIL/GitHub/myRbook_SP&quot; setwd(&quot;..&quot;) getwd() ## [1] &quot;C:/Users/nous/Documents/Francois/TRAVAIL/GitHub&quot; setwd(oldWd) getwd() ## [1] &quot;C:/Users/nous/Documents/Francois/TRAVAIL/GitHub/myRbook_SP&quot; 9.3.7 list.files() La función list.files () se usa para listar todos los archivos en el directorio de trabajo. list.files(pattern = &quot;(html)$&quot;) # html ## [1] &quot;google_analytics_SP.html&quot; list.files(pattern = &quot;(pdf)$&quot;) # pdf ## character(0) 9.3.8 ls() Al igual que la función list.files() hace posible listar todos los archivos presentes en el directorio de trabajo, la función ls() permite listar todos los objetos presentes en el entorno de trabajo de R. ls() ## [1] &quot;aLogic&quot; &quot;bddInsect&quot; &quot;characters&quot; &quot;contrib&quot; ## [5] &quot;dfForMat&quot; &quot;factor01&quot; &quot;i&quot; &quot;irisCopy&quot; ## [9] &quot;j&quot; &quot;k&quot; &quot;logicals&quot; &quot;mdat&quot; ## [13] &quot;miArray&quot; &quot;miArray02&quot; &quot;miDf01&quot; &quot;miDfSub01&quot; ## [17] &quot;miDfSub02&quot; &quot;miDfSub03&quot; &quot;miDfSub04&quot; &quot;miList01&quot; ## [21] &quot;miList02&quot; &quot;miList0203&quot; &quot;miList03&quot; &quot;miList04&quot; ## [25] &quot;miList05&quot; &quot;miList06&quot; &quot;miMat&quot; &quot;miMat01&quot; ## [29] &quot;miMat02&quot; &quot;miVec01&quot; &quot;miVec02&quot; &quot;miVec03&quot; ## [33] &quot;miVec04&quot; &quot;miVec05&quot; &quot;miVec06&quot; &quot;miVec07&quot; ## [37] &quot;miVec08&quot; &quot;miVec09&quot; &quot;miVec10&quot; &quot;miVec11&quot; ## [41] &quot;miVec12&quot; &quot;miVec13&quot; &quot;miVec14&quot; &quot;miVec15&quot; ## [45] &quot;miVec20&quot; &quot;miVec21&quot; &quot;miVec22&quot; &quot;miVec23&quot; ## [49] &quot;miVec24&quot; &quot;miVec25&quot; &quot;miVecArr&quot; &quot;miVecArr02&quot; ## [53] &quot;miVecConf&quot; &quot;miVecNA&quot; &quot;miVecOp&quot; &quot;msg&quot; ## [57] &quot;myCol&quot; &quot;myRow&quot; &quot;myText&quot; &quot;myText2&quot; ## [61] &quot;myText3&quot; &quot;myText4&quot; &quot;myText5&quot; &quot;nbrRep&quot; ## [65] &quot;newVec&quot; &quot;newVec2&quot; &quot;numbers&quot; &quot;oldWd&quot; ## [69] &quot;opAriDf&quot; &quot;sumIntDou&quot; &quot;sumIntInt&quot; &quot;termino01&quot; ## [73] &quot;termino02&quot; &quot;vecForMat01&quot; &quot;vecForMat02&quot; &quot;vecForMat03&quot; ## [77] &quot;vecForMatrix&quot; &quot;vecManip&quot; &quot;vecManip2&quot; &quot;vecManip3&quot; zzz &lt;- &quot;a new object&quot; ls() ## [1] &quot;aLogic&quot; &quot;bddInsect&quot; &quot;characters&quot; &quot;contrib&quot; ## [5] &quot;dfForMat&quot; &quot;factor01&quot; &quot;i&quot; &quot;irisCopy&quot; ## [9] &quot;j&quot; &quot;k&quot; &quot;logicals&quot; &quot;mdat&quot; ## [13] &quot;miArray&quot; &quot;miArray02&quot; &quot;miDf01&quot; &quot;miDfSub01&quot; ## [17] &quot;miDfSub02&quot; &quot;miDfSub03&quot; &quot;miDfSub04&quot; &quot;miList01&quot; ## [21] &quot;miList02&quot; &quot;miList0203&quot; &quot;miList03&quot; &quot;miList04&quot; ## [25] &quot;miList05&quot; &quot;miList06&quot; &quot;miMat&quot; &quot;miMat01&quot; ## [29] &quot;miMat02&quot; &quot;miVec01&quot; &quot;miVec02&quot; &quot;miVec03&quot; ## [33] &quot;miVec04&quot; &quot;miVec05&quot; &quot;miVec06&quot; &quot;miVec07&quot; ## [37] &quot;miVec08&quot; &quot;miVec09&quot; &quot;miVec10&quot; &quot;miVec11&quot; ## [41] &quot;miVec12&quot; &quot;miVec13&quot; &quot;miVec14&quot; &quot;miVec15&quot; ## [45] &quot;miVec20&quot; &quot;miVec21&quot; &quot;miVec22&quot; &quot;miVec23&quot; ## [49] &quot;miVec24&quot; &quot;miVec25&quot; &quot;miVecArr&quot; &quot;miVecArr02&quot; ## [53] &quot;miVecConf&quot; &quot;miVecNA&quot; &quot;miVecOp&quot; &quot;msg&quot; ## [57] &quot;myCol&quot; &quot;myRow&quot; &quot;myText&quot; &quot;myText2&quot; ## [61] &quot;myText3&quot; &quot;myText4&quot; &quot;myText5&quot; &quot;nbrRep&quot; ## [65] &quot;newVec&quot; &quot;newVec2&quot; &quot;numbers&quot; &quot;oldWd&quot; ## [69] &quot;opAriDf&quot; &quot;sumIntDou&quot; &quot;sumIntInt&quot; &quot;termino01&quot; ## [73] &quot;termino02&quot; &quot;vecForMat01&quot; &quot;vecForMat02&quot; &quot;vecForMat03&quot; ## [77] &quot;vecForMatrix&quot; &quot;vecManip&quot; &quot;vecManip2&quot; &quot;vecManip3&quot; ## [81] &quot;zzz&quot; 9.3.9 rm() La función rm() permite eliminar un objeto presente en el entorno de trabajo de R. rm(zzz) ls() ## [1] &quot;aLogic&quot; &quot;bddInsect&quot; &quot;characters&quot; &quot;contrib&quot; ## [5] &quot;dfForMat&quot; &quot;factor01&quot; &quot;i&quot; &quot;irisCopy&quot; ## [9] &quot;j&quot; &quot;k&quot; &quot;logicals&quot; &quot;mdat&quot; ## [13] &quot;miArray&quot; &quot;miArray02&quot; &quot;miDf01&quot; &quot;miDfSub01&quot; ## [17] &quot;miDfSub02&quot; &quot;miDfSub03&quot; &quot;miDfSub04&quot; &quot;miList01&quot; ## [21] &quot;miList02&quot; &quot;miList0203&quot; &quot;miList03&quot; &quot;miList04&quot; ## [25] &quot;miList05&quot; &quot;miList06&quot; &quot;miMat&quot; &quot;miMat01&quot; ## [29] &quot;miMat02&quot; &quot;miVec01&quot; &quot;miVec02&quot; &quot;miVec03&quot; ## [33] &quot;miVec04&quot; &quot;miVec05&quot; &quot;miVec06&quot; &quot;miVec07&quot; ## [37] &quot;miVec08&quot; &quot;miVec09&quot; &quot;miVec10&quot; &quot;miVec11&quot; ## [41] &quot;miVec12&quot; &quot;miVec13&quot; &quot;miVec14&quot; &quot;miVec15&quot; ## [45] &quot;miVec20&quot; &quot;miVec21&quot; &quot;miVec22&quot; &quot;miVec23&quot; ## [49] &quot;miVec24&quot; &quot;miVec25&quot; &quot;miVecArr&quot; &quot;miVecArr02&quot; ## [53] &quot;miVecConf&quot; &quot;miVecNA&quot; &quot;miVecOp&quot; &quot;msg&quot; ## [57] &quot;myCol&quot; &quot;myRow&quot; &quot;myText&quot; &quot;myText2&quot; ## [61] &quot;myText3&quot; &quot;myText4&quot; &quot;myText5&quot; &quot;nbrRep&quot; ## [65] &quot;newVec&quot; &quot;newVec2&quot; &quot;numbers&quot; &quot;oldWd&quot; ## [69] &quot;opAriDf&quot; &quot;sumIntDou&quot; &quot;sumIntInt&quot; &quot;termino01&quot; ## [73] &quot;termino02&quot; &quot;vecForMat01&quot; &quot;vecForMat02&quot; &quot;vecForMat03&quot; ## [77] &quot;vecForMatrix&quot; &quot;vecManip&quot; &quot;vecManip2&quot; &quot;vecManip3&quot; 9.4 Algunos ejercicios para practicar Aquí hay algunos ejercicios para mejorar el uso de las funciones y aprender nuevas gracias a la documentación. Algunos ejercicios son difíciles, podremos volver a resolverlos más tarde. 9.4.1 Secuencias 9.4.1.1 Vamos a reproducir las siguientes secuencias: -3 -4 -5 -6 -7 -8 -9 -10 –11 -3 -1 1 3 5 7 9 11 3.0 3.2 3.4 3.6 3.8 4.0 20 18 16 14 12 10 8 6 “a” “f” “k” “p” “u” “z” “a” “a” “a” “a” “a” “f” “f” “f” “f” “f” “k” “k” “k” “k” “k” “p” “p” “p” “p” “p” “u” “u” “u” “u” “u” “z” “z” “z” “z” “z” 9.4.1.2 Posibles soluciones (porque siempre hay varias soluciones): -3:-11 ## [1] -3 -4 -5 -6 -7 -8 -9 -10 -11 seq(from = -3, to = 11, by = 2) ## [1] -3 -1 1 3 5 7 9 11 seq(from = 3.0, to = 4.0, by = 0.2) ## [1] 3.0 3.2 3.4 3.6 3.8 4.0 letters[seq(from = 1, to = 26, by = 5)] ## [1] &quot;a&quot; &quot;f&quot; &quot;k&quot; &quot;p&quot; &quot;u&quot; &quot;z&quot; letters[rep(seq(from = 1, to = 26, by = 5), each = 5)] ## [1] &quot;a&quot; &quot;a&quot; &quot;a&quot; &quot;a&quot; &quot;a&quot; &quot;f&quot; &quot;f&quot; &quot;f&quot; &quot;f&quot; &quot;f&quot; &quot;k&quot; &quot;k&quot; &quot;k&quot; &quot;k&quot; &quot;k&quot; &quot;p&quot; &quot;p&quot; ## [18] &quot;p&quot; &quot;p&quot; &quot;p&quot; &quot;u&quot; &quot;u&quot; &quot;u&quot; &quot;u&quot; &quot;u&quot; &quot;z&quot; &quot;z&quot; &quot;z&quot; &quot;z&quot; &quot;z&quot; 9.4.2 Estadísticas descriptivas En el conjunto de datos iris, ¿cuántos valores de ancho del sépalo son mayores que 3? Entre 2.8 y 3.2? ¿Cómo se puede visualizar la distribución de datos (función table())? ¿Cuáles son los 10 valores más pequeños? ¿Cómo se calcula el intervalo que contiene el 90% de los valores? Si la distribución de los datos era Normal, ¿cuál sería el valor teórico de este intervalo del 90% (función qnorm())? Soluciones: length(iris$Sepal.Width[iris$Sepal.Width &gt; 3]) ## [1] 67 length(iris$Sepal.Width[iris$Sepal.Width &gt; 2.8 &amp; iris$Sepal.Width &lt; 3.2]) ## [1] 47 table(iris$Sepal.Width) ## ## 2 2.2 2.3 2.4 2.5 2.6 2.7 2.8 2.9 3 3.1 3.2 3.3 3.4 3.5 3.6 3.7 3.8 ## 1 3 4 3 8 5 9 14 10 26 11 13 6 12 6 4 3 6 ## 3.9 4 4.1 4.2 4.4 ## 2 1 1 1 1 table(round(iris$Sepal.Width)) ## ## 2 3 4 ## 19 106 25 irisSepWCopy &lt;- iris$Sepal.Width irisSepWCopy &lt;- irisSepWCopy[order(irisSepWCopy)] head(irisSepWCopy, n = 10) ## [1] 2.0 2.2 2.2 2.2 2.3 2.3 2.3 2.3 2.4 2.4 quantile(irisSepWCopy, probs = c(0.05, 0.95)) ## 5% 95% ## 2.345 3.800 qnorm( p = c(0.05, 0.95), mean = mean(irisSepWCopy), sd = sd(irisSepWCopy) ) ## [1] 2.340397 3.774270 9.5 Escribir una función Cuando reproducimos las mismas operaciones varias veces, el código se vuelve difícil de escribir y de mantener porque si tenemos que hacer una modificación, tendremos que repetirla cada vez que la usemos. Esto es un signo de la necesidad de usar una función. En el siguiente ejemplo, sera largo modificar el código si queremos agregar +45 en lugar de +20 para cada línea. 35 + 20 ## [1] 55 758 + 20 ## [1] 778 862 + 20 ## [1] 882 782 + 20 ## [1] 802 Como todas las funciones básicas de R, nuestras funciones tendrán un nombre y argumentos. Al igual que con los nombres de los objetos y los nombres de los archivos, es importante elegir bien el nombre de nuestra función (ver la sección sobre objetos). Para crear una función utilizaremos la función function() que toma como argumento los argumentos de nuestra función. La función devolverá el resultado deseado. Por defecto, el resultado devuelto es el último utilizado, pero es mejor usar la función return(). La siguiente función addX() toma como argumento x y devuelve x + 20. addX &lt;- function(x){ return(x + 20) } Nuestro código se convierte en: addX(35) ## [1] 55 addX(758) ## [1] 778 addX(862) ## [1] 882 addX(782) ## [1] 802 Si queremos cambiar el código para agregar 45 en lugar de 20, simplemente cambiamos la función addX(). addX &lt;- function(x){ return(x + 45) } addX(35) ## [1] 80 addX(758) ## [1] 803 addX(862) ## [1] 907 addX(782) ## [1] 827 Aquí podríamos haber usado el formato vector para evitar la repetición, pero eso no siempre es posible. c(35, 758, 862, 782) + 20 ## [1] 55 778 882 802 Vamos a esribir una nueva función que contará el número de consonantes y vocales en minúsculas en una palabra. Primero separaremos todas las letras de la palabra con la función strsplit (podemos consultar la ayuda para saber más acerca de esta función). Luego contaremos las vocales y las consonantes con la función length(). Para la lista de letras, usaremos el objeto letters incluido en R que contiene las 26 letras en minuscula (consulte la ayuda con ?letters). print(letters) # las 26 letras ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; &quot;i&quot; &quot;j&quot; &quot;k&quot; &quot;l&quot; &quot;m&quot; &quot;n&quot; &quot;o&quot; &quot;p&quot; &quot;q&quot; ## [18] &quot;r&quot; &quot;s&quot; &quot;t&quot; &quot;u&quot; &quot;v&quot; &quot;w&quot; &quot;x&quot; &quot;y&quot; &quot;z&quot; countVowelConso &lt;- function(word){ # nombre: countVowelConso ; argumento: word wordSplit &lt;- strsplit(word, split = &quot;&quot;)[[1]] # separar letras de word vowels &lt;- c(&quot;a&quot;, &quot;e&quot;, &quot;i&quot;, &quot;o&quot;, &quot;u&quot;, &quot;y&quot;) # las vocales numVowel &lt;- length(wordSplit[wordSplit %in% vowels]) # numero de vocales consonants &lt;- letters[!letters %in% vowels] # las consonantes numConso &lt;- length(wordSplit[wordSplit %in% consonants]) # numero de consonantes return(c(numVowel, numConso)) # el resultado de la funcion } Ahora podemos usar nuestra función. countVowelConso(word = &quot;qwertyuiop azertyuiop&quot;) ## [1] 11 9 Esta función se puede modificar mostrando un mensaje más explícito. Aunque en general se debe evitar este tipo de mensaje para evitar sobrecargar las funciones, puede ser útil verificar que todo esté funcionando correctamente (luego lo borraremos). countVowelConso &lt;- function(word){ wordSplit &lt;- strsplit(word, split = &quot;&quot;)[[1]] vowels &lt;- c(&quot;a&quot;, &quot;e&quot;, &quot;i&quot;, &quot;o&quot;, &quot;u&quot;, &quot;y&quot;) numVowel &lt;- length(wordSplit[wordSplit %in% vowels]) consonants &lt;- letters[!letters %in% vowels] numConso &lt;- length(wordSplit[wordSplit %in% consonants]) print(paste0(&quot;Hay &quot;, numVowel, &quot; vocales y &quot;, numConso, &quot; consonantes en la palabra &#39;&quot;, word, &quot;&#39;.&quot;)) return(c(numVowel, numConso)) } countVowelConso(word = &quot;qwertyuiop azertyuiop&quot;) ## [1] &quot;Hay 11 vocales y 9 consonantes en la palabra &#39;qwertyuiop azertyuiop&#39;.&quot; ## [1] 11 9 Por otro lado, si usamos countVowelConso(word = 5), se devolverá un error porque nuestra función espera un objeto de tipo character. En general, se recomienda manejar los errores devueltos por nuestras funciones para que nuestro código sea más fácil de mantener. Aquí simplemente comprobaremos que el argumento sea de tipo character, en un vector de tamaño 1. También comentaremos nuestra función para encontrar rápidamente lo que hace (comentario insertado en la primera línea, que a veces encontramos en la última línea de las funciones). countVowelConso &lt;- function(word){ # número de vocales y consonantes if(is.vector(word) &amp; is.character(word) &amp; length(word) == 1){ wordSplit &lt;- strsplit(word, split = &quot;&quot;)[[1]] vowels &lt;- c(&quot;a&quot;, &quot;e&quot;, &quot;i&quot;, &quot;o&quot;, &quot;u&quot;, &quot;y&quot;) numVowel &lt;- length(wordSplit[wordSplit %in% vowels]) consonants &lt;- letters[!letters %in% vowels] numConso &lt;- length(wordSplit[wordSplit %in% consonants]) return(c(numVowel, numConso)) } else { print(paste0(&quot;Error: &quot;, &quot;argumento &#39;word&#39; incorrecto (&quot;, word, &quot;)&quot;)) } } countVowelConso(word = &quot;qwertyuiop azertyuiop&quot;) ## [1] 11 9 countVowelConso(word = 5) ## [1] &quot;Error: argumento &#39;word&#39; incorrecto (5)&quot; Con R como para cualquier lenguaje de programación, para un problema siempre hay múltiples soluciones. Recordamos la sección sobre tipos de datos (tipo de datos logical), así como la sección sobre operadores de comparación que el valor de TRUE es 1 y el valor de FALSE es 0. Hemos visto anteriormente que la función % in% devuelve TRUE o FALSE para cada elemento del primer objeto dependiendo de su presencia o ausencia en el segundo objeto. Nuestra función podría haber usado otra función en lugar de length() para contar vocales y consonantes (función sum()). countVowelConsoAlt &lt;- function(word){ # número de vocales y consonantes if(is.vector(word) &amp; is.character(word) &amp; length(word) == 1){ wordSplit &lt;- strsplit(word, split = &quot;&quot;)[[1]] vowels &lt;- c(&quot;a&quot;, &quot;e&quot;, &quot;i&quot;, &quot;o&quot;, &quot;u&quot;, &quot;y&quot;) numVowel &lt;- sum(wordSplit %in% vowels) # &lt;- cambio aqui consonants &lt;- letters[!letters %in% vowels] numConso &lt;- sum(wordSplit %in% consonants) # &lt;- cambio aqui return(c(numVowel, numConso)) } else { print(paste0(&quot;Error: &quot;, &quot;argumento &#39;word&#39; incorrecto (&quot;, word, &quot;)&quot;)) } } countVowelConsoAlt(word = &quot;qwertyuiop azertyuiop&quot;) ## [1] 11 9 No existe una solución óptima en absoluto, todo depende de los objetivos deseados. La primera solución puede ser más fácil de entender, y la segunda puede ser más rápida en términos de velocidad de ejecución (repitiendo el uso de la función 10000 veces, el ahorro de tiempo es casi cero en nuestro caso). system.time(replicate(n = 10000, countVowelConso(word = &quot;qwertyuiop azertyuiop&quot;))) ## user system elapsed ## 0.14 0.02 0.16 system.time(replicate(n = 10000, countVowelConsoAlt(word = &quot;qwertyuiop azertyuiop&quot;))) ## user system elapsed ## 0.15 0.00 0.15 Una función puede tener valores predeterminados para sus argumentos. Este es el caso para la mayoría de las funciones existentes. Por defecto, nuestra función ahora contará el número de vocales y consonantes en la palabra qwerty (los paréntesis son necesarios incluso en ausencia de argumentos). countVowelConsoAlt &lt;- function(word = &quot;qwerty&quot;){ # número de vocales y consonantes if(is.vector(word) &amp; is.character(word) &amp; length(word) == 1){ wordSplit &lt;- strsplit(word, split = &quot;&quot;)[[1]] vowels &lt;- c(&quot;a&quot;, &quot;e&quot;, &quot;i&quot;, &quot;o&quot;, &quot;u&quot;, &quot;y&quot;) numVowel &lt;- sum(wordSplit %in% vowels) consonants &lt;- letters[!letters %in% vowels] numConso &lt;- sum(wordSplit %in% consonants) return(c(numVowel, numConso)) } else { print(paste0(&quot;Error: &quot;, &quot;argumento &#39;word&#39; incorrecto (&quot;, word, &quot;)&quot;)) } } countVowelConsoAlt() # no hay que olvidar los paréntesis ## [1] 2 4 R tiene muchas funciones, por lo tanto, antes de comenzar a escribir una nueva función, siempre debemos verificar que ya no exista en la versión básica de R o en los packages desarrollado por la comunidad de usuarios. Para esto podemos usar la ayuda con la función ??miBusqueda, pero también nuestro navegador de Internet. 9.6 Otras funciones desarrolladas por la comunidad de usuarios: los packages Un package (o paquete) es un conjunto de archivos que agregaremos a R para usar funciones (o conjuntos de datos) que otras personas hayan desarrollado. Actualmente hay más de 10,000 paquetes en los servidores CRAN de R (CRAN; https://cran.r-project.org/web/packages/), más de 1000 en los servidores de BioConductor (para análisis genómicos) y varios cientos en GitHub. Cada paquete hace posible usar nuevas funciones para casi todo … Por lo tanto, puede ser difícil encontrar el paquete adecuado para lo que queremos lograr, y es importante dedicar tiempo a la busqueda del paquete adecuado y probar varios soluciones. Para usar un paquete, primero debemos instalarlo, y luego cargarlo en nuestra sesión R. 9.6.1 Instalar un paquete Una vez que hemos seleccionado nuestro paquete, podemos descargarlo e instalarlo con la función install.packages(), que toma el nombre del paquete entre comillas como argumento (la función tolera la ausencia de comillas, pero es mejor usarlas para que el código sea más legible). Algunos paquetes ya son instalados por defecto con R, como stats (que también se carga de forma predeterminada). install.packages(&quot;stats&quot;) # R statistical functions La instalación de un paquete debe hacerse una vez, luego el paquete está en nuestra computadora. 9.6.2 Cargar un paquete Para poder usar las funciones de un paquete, tenemos que cargarlo en nuestra sesión R. Hay tantos paquetes disponibles que R no cargará todos los que tenemos instalados por defecto, sino solo los que necesitaremos para nuestro estudio actual. Para cargar un paquete usamos la función library() o require(). library(&quot;stats&quot;) La carga del paquete debe hacerse cada vez que queremos ejecutar nuestro código, por lo tanto, es una parte integral de nuestro script. 9.6.3 Portabilidad del código Acabamos de ver que la instalación de un paquete solo se debe hacer una vez por computadora, y que la carga de un paquete se debe lograr para cada nueva sesión de R. Si uno cambia de computadora o si compartimos un script con colegas, puede haber errores de ejecución relacionados con la falta de instalación de un paquete. Para superar este problema, se recomienda utilizar una función que verifique si los paquetes necesarios para ejecutar un script están instalados; si es necesario, instálelos y luego cárguelos. Hay muchas funciones para hacer esto en Internet. La solución que proponemos aquí es una mezcla adaptada de diferentes fuentes. No es necesario comprender los detalles de este script por el momento, sino simplemente comprender lo que hace. Este es un ejemplo para el paquete stats y graphics, dos paquetes que ya estan presente con la versión básica de R, pero podemos tratar todos los paquetes disponibles en CRAN; la lista se puede encontrar aquí: https://cran.r-project.org/web/packages/available_packages_by_name.html. pkgCheck &lt;- function(packages){ for(x in packages){ try(if(!require(x, character.only = TRUE)){ install.packages(x, dependencies = TRUE) if(!require(x, character.only = TRUE)){ stop() } }) } } pkgCheck(c(&quot;stats&quot;, &quot;graphics&quot;)) Alternativamente, podemos usar la función .packages() para listar los paquetes disponibles en el CRAN en orden alfabético. head(.packages(all.available = TRUE), n = 30) ## [1] &quot;abind&quot; &quot;acepack&quot; &quot;ade4&quot; &quot;agricolae&quot; &quot;AlgDesign&quot; ## [6] &quot;ape&quot; &quot;assertthat&quot; &quot;backports&quot; &quot;base64enc&quot; &quot;BH&quot; ## [11] &quot;bindr&quot; &quot;bindrcpp&quot; &quot;BioFTF&quot; &quot;bitops&quot; &quot;bookdown&quot; ## [16] &quot;brew&quot; &quot;broom&quot; &quot;ca&quot; &quot;callr&quot; &quot;caret&quot; ## [21] &quot;cartography&quot; &quot;caTools&quot; &quot;checkmate&quot; &quot;CircStats&quot; &quot;classInt&quot; ## [26] &quot;cli&quot; &quot;clipr&quot; &quot;clisymbols&quot; &quot;coda&quot; &quot;colorRamps&quot; La función pkgCheck() asegura la portabilidad de nuestros scripts: funcionarán en todas las computadoras sin tener que realizar ningún cambio. Por lo tanto, nuestros scipts pueden adjuntarse, por ejemplo, a nuestros artículos científicos y así garantizar la reproducibilidad de nuestros resultados. 9.7 Conclusión Felicitaciones! Ahora sabemos reconocer y usar una función, sabemos cómo buscar ayuda para una función e incluso sabemos escribir nuestras propias funciones. También sabemos que hay muchas funciones desarrolladas por la comunidad de usuarios de R dentro de paquetes (packages) que sabemos cómo instalar y cargar, y asegurar la portabilidad de nuestros scripts de una computadora a otra (importante para la reproducibilidad de los resultados). El próximo capítulo se enfocará en leer y escribir archivos porque nuestros datos suelen estar en archivos de texto u hojas de cálculo. "],
["import.html", " 10 Importar y exportar datos 10.1 Leer datos de un archivo 10.2 Guardar datos para R 10.3 Exportar datos 10.4 Conclusión", " 10 Importar y exportar datos 10.1 Leer datos de un archivo 10.1.1 Transformar datos en formato TXT o CSV Hay muchas maneras de leer el contenido de un archivo con R. Sin embargo, nos enfocaremos en leer los archivos TXT y CSV que son los más comunes y los más confiables. Con raras excepciones, todos los archivos de datos se pueden transformar fácilmente en formatos TXT y CSV. Esta es la práctica preferida para el análisis de datos con R. En concreto, desde Microsoft Excel, simplemente vamos a Archivo, luego Guardar como, seleccionamos el lugar donde queremos guardar nuestro archivo (hablaremos en el siguiente capítulo sobre la gestión de un proyecto R) y luego en el la ventana de copia de seguridad cambiamos el Tipo desde XLSX hacia CSV. Desde LibreOffice Calc, simplemente vamos a Archivo, luego Guardar como, luego seleccionamos el tipo CSV. Es importante saber que el archivo CSV no admite el formato de archivos de hoja de cálculo con, por ejemplo, colores, y que el archivo CSV contiene solo una pestaña. Si tenemos un archivo de hoja de cálculo con varias pestañas, tendremos que guardar tantos archivos CSV como pestañas. CSV viene del Inglés Comma-separated values (https://es.wikipedia.org/wiki/Valores_separados_por_comas) y representa los datos de hoja de cálculo en un formato de texto separado por comas (o punto y coma según el país). Siempre se puede abrir un archivo CSV con software de hoja de cálculo, pero también con un editor de texto simple como el bloc de notas de Windows o con Notepad++. Es preferible abrir archivos CSV con un editor de texto porque las hojas de cálculo tienden a querer cambiar automáticamente los archivos CSV y esto tiene el efecto de dificultar su lectura. Una vez que se obtiene el archivo TXT o CSV, la lectura del contenido desde R es fácil, aun que requiere un poco de rigor. 10.1.2 Leer un archivo CSV Esta es la fuente de error más común para los principiantes en R. Es por eso que es importante leer y volver a leer este capítulo y lo siguiente sobre la gestión de un proyecto R con mucha atención. R funciona en un directorio definido por defecto. Los usuarios de Rstudio u otro entorno de desarrollo especializado para R intentarán usar las opciones disponibles a través de los menús para establecer su directorio de trabajo o cargar el contenido de un archivo. En este libro, estas técnicas nunca se usarán porque no permiten la reproducibilidad de los resultados. Un script debe poder funcionar para todos los sistemas operativos y sin tener en cuenta el entorno de desarrollo del usuario. El directorio de trabajo por defecto se puede obtener con la función getwd() y cambiar con la función setwd(). oldWd &lt;- getwd() print(oldWd) ## [1] &quot;C:/Users/nous/Documents/Francois/TRAVAIL/GitHub/myRbook_SP&quot; setwd(&quot;..&quot;) getwd() ## [1] &quot;C:/Users/nous/Documents/Francois/TRAVAIL/GitHub&quot; setwd(oldWd) getwd() ## [1] &quot;C:/Users/nous/Documents/Francois/TRAVAIL/GitHub/myRbook_SP&quot; Entonces tenemos cuatro opciones: podemos leer el contenido de un archivo indicando a R su ruta completa (limitacion para la reproducibilidad de los resultados) podemos leer el contenido de un archivo indicando a R su ruta relativa podemos mover el archivo en el directorio de trabajo de R podemos modificar el directorio de trabajo de R para que coincida con la ubicación de nuestro archivo (con su ruta relativa) Un ejemplo de una ruta completa sería: /home/myName/myFile.csv en un entorno UNIX C:/users/myName/myFile.csv bajo un entorno de Windows (tenga cuidado, bajo R utilizamos / y no \\ como es el caso por defecto en Windows) Un camino relativo sería: myName/myFiles.csv Para navegar por las rutas relativas, podemos usar .. que permite volver al directorio de origen. Por ejemplo, si el directorio de trabajo es myScripts y el árbol de mis archivos es: ## -myProject ## |-myFiles ## |-|-data01.csv ## |-|-data02.csv ## |-myScripts ## |-|-myFirstScript.R La ruta relativa al archivo data01.csv sería ../myFiles/data01.csv Entonces, para leer el contenido del archivo data01.csv, privilegiaremos la opción 2 (leer el contenido de un archivo que indicando su ruta relativa) o la opción 4 (modificar el directorio de trabajo de R para que coincida con la ubicación de nuestro archivo). En el último caso: myWD &lt;- &quot;../myFiles/&quot; setwd(myWd) getwd() # para verificar que estamos en el directorio correcto list.files() # para verificar que el archivo está aquí El error más común: ## Error in setwd(&quot;../myFiles/&quot;) : ## no se puede cambiar el directorio de trabajo Esto significa que el directorio no existe (se debe verificar que la sintaxis sea correcta y que el directorio exista con esta ruta). Una vez que el directorio de trabajo está definido correctamente o la ruta relativa al archivo está establecida correctamente, podemos leer el archivo con la función read.table(). Algunos usan la función read.csv() pero este es solo un caso especial de read.table(). myWD &lt;- &quot;../myFiles/&quot; setwd(myWd) read.table(file = &quot;data01.csv&quot;) o alternativamente: read.table(file = &quot;../myFiles/data01.csv&quot;) Si la ruta no se llena correctamente o si el archivo de datos no existe, R devolverá el siguiente error: ## Error in file(file, &quot;rt&quot;) : incapaz de abrir la conexión ## De más : Warning message: ## In file(file, &quot;rt&quot;) : ## incapaz de abrir el archivo &#39;../myFiles/data01.csv&#39; : No such file or directory Si todo está bien, R muestra el contenido del archivo data01.csv. Advertencia a los usuarios de Windows porque por defecto no aparece la extensión de los archivos… Así que cuando navegamos a través de directorios con el explorador de archivos, no hay data01.csv, pero sólo un archivo data01. Es esencial remediar este problema para evitar errores. Para hacer esto, simplemente abrimos las ‘Opciones del Explorador de archivos’ a través de la tecla ‘Windows’, luego en la pestaña ‘Ver’, verificamos que la opción ‘Ocultar extensiones de archivos cuyo tipo es conocido’ no está marcado. Consultando la ayuda sobre la función read.table(), podemos ver que tiene muchos argumentos. Los principales son: header = FALSE: ¿el archivo contiene nombres de columna? Si es así, cambiamos el valor a header = TRUE sep =&quot; &quot;: ¿cómo se separan los datos de la tabla? En un archivo CSV es la coma o el punto y coma, así que cambiamos a sep = &quot;,&quot; o sep = &quot;;&quot; dec =&quot;. &quot;: ¿cuál es el separador de los números decimales? Si es la coma, entonces debes cambiar a dec = &quot;,&quot; Con estos tres argumentos, la mayoría de los archivos se pueden leer sin ningún problema. En caso de necesidad, la ayuda de esta función es muy completa. La función read.table () devuelve el contenido del archivo como data.frame. Para poder usar el contenido del archivo, almacenaremos el data.frame en un objeto. myWD &lt;- &quot;../myFiles/&quot; setwd(myWd) data01 &lt;- read.table(file = &quot;data01.csv&quot;) str(data01) # verificar el formato de los datos head(data01) # vverificar los primeros datos El estudio de caso sobre el análisis de datos de datalogger se basa en un archivo CSV. Aquí hay un extracto: bdd &lt;- read.table(&quot;myFiles/E05C13.csv&quot;, skip = 1, header = TRUE, sep = &quot;,&quot;, dec = &quot;.&quot;, stringsAsFactors = FALSE) colnames(bdd) &lt;- c(&quot;id&quot;, &quot;date&quot;, &quot;temp&quot;) head(bdd) ## id date temp ## 1 1 11/12/15 23:00:00 4.973 ## 2 2 11/12/15 23:30:00 4.766 ## 3 3 11/13/15 00:00:00 4.844 ## 4 4 11/13/15 00:30:00 4.844 ## 5 5 11/13/15 01:00:00 5.076 ## 6 6 11/13/15 01:30:00 5.282 tail(bdd) ## id date temp ## 32781 32781 09/25/17 21:00:00 7.091 ## 32782 32782 09/25/17 21:30:00 6.914 ## 32783 32783 09/25/17 22:00:00 6.813 ## 32784 32784 09/25/17 22:30:00 6.611 ## 32785 32785 09/25/17 23:00:00 6.331 ## 32786 32786 09/25/17 23:30:00 5.385 str(bdd) ## &#39;data.frame&#39;: 32786 obs. of 3 variables: ## $ id : int 1 2 3 4 5 6 7 8 9 10 ... ## $ date: chr &quot;11/12/15 23:00:00&quot; &quot;11/12/15 23:30:00&quot; &quot;11/13/15 00:00:00&quot; &quot;11/13/15 00:30:00&quot; ... ## $ temp: num 4.97 4.77 4.84 4.84 5.08 ... 10.1.3 Leer un archivo de texto La función más simple para leer un archivo que contiene texto es readlines(). Aquí hay un ejemplo con el archivo README.md de este libro, que se encuentra en GitHub. readmeGitHub &lt;- &quot;https://raw.githubusercontent.com/frareb/myRBook_SP/master/README.md&quot; readLines(readmeGitHub) ## [1] &quot;# myRBook_SP&quot; ## [2] &quot;Aqui se encuentra el cÃ³digo fuente del libro *Aprender R: iniciaciÃ³n y perfeccionamiento*, construido con bookdown.&quot; También está la función scan() que devolve todas las palabras separadas por espacios. Podemos consultar la ayuda para obtener más información. scan(readmeGitHub, what = &quot;character&quot;) ## [1] &quot;#&quot; &quot;myRBook_SP&quot; &quot;Aqui&quot; ## [4] &quot;se&quot; &quot;encuentra&quot; &quot;el&quot; ## [7] &quot;cÃ³digo&quot; &quot;fuente&quot; &quot;del&quot; ## [10] &quot;libro&quot; &quot;*Aprender&quot; &quot;R:&quot; ## [13] &quot;iniciaciÃ³n&quot; &quot;y&quot; &quot;perfeccionamiento*,&quot; ## [16] &quot;construido&quot; &quot;con&quot; &quot;bookdown.&quot; 10.2 Guardar datos para R A veces es útil poder guardar un objeto R para poder reutilizarlo más tarde. Este es el caso, por ejemplo, cuando el tiempo de cálculo para llegar a un resultado es muy largo, o cuando queremos liberar espacio en la RAM. Para hacer esto, existe la función save() que toma como argumento principal el nombre de los objetos que queremos guardar. El objeto guardado se almacenará en un archivo. Por convención, es bueno dar como nombre de extensión .RData a los archivos que contienen objetos R, preferir un solo objeto por archivo, y dar el nombre del objeto como nombre del archivo. myObject &lt;- 5 ls(pattern = &quot;myObject&quot;) ## [1] &quot;myObject&quot; save(myObject, file = &quot;myFiles/myObject.RData&quot;) rm(myObject) ls(pattern = &quot;myObject&quot;) ## character(0) Si necesitamos el objeto guardado en el archivo, podemos volver a cargarlo con la función load(). ls(pattern = &quot;myObject&quot;) ## character(0) load(&quot;myFiles/myObject.RData&quot;) ls(pattern = &quot;myObject&quot;) ## [1] &quot;myObject&quot; print(myObject) ## [1] 5 10.3 Exportar datos La mejor forma de comunicar sus resultados o datos es enviar sus scripts y archivos de datos. A veces esto no es posible o no es adecuado, y puede ser útil exportar sus datos en un archivo de texto o CSV. Para hacer esto, existe la función genérica write() y la función write.table() para data.frame. Por ejemplo, crearemos un data.frame con los números del 1 al 26 y las letras correspondientes, luego los guardaremos en un archivo CSV, luego volveremos a leer los datos contenidos en este archivo. dfLetters &lt;- data.frame(num = 1:26, letters = letters) write.table(dfLetters, file = &quot;myFiles/dfLetters.csv&quot;, sep = &quot;,&quot;, col.names = TRUE, row.names = FALSE) read.table(file = &quot;myFiles/dfLetters.csv&quot;, header = TRUE, sep = &quot;,&quot;) ## num letters ## 1 1 a ## 2 2 b ## 3 3 c ## 4 4 d ## 5 5 e ## 6 6 f ## 7 7 g ## 8 8 h ## 9 9 i ## 10 10 j ## 11 11 k ## 12 12 l ## 13 13 m ## 14 14 n ## 15 15 o ## 16 16 p ## 17 17 q ## 18 18 r ## 19 19 s ## 20 20 t ## 21 21 u ## 22 22 v ## 23 23 w ## 24 24 x ## 25 25 y ## 26 26 z 10.4 Conclusión Felicitaciones! Ahora sabemos cómo leer datos de un archivo de texto o CSV, guardar y cargar datos de RData, y escribir en un archivo. El error más común entre los principiantes en R es la lectura de archivos de datos. Es por eso que este capítulo es para leer y volver a leer sin moderación. "],
["algo.html", " 11 Algorítmico 11.1 Pruebas lógicas con if 11.2 Pruebas lógicas con switch 11.3 El bucle for 11.4 El bucle while 11.5 El bucle repeat 11.6 next y break 11.7 Los bucles de la familia apply 11.8 Conclusión", " 11 Algorítmico 11.1 Pruebas lógicas con if Si queremos realizar una operación diferente según una condición, podemos configurar una prueba lógica del tipo SI esto ENTONCES esto SINO esto. Con R esto dará como resultado la función if(cond) cons.express alt.expr como se muestra en la función help. myVar &lt;- 2 if(myVar &lt; 3) print(&quot;myVar &lt; 3&quot;) ## [1] &quot;myVar &lt; 3&quot; if(myVar &lt; 3) print(&quot;myVar &lt; 3&quot;) else print(&quot;myVar &gt; 3&quot;) ## [1] &quot;myVar &lt; 3&quot; Cuando hay varias líneas de código para ejecutar basadas en la prueba lógica, o simplemente para hacer que el código sea más fácil de leer, utilizamos varias líneas con {} y con identacion. myVar &lt;- 2 myResult &lt;- 0 if(myVar &lt; 3){ print(&quot;myVar &lt; 3&quot;) myResult &lt;- myVar + 10 } else { print(&quot;myVar &gt; 3&quot;) myResult &lt;- myVar - 10 } ## [1] &quot;myVar &lt; 3&quot; print(myResult) ## [1] 12 En este ejemplo definimos una variable myVar. Si esta variable es menor que 3, la variable myResult se establece en myVar + 10, y de lo contrario myResult se establece en myVar - 10. Ya hemos visto el uso de la prueba lógica if en el capítulo sobre las funciones. Habiamos probado si la variable ingresada como argumento en nuestra función era de tipo character. myVar &lt;- &quot;qwerty&quot; if(is.character(myVar)){ print(&quot;ok&quot;) } else { print(&quot;error&quot;) } ## [1] &quot;ok&quot; También podemos anidar pruebas lógicas entre sí. myVar &lt;- TRUE if(is.character(myVar)){ print(&quot;myVar: character&quot;) } else { if(is.numeric(myVar)){ print(&quot;myVar: numeric&quot;) } else { if(is.logical(myVar)){ print(&quot;myVar: logical&quot;) } else { print(&quot;myVar: ...&quot;) } } } ## [1] &quot;myVar: logical&quot; También es posible estipular varias condiciones, como vimos en el capítulo sobre operadores de comparación. myVar &lt;- 2 if(myVar &gt; 1 &amp; myVar &lt; 50){ print(&quot;ok&quot;) } ## [1] &quot;ok&quot; En este ejemplo, myVar está en formato numeric, por lo que la primera condición (&gt; 1) y la segunda condición (&lt; 50) son verificables. Por otro lado, si asignamos una variable de tipo character a myVar entonces R transformará 0 y 10 en objetos de tipo character y probará si myVar&gt; &quot;1&quot; y despues si myVar &lt; &quot;50&quot; basandose en la clasificación alfabética. En el siguiente ejemplo, &quot;azerty&quot; no está ubicado segun el orden alfabético entre &quot;1&quot; y &quot;50&quot;, pero para &quot;2azerty&quot; es el caso, lo que resulta problematico. myVar &lt;- &quot;azerty&quot; limInit &lt;- 1 limEnd &lt;- 50 if(myVar &gt; limInit &amp; myVar &lt; limEnd){ print(paste0(myVar, &quot; is between &quot;, limInit, &quot; and &quot;, limEnd, &quot;.&quot;)) } else { print(paste0(myVar, &quot; not between &quot;, limInit, &quot; and &quot;, limEnd, &quot;.&quot;)) } ## [1] &quot;azerty not between 1 and 50.&quot; myVar &lt;- &quot;2azerty&quot; if(myVar &gt; limInit &amp; myVar &lt; limEnd){ print(paste0(myVar, &quot; is between &quot;, limInit, &quot; and &quot;, limEnd, &quot;.&quot;)) } else { print(paste0(myVar, &quot; not between &quot;, limInit, &quot; and &quot;, limEnd, &quot;.&quot;)) } ## [1] &quot;2azerty is between 1 and 50.&quot; Entonces, lo que nos gustaría hacer es probar si myVar está en formato numeric, y entonces solo si es el caso probar las siguientes condiciones. myVar &lt;- &quot;2azerty&quot; if(is.numeric(myVar)){ if(myVar &gt; limInit &amp; myVar &lt; limEnd){ print(paste0(myVar, &quot; is between &quot;, limInit, &quot; and &quot;, limEnd, &quot;.&quot;)) } else { print(paste0(myVar, &quot; not between &quot;, limInit, &quot; and &quot;, limEnd, &quot;.&quot;)) } } else { print(paste0(&quot;Object &quot;, myVar, &quot; is not numeric&quot;)) } ## [1] &quot;Object 2azerty is not numeric&quot; A veces es posible que necesitemos probar una primera condición y luego una segunda condición solo si la primera es verdadera en la misma prueba. Por ejemplo, para un sitio nos gustaría saber si hay una sola especie y probar si su abundancia es mayor que 10. Imagine un conjunto de datos con abundancia de vectores. Probaremos el número de especies con la función length (). mySpecies &lt;- c(15, 14, 20, 12) if(length(mySpecies) == 1 &amp; mySpecies &gt; 10){ print(&quot;ok!&quot;) } ## Warning message: ## In if (length(mySpecies) == 1 &amp; mySpecies &gt; 10) { : ## the condition has length &gt; 1 and only the first element will be used R devuelve un error porque no puede dentro de una prueba lógica con if() verificar la segunda condición. De hecho, mySpecies &gt; 10 devuelve TRUE TRUE TRUE TRUE TRUE. Podemos separar el código en dos condiciones: mySpecies &lt;- c(15, 14, 20, 12) if(length(mySpecies) == 1){ if(mySpecies &gt; 10){ print(&quot;ok!&quot;) } } Una alternativa más elegante es decirle a R que verifique la segunda condición solo si la primera es verdadera. Para eso podemos usar &amp;&amp; en lugar de &amp;. mySpecies &lt;- c(15, 14, 20, 12) if(length(mySpecies) == 1 &amp;&amp; mySpecies &gt; 10){ print(&quot;ok!&quot;) } mySpecies &lt;- 15 if(length(mySpecies) == 1 &amp;&amp; mySpecies &gt; 10){ print(&quot;ok!&quot;) } ## [1] &quot;ok!&quot; mySpecies &lt;- 5 if(length(mySpecies) == 1 &amp;&amp; mySpecies &gt; 10){ print(&quot;ok!&quot;) } Con &amp; R comprobará todas las condiciones, y con &amp;&amp; R tomará cada condición una después de la otra y continuará solo si es verdadera. Esto puede parecer anecdótico, pero es bueno saber la diferencia entre &amp; y &amp;&amp; porque a menudo los encontramos en los códigos disponibles en Internet o en los paquetes. 11.2 Pruebas lógicas con switch La función switch() es una variante de if() que es útil cuando tenemos muchas opciones posibles para la misma expresión. El siguiente ejemplo muestra cómo transformar el código usando if() a switch(). x &lt;- &quot;aa&quot; if(x == &quot;a&quot;){ result &lt;- 1 } if(x == &quot;aa&quot;){ result &lt;- 2 } if(x == &quot;aaa&quot;){ result &lt;- 3 } if(x == &quot;aaaa&quot;){ result &lt;- 4 } print(result) ## [1] 2 x &lt;- &quot;aa&quot; switch(x, a = result &lt;- 1, aa = result &lt;- 2, aaa = result &lt;- 3, aaaa = result &lt;- 4) print(result) ## [1] 2 11.3 El bucle for En programación, cuando tenemos que repetir la misma línea de código varias veces, es un signo que indica que debemos usar un bucle. Un bucle es una forma de iterar sobre un conjunto de objetos (o los elementos de un objeto) y repetir una operación. Imaginamos un data.frame con mediciones de datos de campo en dos fechas. bdd &lt;- data.frame(date01 = rnorm(n = 100, mean = 10, sd = 1), date02 = rnorm(n = 100, mean = 10, sd = 1)) print(head(bdd)) ## date01 date02 ## 1 9.931410 10.20626 ## 2 10.073029 8.82943 ## 3 10.368169 9.25168 ## 4 9.509984 10.06533 ## 5 8.826607 9.60102 ## 6 12.087584 10.45548 Nos gustaría cuantificar la diferencia entre la primera y la segunda fecha, luego poner un indicador para saber si esta diferencia es pequeña o grande, por ejemplo, con un umbral arbitrario de 3. Entonces, para cada línea podríamos hacer: bdd$dif &lt;- NA bdd$isDifBig &lt;- NA bdd$dif[1] &lt;- sqrt((bdd$date01[1] - bdd$date02[1])^2) bdd$dif[2] &lt;- sqrt((bdd$date01[2] - bdd$date02[2])^2) bdd$dif[3] &lt;- sqrt((bdd$date01[3] - bdd$date02[3])^2) # ... bdd$dif[100] &lt;- sqrt((bdd$date01[100] - bdd$date02[100])^2) if(bdd$dif[1] &gt; 3){ bdd$isDifBig[1] &lt;- &quot;big&quot; }else{ bdd$isDifBig[1] &lt;- &quot;small&quot; } if(bdd$dif[2] &gt; 3){ bdd$isDifBig[2] &lt;- &quot;big&quot; }else{ bdd$isDifBig[2] &lt;- &quot;small&quot; } if(bdd$dif[3] &gt; 3){ bdd$isDifBig[3] &lt;- &quot;big&quot; }else{ bdd$isDifBig[3] &lt;- &quot;small&quot; } # ... if(bdd$dif[100] &gt; 3){ bdd$isDifBig[100] &lt;- &quot;big&quot; }else{ bdd$isDifBig[100] &lt;- &quot;small&quot; } Esta forma de hacer las cosas sería extremadamente tediosa de lograr, y casi imposible de lograr si la tabla contuviera 1000 o 100000 líneas. Puede parecer lógico querer iterar sobre las líneas de nuestro data.frame para obtener las nuevas columnas. Es lo que vamos a hacer aun que no es la solución que retendremos más adelante. Vamos a usar un bucle for(). El bucle for() recorrerá los elementos de un objeto que vamos a dar como argumento. Por ejemplo, aquí hay un bucle que para todos los números del 3 al 9 calculará su valor al cuadrado. El valor actual del número está simbolizado por un objeto que puede tomar el nombre que queramos (aquí será i). for(i in c(3, 4, 5, 6, 7, 8, 9)){ print(i^2) } ## [1] 9 ## [1] 16 ## [1] 25 ## [1] 36 ## [1] 49 ## [1] 64 ## [1] 81 Eso podemos mejorar usando la función :. for(i in 3:9){ print(i^2) } El bucle for() puede iterar sobre todos los tipos de elementos. nChar &lt;- c(&quot;a&quot;, &quot;z&quot;, &quot;e&quot;, &quot;r&quot;, &quot;t&quot;, &quot;y&quot;) for(i in nChar){ print(i) } ## [1] &quot;a&quot; ## [1] &quot;z&quot; ## [1] &quot;e&quot; ## [1] &quot;r&quot; ## [1] &quot;t&quot; ## [1] &quot;y&quot; Volvamos a nuestro caso. Vamos a iterar sobre el número de líneas de nuestro data.frame bdd. Antes de eso crearemos las columnas dif y isDifBig con los valores NA. Luego usaremos la función nrow() para encontrar el número de líneas. bdd$dif &lt;- NA bdd$isDifBig &lt;- NA for(i in 1:nrow(bdd)){ bdd$dif[i] &lt;- sqrt((bdd$date01[i] - bdd$date02[i])^2) if(bdd$dif[i] &gt; 3){ bdd$isDifBig[i] &lt;- &quot;big&quot; }else{ bdd$isDifBig[i] &lt;- &quot;small&quot; } } print(head(bdd, n = 20)) ## date01 date02 dif isDifBig ## 1 9.931410 10.206260 0.27485048 small ## 2 10.073029 8.829430 1.24359906 small ## 3 10.368169 9.251680 1.11648896 small ## 4 9.509984 10.065330 0.55534614 small ## 5 8.826607 9.601020 0.77441311 small ## 6 12.087584 10.455482 1.63210170 small ## 7 10.279414 11.565701 1.28628680 small ## 8 9.576970 9.071997 0.50497292 small ## 9 8.682584 11.967954 3.28537071 big ## 10 9.742034 10.730933 0.98889837 small ## 11 10.401393 10.103246 0.29814705 small ## 12 8.361763 10.900472 2.53870939 small ## 13 9.703234 9.666433 0.03680047 small ## 14 10.306315 9.268623 1.03769196 small ## 15 10.912440 9.201843 1.71059746 small ## 16 10.067544 10.849359 0.78181428 small ## 17 10.545054 9.594923 0.95013108 small ## 18 9.128617 10.560705 1.43208859 small ## 19 11.335854 11.670655 0.33480128 small ## 20 9.416334 8.768262 0.64807228 small En la práctica, esta no es la mejor manera de realizar este ejercicio porque se trata de cálculos simples en vectores contenidos en un data.frame. R es particularmente potente para realizar operaciones en vectores. Donde sea posible, siempre tenemos que enfócarnos en operaciones vectoriales. Aquí nuestro código se convierte en: bdd$dif &lt;- sqrt((bdd$date01 - bdd$date02)^2) bdd$isDifBig &lt;- &quot;small&quot; bdd$isDifBig[bdd$dif &gt; 3] &lt;- &quot;big&quot; print(head(bdd, n = 20)) ## date01 date02 dif isDifBig ## 1 9.931410 10.206260 0.27485048 small ## 2 10.073029 8.829430 1.24359906 small ## 3 10.368169 9.251680 1.11648896 small ## 4 9.509984 10.065330 0.55534614 small ## 5 8.826607 9.601020 0.77441311 small ## 6 12.087584 10.455482 1.63210170 small ## 7 10.279414 11.565701 1.28628680 small ## 8 9.576970 9.071997 0.50497292 small ## 9 8.682584 11.967954 3.28537071 big ## 10 9.742034 10.730933 0.98889837 small ## 11 10.401393 10.103246 0.29814705 small ## 12 8.361763 10.900472 2.53870939 small ## 13 9.703234 9.666433 0.03680047 small ## 14 10.306315 9.268623 1.03769196 small ## 15 10.912440 9.201843 1.71059746 small ## 16 10.067544 10.849359 0.78181428 small ## 17 10.545054 9.594923 0.95013108 small ## 18 9.128617 10.560705 1.43208859 small ## 19 11.335854 11.670655 0.33480128 small ## 20 9.416334 8.768262 0.64807228 small La mayoría de los ejemplos que se pueden encontrar en Internet sobre el bucle for() pueden reemplazarse por operaciones vectoriales. Aquí hay algunos ejemplos adaptados de varias fuentes: # prueba si los números son pares # [1] FOR x &lt;- sample(1:100, size = 20) count &lt;- 0 for (val in x) { if(val %% 2 == 0){ count &lt;- count + 1 } } print(count) ## [1] 11 # [2] VECTOR sum(x %% 2 == 0) ## [1] 11 # calcular cuadrados # [1] FOR x &lt;- rep(0, 20) for (j in 1:20){ x[j] &lt;- j^2 } print(x) ## [1] 1 4 9 16 25 36 49 64 81 100 121 144 169 196 225 256 289 ## [18] 324 361 400 # [2] VECTOR (1:20)^2 ## [1] 1 4 9 16 25 36 49 64 81 100 121 144 169 196 225 256 289 ## [18] 324 361 400 # repetir una tirada de dados y promediar # [1] FOR ntrials = 1000 trials = rep(0, ntrials) for (j in 1:ntrials){ trials[j] = sample(1:6, size = 1) } mean(trials) ## [1] 3.527 # [2] VECTOR mean(sample(1:6, ntrials, replace = TRUE)) ## [1] 3.513 Es un buen ejercicio explorar los muchos ejemplos disponibles en Internet en el bucle for() e intentar convertirlos en operaciones vectoriales. Esto nos permite adquirir buenos reflejos de programación con R. El bucle for() es muy útil, por ejemplo, para leer varios archivos y tratar la información que contienen de la misma manera, hacer gráficos, o Cuando las operaciones vectoriales se vuelven tediosas. Imagina una matriz de 10 columnas y 100 líneas. Queremos la suma de cada línea (veremos cómo hacer con la función apply() mas adelante). myMat &lt;- matrix(sample(1:100, size = 1000, replace = TRUE), ncol = 10) # VECTOR sumRow &lt;- myMat[, 1] + myMat[, 2] + myMat[, 3] + myMat[, 4] + myMat[, 5] + myMat[, 6] + myMat[, 7] + myMat[, 8] + myMat[, 9] + myMat[, 10] print(sumRow) ## [1] 429 510 593 629 504 529 388 481 622 492 631 431 592 353 485 540 538 ## [18] 584 362 621 464 434 400 468 453 580 551 414 436 371 438 414 410 489 ## [35] 561 602 613 392 386 573 463 624 662 571 450 496 479 663 448 526 385 ## [52] 735 585 568 477 474 294 527 471 550 354 497 510 637 394 574 436 462 ## [69] 441 596 382 507 502 541 574 481 519 557 555 484 499 625 532 511 634 ## [86] 552 472 416 442 515 483 606 536 571 508 568 673 485 580 370 # FOR sumRow &lt;- rep(NA, times = nrow(myMat)) for(j in 1:nrow(myMat)){ sumRow[j] &lt;- sum(myMat[j, ]) } print(sumRow) ## [1] 429 510 593 629 504 529 388 481 622 492 631 431 592 353 485 540 538 ## [18] 584 362 621 464 434 400 468 453 580 551 414 436 371 438 414 410 489 ## [35] 561 602 613 392 386 573 463 624 662 571 450 496 479 663 448 526 385 ## [52] 735 585 568 477 474 294 527 471 550 354 497 510 637 394 574 436 462 ## [69] 441 596 382 507 502 541 574 481 519 557 555 484 499 625 532 511 634 ## [86] 552 472 416 442 515 483 606 536 571 508 568 673 485 580 370 En conclusión, se recomienda no usar el bucle for() con R siempre que sea posible, y en este capítulo veremos alternativas como los bucles familiares apply(). 11.4 El bucle while El bucle while(), a diferencia del bucle for(), significa MIENTRAS. Mientras no se cumpla una condición, el bucle continuará ejecutándose. Atención porque en caso de error, podemos programar fácilmente bucles que nunca terminan. Este bucle es menos común que el bucle for(). Tomemos un ejemplo: i &lt;- 0 while(i &lt; 10){ print(i) i &lt;- i + 1 } ## [1] 0 ## [1] 1 ## [1] 2 ## [1] 3 ## [1] 4 ## [1] 5 ## [1] 6 ## [1] 7 ## [1] 8 ## [1] 9 En este ejemplo, la variable i tiene como valor inicial 0. MIENTRAS QUE i &lt; 10, mostramos i con print(). Para que este bucle finalice, no olvidamos cambiar el valor de i, esto se hace con la línea i &lt;- i + 1. Cuando la condición i &lt; 10 ya no se cumple, el bucle se detiene. El bucle while() es muy útil para crear scripts que realizarán cálculos en variables cuyo valor cambia con el tiempo. Por ejemplo, imaginamos un número entre 0 y 10000 y un generador aleatorio que intentará determinar el valor de este número. Si queremos limitar los intentos de R a 2 segundos, podemos escribir el siguiente script (que debería funcionar cada vez en una computadora de escritorio típica que pueda realizar fácilmente 35000 pruebas en 2 segundos): myNumber &lt;- sample(x = 10000, size = 1) myGuess &lt;- sample(x = 10000, size = 1) startTime &lt;- Sys.time() numberGuess &lt;- 0 while(Sys.time() - startTime &lt; 2){ if(myGuess == myNumber){ numberGuess &lt;- numberGuess + 1 print(&quot;Number found !&quot;) print(paste0(&quot;And I have plenty of time left: &quot;, round(2 - as.numeric(Sys.time() - startTime), digits = 2), &quot; sec&quot;)) break }else{ myGuess &lt;- sample(x = 10000, size = 1) numberGuess &lt;- numberGuess + 1 } } ## [1] &quot;Number found !&quot; ## [1] &quot;And I have plenty of time left: 1.82 sec&quot; En este script generamos un número aleatorio para adivinar con la función sample(), y cada uno de los intentos con la misma función sample(). Luego usamos la función Sys.time() (con una S mayúscula a Sys), para saber la hora de inicio del bucle. Siempre que la diferencia entre cada iteración del bucle y la hora de inicio sea inferior a 2 segundos, el bucle while() verificará si el número correcto estaba adivinando en la prueba lógica con if() y luego si es el caso nos informa que se encontró el número, y nos indica el tiempo restante antes de los dos segundos. Luego para finalizar el bucle usamos la palabra clave “break” en la que volveremos. En resumen, break, permite salir de un bucle. Si no se ha adivinado el número, el bucle realiza otra prueba con la función sample(). Más concretamente, podríamos imaginar algoritmos para explorar un espacio de soluciones a un problema con un tiempo limitado para lograrlo. El bucle while() también puede ser útil para que un script se ejecute solo cuando un archivo de otro programa esté disponible … En la práctica, el bucle while() se usa poco con R. 11.5 El bucle repeat El bucle repeat() permite repetir una operación sin condiciones para verificar. Para salir de este bucle debemos usar la palabra clave break. i &lt;- 1 repeat{ print(i^2) i &lt;- i + 1 if(i == 5){ break } } ## [1] 1 ## [1] 4 ## [1] 9 ## [1] 16 Si volvemos al ejemplo anterior, podemos usar un bucle repeat() para repetirlo cinco veces. numTry &lt;- 0 repeat{ myNumber &lt;- sample(x = 10000, size = 1) myGuess &lt;- sample(x = 10000, size = 1) startTime &lt;- Sys.time() numberGuess &lt;- 0 while(Sys.time() - startTime &lt; 2){ if(myGuess == myNumber){ numberGuess &lt;- numberGuess + 1 print(round(as.numeric(Sys.time() - startTime), digits = 3)) break }else{ myGuess &lt;- sample(x = 10000, size = 1) numberGuess &lt;- numberGuess + 1 } } numTry &lt;- numTry + 1 if(numTry == 5){break} } ## [1] 0.232 ## [1] 0.475 ## [1] 0.279 ## [1] 0.419 ## [1] 0.016 Al igual que el bucle while(), el bucle repeat() no se usa mucho con R. 11.6 next y break Ya hemos visto la palabra clave break que permite salir del bucle actual. Por ejemplo, si buscamos el primer dígito después de 111 que es divisible por 32: myVars &lt;- 111:1000 for(myVar in myVars){ if(myVar %% 32 == 0){ print(myVar) break } } ## [1] 128 Aunque hemos visto que en la práctica podemos evitar el bucle for() con una operación vectorial: (111:1000)[111:1000 %% 32 == 0][1] ## [1] 128 La palabra clave next permite pasar a la siguiente iteración de un bucle si se cumple una determinada condición. Por ejemplo, si queremos imprimir las letras del alfabeto sin las vocales: for(myLetter in letters){ if(myLetter %in% c(&quot;a&quot;, &quot;e&quot;, &quot;i&quot;, &quot;o&quot;, &quot;u&quot;, &quot;y&quot;)){ next } print(myLetter) } ## [1] &quot;b&quot; ## [1] &quot;c&quot; ## [1] &quot;d&quot; ## [1] &quot;f&quot; ## [1] &quot;g&quot; ## [1] &quot;h&quot; ## [1] &quot;j&quot; ## [1] &quot;k&quot; ## [1] &quot;l&quot; ## [1] &quot;m&quot; ## [1] &quot;n&quot; ## [1] &quot;p&quot; ## [1] &quot;q&quot; ## [1] &quot;r&quot; ## [1] &quot;s&quot; ## [1] &quot;t&quot; ## [1] &quot;v&quot; ## [1] &quot;w&quot; ## [1] &quot;x&quot; ## [1] &quot;z&quot; De nuevo podimos evitar el bucle for() con: letters[! letters %in% c(&quot;a&quot;, &quot;e&quot;, &quot;i&quot;, &quot;o&quot;, &quot;u&quot;, &quot;y&quot;)] ## [1] &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; &quot;j&quot; &quot;k&quot; &quot;l&quot; &quot;m&quot; &quot;n&quot; &quot;p&quot; &quot;q&quot; &quot;r&quot; &quot;s&quot; &quot;t&quot; &quot;v&quot; ## [18] &quot;w&quot; &quot;x&quot; &quot;z&quot; En conclusión, si usamos bucles, las palabras clave next y break suelen ser muy útiles, pero siempre que sea posible es mejor usar operaciones vectoriales. Cuando no es posible trabajar con vectores, es mejor usar los bucles del tipo apply que son el tema de la siguiente sección. 11.7 Los bucles de la familia apply 11.7.1 apply La función apply() permite aplicar una función a todos los elementos de un array o un matrix. Por ejemplo, si queremos saber la suma de cada fila de una matriz de 10 columnas y 100 líneas: myMat &lt;- matrix(sample(1:100, size = 1000, replace = TRUE), ncol = 10) apply(X = myMat, MARGIN = 1, FUN = sum) ## [1] 436 543 602 393 550 513 498 405 531 493 565 486 552 329 569 524 489 ## [18] 508 457 540 454 558 346 447 400 588 445 653 322 502 466 476 299 421 ## [35] 546 669 495 386 477 529 626 493 421 561 515 571 519 494 588 563 482 ## [52] 476 436 563 569 660 589 576 583 475 530 578 363 506 596 323 356 539 ## [69] 414 617 547 479 432 529 485 464 701 494 644 525 509 540 561 590 489 ## [86] 567 568 432 439 730 563 568 529 605 607 518 584 498 465 582 Si queremos saber la mediana de cada columna, la expresión se convierte en: apply(X = myMat, MARGIN = 2, FUN = median) ## [1] 59.0 52.5 56.0 55.5 52.0 48.5 43.5 57.0 44.0 45.5 El argumento X es el objeto en el que el bucle apply se repetirá. El argumento MARGEN corresponde a la dimensión a tener en cuenta (1 para las filas y 2 para las columnas). El argumento FUN es la función a aplicar. En un objeto array, el argumento MARGIN puede tomar tantos valores como dimensiones. En este ejemplo, MARGIN = 1 es el promedio de cada fila - dimensión 1 - (todas las dimensiones combinadas), MARGIN = 2 es el promedio de cada columna - dimensión 2 - (todas las dimensiones combinadas), y MARGEN = 3 es el promedio de cada dimensión 3. Debajo cada cálculo se realiza de dos maneras diferentes para explicar su operación. myArr &lt;- array(sample(1:100, size = 1000, replace = TRUE), dim = c(10, 20, 5)) apply(X = myArr, MARGIN = 1, FUN = mean) ## [1] 53.98 53.55 52.00 50.10 52.48 51.24 50.98 45.60 54.05 49.08 (apply(myArr[,,1], 1, mean) + apply(myArr[,,2], 1, mean) + apply(myArr[,,3], 1, mean) + apply(myArr[,,4], 1, mean) + apply(myArr[,,5], 1, mean))/5 ## [1] 53.98 53.55 52.00 50.10 52.48 51.24 50.98 45.60 54.05 49.08 apply(X = myArr, MARGIN = 2, FUN = mean) ## [1] 53.40 50.28 47.58 47.54 48.30 53.40 48.52 55.40 55.50 55.02 47.36 ## [12] 55.26 53.56 51.96 50.10 53.14 54.16 48.02 51.72 45.90 (apply(myArr[,,1], 2, mean) + apply(myArr[,,2], 2, mean) + apply(myArr[,,3], 2, mean) + apply(myArr[,,4], 2, mean) + apply(myArr[,,5], 2, mean))/5 ## [1] 53.40 50.28 47.58 47.54 48.30 53.40 48.52 55.40 55.50 55.02 47.36 ## [12] 55.26 53.56 51.96 50.10 53.14 54.16 48.02 51.72 45.90 apply(X = myArr, MARGIN = 3, FUN = mean) ## [1] 56.900 49.540 48.305 51.575 50.210 c(mean(myArr[,,1]), mean(myArr[,,2]), mean(myArr[,,3]), mean(myArr[,,4]), mean(myArr[,,5])) ## [1] 56.900 49.540 48.305 51.575 50.210 También podemos calcular el promedio de cada fila y valor de columna (la función luego itera en la dimensión 3): apply(X = myArr, MARGIN = c(1, 2), FUN = mean) ## [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12] [,13] ## [1,] 43.2 69.0 42.0 49.6 49.4 50.2 55.6 48.0 81.0 66.4 30.0 61.4 53.6 ## [2,] 56.8 57.2 69.4 58.4 39.2 54.6 37.0 81.8 55.4 61.8 37.0 40.6 65.4 ## [3,] 47.8 73.8 56.6 50.4 57.8 44.2 67.8 37.2 16.2 40.6 49.6 69.0 58.6 ## [4,] 49.0 39.0 59.8 31.8 31.4 57.6 53.4 59.4 73.4 39.2 47.2 55.6 65.0 ## [5,] 42.6 49.6 36.8 57.6 65.2 39.6 25.4 46.8 39.6 71.8 51.2 61.0 61.4 ## [6,] 74.0 46.8 39.6 70.4 55.8 51.0 49.6 44.6 64.4 43.4 44.6 48.2 42.4 ## [7,] 53.8 59.0 39.6 41.2 31.2 54.0 58.8 57.8 44.6 71.4 40.4 54.6 43.4 ## [8,] 58.4 46.6 44.4 24.8 45.2 60.0 44.0 57.6 42.0 55.6 68.2 34.6 29.4 ## [9,] 36.4 35.6 62.8 38.6 68.2 67.0 64.0 52.8 77.6 60.8 66.6 73.0 43.6 ## [10,] 72.0 26.2 24.8 52.6 39.6 55.8 29.6 68.0 60.8 39.2 38.8 54.6 72.8 ## [,14] [,15] [,16] [,17] [,18] [,19] [,20] ## [1,] 52.8 51.8 46.4 58.8 49.8 62.2 58.4 ## [2,] 57.4 57.0 48.8 74.0 56.8 49.2 13.2 ## [3,] 49.2 26.2 65.8 55.0 52.4 68.0 53.8 ## [4,] 52.0 74.8 46.2 49.8 47.2 52.8 17.4 ## [5,] 65.2 67.0 60.0 68.4 49.2 38.0 53.2 ## [6,] 56.0 47.4 31.6 51.0 64.0 41.0 59.0 ## [7,] 59.6 60.0 69.8 56.0 27.6 59.2 37.6 ## [8,] 47.8 20.4 53.0 43.6 40.2 45.0 51.2 ## [9,] 33.8 46.2 65.0 36.8 42.2 46.2 63.8 ## [10,] 45.8 50.2 44.8 48.2 50.8 55.6 51.4 11.7.2 lapply Como se indica en la documentación, lapply() devuelve una lista de la misma longitud que X, y cada elemento resulta de la aplicación FUN al elemento X correspondiente. Si X es una list que contiene vector y estamos tratando de obtener el promedio de cada elemento de list, podemos usar la función lapply(): myList &lt;- list( a = sample(1:100, size = 10), b = sample(1:100, size = 10), c = sample(1:100, size = 10), d = sample(1:100, size = 10), e = sample(1:100, size = 10) ) print(myList) ## $a ## [1] 84 3 9 62 99 10 96 85 71 41 ## ## $b ## [1] 83 6 11 16 70 75 52 68 2 20 ## ## $c ## [1] 98 95 69 80 39 78 17 50 81 91 ## ## $d ## [1] 12 10 95 31 86 32 25 22 38 35 ## ## $e ## [1] 64 14 77 25 100 89 40 76 79 4 lapply(myList, FUN = mean) ## $a ## [1] 56 ## ## $b ## [1] 40.3 ## ## $c ## [1] 69.8 ## ## $d ## [1] 38.6 ## ## $e ## [1] 56.8 Al igual que con la función apply(), podemos pasar argumentos adicionales a la función lapply() agregándolos después de la función. Esto es útil, por ejemplo, si nuestra list contiene estos valores faltantes NA y queremos ignorarlos para calcular los promedios (con el argumento na.rm = TRUE). myList &lt;- list( a = sample(c(1:5, NA), size = 10, replace = TRUE), b = sample(c(1:5, NA), size = 10, replace = TRUE), c = sample(c(1:5, NA), size = 10, replace = TRUE), d = sample(c(1:5, NA), size = 10, replace = TRUE), e = sample(c(1:5, NA), size = 10, replace = TRUE) ) print(myList) ## $a ## [1] 2 2 1 3 2 NA 1 2 2 NA ## ## $b ## [1] 5 1 4 3 1 2 5 1 NA 3 ## ## $c ## [1] 3 4 2 5 3 NA NA 5 2 5 ## ## $d ## [1] 1 2 NA 2 1 5 3 2 1 1 ## ## $e ## [1] NA 5 1 1 5 3 1 3 5 5 lapply(myList, FUN = mean) ## $a ## [1] NA ## ## $b ## [1] NA ## ## $c ## [1] NA ## ## $d ## [1] NA ## ## $e ## [1] NA lapply(myList, FUN = mean, na.rm = TRUE) ## $a ## [1] 1.875 ## ## $b ## [1] 2.777778 ## ## $c ## [1] 3.625 ## ## $d ## [1] 2 ## ## $e ## [1] 3.222222 Para mayor legibilidad o si se debemos realizar varias operaciones dentro del argumento FUN, podemos usar el siguiente script: lapply(myList, FUN = function(i){ mean(i, na.rm = TRUE) }) ## $a ## [1] 1.875 ## ## $b ## [1] 2.777778 ## ## $c ## [1] 3.625 ## ## $d ## [1] 2 ## ## $e ## [1] 3.222222 Por ejemplo, si queremos obtener i^2 si el promedio es mayor que 3, y i^3 de lo contrario: lapply(myList, FUN = function(i){ m &lt;- mean(i, na.rm = TRUE) if(m &gt; 3){ return(i^2) }else{ return(i^3) } }) ## $a ## [1] 8 8 1 27 8 NA 1 8 8 NA ## ## $b ## [1] 125 1 64 27 1 8 125 1 NA 27 ## ## $c ## [1] 9 16 4 25 9 NA NA 25 4 25 ## ## $d ## [1] 1 8 NA 8 1 125 27 8 1 1 ## ## $e ## [1] NA 25 1 1 25 9 1 9 25 25 11.7.3 sapply La función sapply() es una versión modificada de la función lapply() que realiza la misma operación pero devuelve el resultado en un formato simplificado siempre que sea posible. lapply(myList, FUN = function(i){ mean(i, na.rm = TRUE) }) ## $a ## [1] 1.875 ## ## $b ## [1] 2.777778 ## ## $c ## [1] 3.625 ## ## $d ## [1] 2 ## ## $e ## [1] 3.222222 sapply(myList, FUN = function(i){ mean(i, na.rm = TRUE) }) ## a b c d e ## 1.875000 2.777778 3.625000 2.000000 3.222222 La función sapply() es interesante para recuperar, por ejemplo, el elemento “n” de cada elemento de una list. La función que se llama para hacer esto es '[['. sapply(myList, FUN = &#39;[[&#39;, 2) ## a b c d e ## 2 1 4 2 5 11.7.4 tapply La función tapply() permite aplicar una función tomando como elemento para iterar una variable existente. Imaginamos información sobre especies representadas por letras mayúsculas (por ejemplo, A, B, C) y valores de mediciones biologicas en diferentes ubicaciones. species &lt;- sample(LETTERS[1:10], size = 1000, replace = TRUE) perf1 &lt;- rnorm(n = 1000, mean = 10, sd = 0.5) perf2 &lt;- rlnorm(n = 1000, meanlog = 10, sdlog = 0.5) perf3 &lt;- rgamma(n = 1000, shape = 10, rate = 0.5) dfSpecies &lt;- data.frame(species, perf1, perf2, perf3) print(head(dfSpecies, n = 10)) ## species perf1 perf2 perf3 ## 1 E 9.624152 8355.861 27.85224 ## 2 H 9.031371 10004.189 32.68659 ## 3 E 9.450630 11528.930 23.42226 ## 4 G 9.988025 53702.293 34.60455 ## 5 J 10.644337 12882.290 21.99404 ## 6 C 10.063660 15079.820 20.45250 ## 7 F 9.891189 12654.929 24.68377 ## 8 F 10.047821 27602.272 11.92797 ## 9 A 9.610383 26494.812 27.73818 ## 10 J 9.619142 45846.799 28.77747 Podemos obtener fácilmente un resumen de las mediciones para cada especie con la función tapply() y la función summary(). tapply(dfSpecies$perf1, INDEX = dfSpecies$species, FUN = summary) ## $A ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 8.962 9.666 10.059 9.999 10.306 11.631 ## ## $B ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 8.859 9.676 9.979 10.032 10.395 11.354 ## ## $C ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 8.740 9.556 9.897 9.920 10.240 11.060 ## ## $D ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 8.754 9.586 9.922 9.932 10.237 11.271 ## ## $E ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 8.817 9.624 9.996 9.985 10.343 11.631 ## ## $F ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 8.704 9.734 10.048 9.998 10.332 11.180 ## ## $G ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 9.080 9.769 10.020 10.052 10.441 11.162 ## ## $H ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 8.797 9.610 9.950 9.964 10.277 11.436 ## ## $I ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 8.771 9.598 9.966 9.943 10.232 11.368 ## ## $J ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 8.839 9.688 9.995 10.024 10.312 11.458 También podemos obtener el valor promedio de cada mediciones combinando una función sapply() con la función tapply() y usando la función mean(). sapply(2:4, FUN = function(i){ tapply(dfSpecies[,i], INDEX = dfSpecies$species, FUN = mean) }) ## [,1] [,2] [,3] ## A 9.998895 25036.70 20.19985 ## B 10.031797 26698.10 20.19251 ## C 9.920241 24703.81 19.81209 ## D 9.932315 23292.19 20.11155 ## E 9.984807 24765.56 20.23726 ## F 9.998006 24447.51 19.99511 ## G 10.052084 24901.66 19.91650 ## H 9.964102 25976.71 20.38668 ## I 9.942631 24308.49 19.31502 ## J 10.024080 23023.21 20.44797 11.7.5 mapply La función mapply() es una versión de la función sapply() que usa múltiples argumentos. Por ejemplo, si tenemos una lista de dos elementos 1:5 y 5:1 y queremos agregar 10 al primer elemento y 100 al segundo elemento: mapply(FUN = function(i, j){i+j}, i = list(1:5, 5:1), j = c(10, 100)) ## [,1] [,2] ## [1,] 11 105 ## [2,] 12 104 ## [3,] 13 103 ## [4,] 14 102 ## [5,] 15 101 11.8 Conclusión Felicitaciones, hemos llegado al final de este capítulo sobre algoritmos. Recordemos este mensaje clave: cuando una operación debe realizarse más de dos veces en un script y repetir el código que ya se ha escrito, es un signo que nos debe llevar a utilizar un bucle. Sin embargo, siempre que sea posible, se recomienda no usar los bucles tradicionales for(), while(), y repeat(), sino preferir operaciones sobre vectores o bucles de la familia apply. Esto puede ser difícil de integrar al principio, pero veremos que nuestros scripts serán más fáciles de mantener y leer, y mucho más eficientes si seguimos estos hábitos. "],
["project.html", " 12 Gestión de proyectos con R 12.1 Gestionando archivos y directorios de trabajo. 12.2 Gestión de versiones de script 12.3 Gestion de documentacion 12.4 Conclusión", " 12 Gestión de proyectos con R Ahora que hemos visto los conceptos básicos de R, todavía tenemos que abordar un elemento decisivo para el buen funcionamiento de nuestras actividades científicas con R: gestión de proyectos. Consiste en integrar sus desarrollos en un entorno y con una lógica orientada a facilitar su trabajo y aumentar así su eficiencia. Esta es solo una manera de hacer dentro de las infinitas posibilidades, a adaptar para todos y cada uno. 12.1 Gestionando archivos y directorios de trabajo. Entre los archivos de entrada (es decir, los archivos que contienen nuestros datos en bruto), los archivos de salida (por ejemplo, con la función write()), los gráficos (siguiente capítulo) y los muchos scripts asociados con un proyecto, se necesita un mínimo de organización para ser eficaz y reanudar rápidamente su proyecto. La solución más sencilla es estructurar su entorno de trabajo en carpetas según cada categoría de archivo. Por ejemplo, con una carpeta “myProject” para el proyecto, que contiene las carpetas “myFiles” para los archivos de entrada, una carpeta “myScripts” para el script R y una carpeta “myOutputs” para los archivos salida (por ejemplo, gráficos y análisis). ## -myProject ## |-myFiles ## |-|-data01.csv ## |-|-data02.csv ## |-myScripts ## |-|-myFirstScript.R ## |-myOutputs ## |-|-dataOut01.csv ## |-|-figure01.pdf 12.2 Gestión de versiones de script El trabajo en un script es iterativo: incluso si los objetivos se definen desde el principio, volveremos a trabajar algunas partes para obtener, por ejemplo, información adicional, o para optimizar esta o aquella función, o hacer un script generalizable para comunicarlo a La comunidad científica o simplemente un colega. A veces, lo que veremos como una mejora finalmente será un error, y volver al estado inicial puede ser difícil. Así que tenemos que gestionar las versiones. En la mayoría de los laboratorios hay servicios de control de versiones, el más conocido es GIT (https://git-scm.com/) y Subversion (https://subversion.apache.org/). Cuando GIT o Subversion están disponibles, se recomienda usarlos. Si no tenemos acceso a estos servicios, hay servicios en línea gratuitos como GitHub (https://github.com/; este libro utiliza GitHub). Hay muchas otras soluciones como GitLab (https://about.gitlab.com/), Bitbucket (https://bitbucket.org/), SourceForge (https://sourceforge.net/), GitKraken (https://gitkraken.com/), o Launchpad (https://launchpad.net/). El uso de estos diferentes servicios de versiones está fuera del alcance de este libro. Para los principiantes o para proyectos que no requieren trabajo colaborativo en scripts, una alternativa es administrar sus versiones manualmente. Por ejemplo, una solución es agregar un número al final de su nombre de archivo de script (por ejemplo, “myFirstScript_01.R”). Tan pronto como se realice una modificación importante en este script, bastará con guardarlo con un nuevo nombre (p. Ej., “MyFirstScript_02.R”) y colocar el script antiguo en una carpeta aparte para no desordenar el espacio de trabajo y hacer errores de version. En caso de problemas, podemos volver fácilmente al script anterior y reanudar nuestro trabajo. ## -myProject ## |-myFiles ## |-|-data01.csv ## |-|-data02.csv ## |-myScripts ## |-|-myFirstScript04.R ## |-|-ARCHIVES ## |-|-|-myFirstScript01.R ## |-|-|-myFirstScript02.R ## |-|-|-myFirstScript03.R ## |-myOutputs ## |-|-dataOut01.csv ## |-|-figure01.pdf 12.3 Gestion de documentacion La documentación de su código es esencial para volver fácilmente al trabajo o comunicar su trabajo con colegas y la comunidad científica. Un código bien documentado será comprensible por un número mayor y, por lo tanto, se utilizará más. Por eso es importante adoptar buenas técnicas y practicas. Ya hemos visto que hay varias formas de escribir su código con R porque es un lenguaje bastante permisivo. El primer paso hacia un código legible y reproducible es adoptar un estilo de código claro y coherente y … ¡hecho para humanos! Porque incluso si nuestro código está destinado a ser ejecutado por máquinas, debe seguir siendo comprensible de todas las personas que lo consultarán. Es por ejemplo poner espacios después de las comas, o usar la identación. Por supuesto, la legibilidad del código debe equilibrarse con la optimización del código para grandes conjuntos de datos, pero en la mayoría de los casos podemos asociar un código claro y optimizado. Entonces, el primer paso de la documentación y su administración es escribir primero su código pensando en las personas que lo leerán y lo reproducirán. El segundo paso es comentar su código. Los comentarios son esenciales cuando privilegiamos el código optimizado para el rendimiento pero que pierde en legibilidad. Los comentarios son superfluos si el código está bien escrito y los objetos y funciones están bien nombrados. Esto significa que los comentarios no deben usarse para explicar un código mal escrito, sino que desdemos desde el principio escribir bien nuestro código. Los comentarios son útiles para proporcionar elementos contextuales (por ejemplo, la elección de un método sobre otro en la literatura). El lugar de los comentarios puede estar al final de las líneas o en líneas separadas. Para un proyecto pequeño en R es esencial que cada script comience con una descripción de sus contenidos para que podamos saber rápidamente de qué se trata. Eso es lo que hicimos al principio de este libro: # ------------------------------------------------------------ # Aquí hay un script para adquirir los conceptos básicos # con R # fecha de creación : 25/06/2018 # autor : François Rebaudo # ------------------------------------------------------------ # [1] Creación del objeto número de repeticiones. # ------------------------------------------------------------ nbrRep &lt;- 5 # [2] calculos simples # ------------------------------------------------------------ pi * nbrRep^2 Aquí los comentarios que siguen al encabezado no son necesarios porque el nombre del objeto se entiende por sí mismo. Nuestro archivo se convierte en: # ------------------------------------------------------------ # Aquí hay un script para adquirir los conceptos básicos # con R # fecha de creación : 25/06/2018 # autor : François Rebaudo # ------------------------------------------------------------ nbrRep &lt;- 5 pi * nbrRep^2 Para un proyecto grande con muchas funciones para ser utilizado por otros usuarios, es preferible que la documentación del código esté separada, en un archivo de ayuda específico. Este es el caso de todos los paquetes R! Para gestionar la documentación de un paquete (y por lo tanto de todas las funciones), de nuevo hay muchas posibilidades. Lo más común es usar el paquete R roxigen2. Sin entrar en detalles, aquí hay algunos ejemplos de la documentación del paquete. #&#39; Add together two numbers #&#39; #&#39; @param x A number #&#39; @param y A number #&#39; @return The sum of \\code{x} and \\code{y} #&#39; @examples #&#39; add(1, 1) #&#39; add(10, 1) add &lt;- function(x, y) { x + y } #&#39; Sum of vector elements. #&#39; #&#39; `sum` returns the sum of all the values present in its arguments. #&#39; #&#39; This is a generic function: methods can be defined for it directly #&#39; or via the [Summary()] group generic. For this to work properly, #&#39; the arguments `...` should be unnamed, and dispatch is on the #&#39; first argument. sum &lt;- function(..., na.rm = TRUE) {} Esto nos permite escribir la documentación de cada función junto a la función. El paquete roxigen2 generará a partir de estos comentarios un documento de ayuda accesible con la función '?'. A menos que escribamos un nuevo paquete, los comentarios simples serán suficientes, y el desarrollo de un paquete está fuera del alcance de este libro. 12.4 Conclusión Felicitaciones. Este capítulo marca el final de la primera parte de este libro. Ahora tenemos lo básico para llevar a cabo nuestros proyectos con R. En la siguiente parte veremos los gráficos y cómo hacer figuras en el marco de los artículos científicos. "],
["graph1.html", " 13 Gráficos simples 13.1 plot 13.2 hist 13.3 barplot 13.4 boxplot 13.5 Otros gráficos 13.6 Conclusión", " 13 Gráficos simples 13.1 plot El primer tipo de gráfico que veremos es la nube de puntos. En un diagrama de dispersión, cada punto está representado por su valor en x e y. La función para hacer un diagrama de dispersión es plot(). myX &lt;- rnorm(50, mean = 0, sd = 1) myY &lt;- rnorm(50, mean = 10, sd = 1) plot(x = myX, y = myY) Al igual que con todos los tipos de gráficos, podemos agregar una leyenda en los ejes x e y. plot(x = myX, y = myY, xlab = &quot;X&quot;, ylab = &quot;Y&quot;) También podemos definir los límites de los ejes X e Y. plot(x = myX, y = myY, xlab = &quot;X&quot;, ylab = &quot;Y&quot;, xlim = c(-3, 3), ylim = c(7, 13)) El tipo de punto se puede establecer con el argumento pch que puede tomar un carácter o un número del 1 al 25. plot(x = rep(seq(1:5), 5), y = rep(seq(1:5), each = 5), pch = 1:25) plot(x = myX, y = myY, pch = c(&quot;a&quot;, &quot;@&quot;, &quot;#&quot;, &quot;1&quot;, &quot;=&quot;, &quot;-&quot;, &quot;_&quot;, &quot;o&quot;, &quot;O&quot;, &quot;0&quot;, letters[1:15])) El tamaño de los puntos se puede definir con el argumento cex. plot(x = myX, y = myY, cex = seq(from = 0.5, to = 3, length.out = 50)) El color de los puntos se puede definir con el argumento col. Volveremos a los colores en un próximo capítulo. myX &lt;- rnorm(100, mean = 0, sd = 1) myY &lt;- rnorm(100, mean = 10, sd = 1) plot(x = myX, y = myY, cex = seq(from = 0.5, to = 3, length.out = 100), pch = 16, col = sample(colors(), 100)) Para representar nuestros puntos, el color y el tamaño de los puntos pueden representar información adicional. Aquí representaremos por un gradiente de tamaño la variable myY y por un gradiente de color la variablemyX. myX &lt;- rnorm(100) myY &lt;- rnorm(100) dfGraph &lt;- data.frame(myX, myY) dfGraph &lt;- dfGraph[order(dfGraph$myX),] dfGraph$myCol &lt;- colorRampPalette(c(&quot;blue&quot;, &quot;red&quot;))(100) dfGraph &lt;- dfGraph[order(dfGraph$myY),] dfGraph$myCex &lt;- seq(from = 0.5, to = 3, length.out = 100) plot(x = dfGraph$myX, y = dfGraph$myY, cex = dfGraph$myCex, pch = 16, col = dfGraph$myCol, xlab = &quot;&quot;, ylab = &quot;&quot;) R ofrece la posibilidad de conectar puntos de nube de puntos de diferentes maneras. Las diferentes opciones están disponibles en la ayuda de las funciones plot() y plot.default(). myX &lt;- 1:20 myY &lt;- rnorm(20, mean = 10, sd = 1) plot(x = myX, y = myY, type = &#39;b&#39;) # &#39;p&#39;, &#39;l&#39;, &#39;b&#39;, &#39;c&#39;, &#39;o&#39;, &#39;h&#39;, &#39;s&#39;, &#39;S&#39;, &#39;n&#39; Una última opción muy útil es el argumento panel.first que permite realizar una operación gráfica en una capa debajo de nuestro gráfico. Aquí hay un ejemplo ilustrativo con una cuadrícula hecha con y sin panel.first. La cuadrícula se realiza gracias a la función grid(). Para poner los gráficos lado a lado usaremos mfrow. par(mfrow = c(1, 2)) plot(x = myX, y = myY, type = &#39;b&#39;, pch = 16, cex = 3) grid(lwd = 3, lty = 1) plot(x = myX, y = myY, type = &#39;b&#39;, pch = 16, cex = 3, panel.first = grid(lwd = 3, lty = 1)) par(mfrow = c(1, 1)) La función par() proporciona acceso a parámetros gráficos. Entre estos parámetros hay mfrow que permite dividir el espacio gráfico como una matriz. mfrow toma como argumentos un vector numérico de tamaño 2: el primer elemento corresponde al número de líneas y el segundo elemento al número de columnas. El parámetro mar controla los márgenes en la parte inferior, izquierda, superior y derecha, respectivamente, utilizando un vector digital de tamaño 4. Después de cambiar la configuración de gráficos predeterminada, se recomienda restablecerlos para que no afecte a los futuros gráficos. Los valores predeterminados para mfrow son c(1, 1) y mar = c (4, 4, 4, 4). Podemos restablecer estos valores predeterminados como antes, redefiniendo cada parámetro. También podemos guardar los valores actuales (en un objeto op) de antemano, modificarlos para los propósitos de nuestros gráficos y luego recuperar los valores contenidos en el objeto op. Aquí usamos lapply para hacer rápidamente cuatro gráficos. op &lt;- par(no.readonly = TRUE) par(mfrow = c(2, 2), mar = c(2, 2, 1, 1)) graph4 &lt;- lapply(1:4, function(i){ plot(x = rnorm(100), y = rnorm(100), col = i, pch = 16) }) par(op) Es útil incluir líneas verticales u horizontales para representar valores particulares. Estas líneas se pueden agregar con la función abline(). myX &lt;- rnorm(100) myY &lt;- rnorm(100) plot(x = myX, y = myY, xlim = c(-4, 4), ylim = c(-4, 4), pch = 16, cex = 1.5, col = sample(colors(), size = 100), panel.first = { grid() abline(v = c(min(myX), max(myX)), lty = 2) abline(h = c(min(myY), max(myY)), lty = 2) abline(v = mean(myX), lty = 1) abline(h = mean(myY), lty = 1) }) 13.2 hist Para hacer un histograma usamos la función hist(). Esta es una función gráfica útil para visualizar rápidamente la distribución de un conjunto de datos. op &lt;- par(no.readonly = TRUE) par(mfrow = c(2, 2), mar = c(2, 2, 1, 1)) myX &lt;- list( rnorm(1000), rgamma(1000, shape = 1), sample(1:100, size = 1000, replace = TRUE), rbeta(1000, shape1 = 1, shape2 = 2) ) myTitle &lt;- c(&quot;Normal&quot;, &quot;Gamma&quot;, &quot;Uniform&quot;, &quot;Beta&quot;) tr &lt;- lapply(1:4, function(i){ hist(myX[[i]], col = heat.colors(15), main = myTitle[i] ) }) par(op) 13.3 barplot El gráfico de barras se realiza utilizando la función barplot(). myX &lt;- c(4, 5, 8) barplot(myX, names.arg = c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;)) Cuando el objeto enviado a esta función es un vector, entonces la función barplot() devuelve un gráfico de barras simple. Cuando es un matrix entonces las barras son múltiples. op &lt;- par(no.readonly = TRUE) par(mfrow = c(1, 2), mar = c(2, 2, 1, 1)) myX &lt;- matrix(c(4, 5, 8, 4, 6, 2), nrow = 2) barplot(myX, names.arg = c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;)) myX &lt;- matrix(c(4, 5, 8, 4, 6, 2, 3, 4, 5), nrow = 3) barplot(myX, names.arg = c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;)) par(op) La función barplot() también se puede usar para representar el equivalente de un histograma. Esto puede ser útil para representar la distribución de una variable en función del eje x el eje y. En el siguiente ejemplo tenemos n puntos tomados aleatoriamente en una distribución normal con la configuración mean = 0 y sd = 1 (myX &lt;- rnorm(n)). Estos puntos son para ser mostrado en azul o en rojo (el color azul se codifica con el valor 4 y el color rojo con el valor 2, discutiremos en un capítulo posterior). La eleccion aleatoria del color se realiza con la función sample() (myCol &lt;- sample(c(4, 2), size = n, replace = TRUE)). Aquí queremos representar una nube de puntos con puntos rojos o azules, y histogramas de los ejes X y Y para ver la distribución de puntos (con un degradado de color de azul a rojo dependiendo La proporción de puntos de color en cada categoría con un degradado de color con 100 valores entre azul y rojo ; Mycolors &lt;- colorRampPalette (c(&quot;azul&quot;, &quot;rojo&quot;))(100)). Para hacer el histograma, cortaremos los datos con la función cut(), especificando que queremos que las separaciones se realicen entre -4 y 4 en pasos de 1 (myYCut &lt;- cut(myY, breaks = -4:4)). Para contar el número de puntos en cada categoría y para cada color, solo usamos la función table() (myYCutCol &lt;- table(myCol, myYCut)). En esta tabla, la primera línea corresponde al primer color encontrado en el conjunto de datos y la segunda línea al otro color. Es por eso que necesitamos cambiar el dibujo aleatorio de los colores para que la primera línea siempre corresponda a azul y la segunda línea a rojo: myCol &lt;- c(2, sample(c(4, 2), size = (n - 1), replace = TRUE)). Luego podemos calcular la proporción de rojo dividiendo la primera línea por la suma de las dos líneas que representaremos en porcentaje multiplicando por 100: myXCutCol[1,] / (myXCutCol[1,] + myXCutCol[2,]) * 100. Para que este número coincida con un color, solo mantendremos su parte entera con la función round(). Si el porcentaje es cero o si el resultado no es posible debido a una división por cero, debemos reemplazarlo con 1 para que corresponda a un color en nuestro gradiente que va de 1 a 100 (xCol[is.na(xCol) | xCol == 0] &lt;- 1). Todo lo que nos queda es organizar el espacio gráfico con la función layout() que toma como argumento una matriz cuyos valores y su posición corresponderán al diseño de los diferentes gráficos que queremos lograr. El gráfico 1 corresponde al gráfico de barras superior, el gráfico 2 a la nube de puntos y el gráfico 3 al gráfico de barras derecho. n &lt;- 50 myX &lt;- rnorm(n) myY &lt;- rnorm(n) myCol &lt;- c(2, sample(c(4, 2), size = (n - 1), replace = TRUE)) myColors &lt;- colorRampPalette(c(&quot;blue&quot;, &quot;red&quot;))(100) myYCut &lt;- cut(myY, breaks = -4:4) myXCut &lt;- cut(myX, breaks = -4:4) myYCutCol &lt;- table(myCol, myYCut) myXCutCol &lt;- table(myCol, myXCut) xCol &lt;- round( myXCutCol[1,] / (myXCutCol[1,] + myXCutCol[2,]) * 100 ) xCol[is.na(xCol) | xCol == 0] &lt;- 1 yCol &lt;- round( myYCutCol[1,] / (myYCutCol[1,] + myYCutCol[2,]) * 100 ) yCol[is.na(yCol) | yCol == 0] &lt;- 1 op &lt;- par(no.readonly = TRUE) par(mar = c(2, 3, 1, 1)) layout(matrix(c(1, 1, 0, 2, 2, 3, 2, 2, 3), ncol = 3, byrow = TRUE)) barplot(table(myXCut), las = 1, col = myColors[xCol]) plot(x = myX, y = myY, col = myCol, pch = 16, xlim = c(-4, 4), ylim = c(-4, 4), cex = 1.5, panel.first = grid()) barplot(table(myYCut), las = 1, horiz = TRUE, col = myColors[yCol]) par(op) Luego podemos integrar este script en una función para, por ejemplo, estudiar el efecto de la variable n. graphBarplotCol &lt;- function(n){ myX &lt;- rnorm(n) myY &lt;- rnorm(n) myCol &lt;- c(2, sample(c(4, 2), size = (n - 1), replace = TRUE)) myColors &lt;- colorRampPalette(c(&quot;blue&quot;, &quot;red&quot;))(100) myYCut &lt;- cut(myY, breaks = -4:4) myXCut &lt;- cut(myX, breaks = -4:4) myYCutCol &lt;- table(myCol, myYCut) myXCutCol &lt;- table(myCol, myXCut) xCol &lt;- round( myXCutCol[1,] / (myXCutCol[1,] + myXCutCol[2,]) * 100 ) xCol[is.na(xCol) | xCol == 0] &lt;- 1 yCol &lt;- round( myYCutCol[1,] / (myYCutCol[1,] + myYCutCol[2,]) * 100 ) yCol[is.na(yCol) | yCol == 0] &lt;- 1 op &lt;- par(no.readonly = TRUE) par(mar = c(2, 3, 1, 1)) layout(matrix(c(1, 1, 0, 2, 2, 3, 2, 2, 3), ncol = 3, byrow = TRUE)) barplot(table(myXCut), las = 1, col = myColors[xCol]) plot(x = myX, y = myY, col = myCol, pch = 16, xlim = c(-4, 4), ylim = c(-4, 4), cex = 1.5, panel.first = grid()) barplot(table(myYCut), las = 1, horiz = TRUE, col = myColors[yCol]) par(op) } graphBarplotCol(n = 1000) Por supuesto, un barplot puede tomar valores positivos o negativos. barplot(rnorm(20), horiz = TRUE, col = rainbow(20)) El barplot también se puede usar para hacer una pirámide de edades (hay funciones para realizar las las pirámides de edades, aquí el objetivo es educativo). gender &lt;- data.frame( m = cut(sample(1:75, 1000, replace = TRUE), breaks = seq(from = 0, to = 80, by = 10)), f = cut(sample(1:75, 1000, replace = TRUE), breaks = seq(from = 0, to = 80, by = 10)) ) op &lt;- par(no.readonly = TRUE) par(mfrow = c(1, 2), mar = c(2, 1, 2, 1)) barplot(-table(gender$f), horiz = TRUE, col = &quot;salmon&quot;) barplot(table(gender$m), horiz = TRUE, col = &quot;lightblue&quot;) par(op) 13.4 boxplot Los diagramas de caja son gráficos muy comunes con R porque ofrecen una buena vista de un conjunto de datos al representar los valores extremos (valores atípicos), la mediana, los cuartiles, los mínimos y los máximos. La función boxplot() se aplica a uno o más vector. df &lt;- data.frame( box1 = rnorm(1000), box2 = rgamma(1000, shape = 1), box3 = sample(-3:3, size = 1000, replace = TRUE), box4 = rbeta(1000, shape1 = 1, shape2 = 2) ) boxplot(df, col = c(rgb(0, 94, 255, maxColorValue = 255), rgb(255, 0, 174, maxColorValue = 255), rgb(255, 136, 0, maxColorValue = 255), rgb(119, 255, 0, maxColorValue = 255))) Si una variable es de tipo factor, la función boxplot() facilita la representación de cada categoría. También funciona con variables numéricas, pero se debe tener cuidado de no tener demasiados valores diferentes para que el gráfico permanezca legible. df$cat &lt;- sample(c(&quot;w&quot;, &quot;x&quot;, &quot;y&quot;, &quot;z&quot;), size = 1000, replace = TRUE) boxplot(df$box3 ~ df$cat, col = c(rgb(0, 94, 255, maxColorValue = 255), rgb(255, 0, 174, maxColorValue = 255), rgb(255, 136, 0, maxColorValue = 255), rgb(119, 255, 0, maxColorValue = 255)), ylab = &quot;Box3&quot;) df$cat2 &lt;- sample(1:3, size = 1000, replace = TRUE) boxplot(df$box4 ~ df$cat*df$cat2, col = c( rgb(0, 94, 255, maxColorValue = 255), rgb(255, 0, 174, maxColorValue = 255), rgb(255, 136, 0, maxColorValue = 255), rgb(119, 255, 0, maxColorValue = 255)), ylab = &quot;Box4&quot;) El boxplot puede representarse horizontal o verticalmente. df$cat &lt;- sample(c(&quot;w&quot;, &quot;x&quot;, &quot;y&quot;, &quot;z&quot;), size = 1000, replace = TRUE) boxplot(df$box2 ~ df$cat, horizontal = TRUE, col = c(rgb(255, 110, 0, maxColorValue = 255), rgb(230, 255, 0, maxColorValue = 255), rgb(0, 178, 255, maxColorValue = 255), rgb(166, 0, 255, maxColorValue = 255)), xlab = &quot;Box2&quot;) 13.5 Otros gráficos Hay muchos otros gráficos, pero los que acabamos de ver son la base. Para obtener más información e ideas para representar sus datos, podemos consultar el hermoso sitio https://www.data-to-viz.com/ o la galería gráfica R https://www.r-graph-gallery.com/ (la mayoría de los gráficos se realizan con el paquete ggplot2 que veremos más adelante). Para obtener más ideas, también podemos usar la demostración del paquete graphics usando el comando demo('graphics') (la tecla “Enter” se usa para mostrar los gráficos). 13.6 Conclusión Felicitaciones, hemos llegado al final de este capítulo sobre gráficos simples. Ahora sabemos cómo hacer que los gráficos principales plot(), hist(), barplot(), y boxplot(). A lo largo de este capítulo, hemos utilizado diferentes colores y diferentes formas de representar los colores: es hora de formalizar el uso y la gestión de los colores. ¡Este es el tema del próximo capítulo! "],
["studyCase1.html", " 14 Analizar datos de loggers de temperatura", " 14 Analizar datos de loggers de temperatura En estudios de biología, ecología, o agronomía, frecuentemente usamos datos de temperatura de dataloggers. En este estudio vamos a ver como analizar esos datos usando datos de temperatura del altiplano Boliviano cerca de la ciudad de El Alto. El primer paso es transformar los datos del datalogger en un formato que sea fácil de leer para R. Usaremos un archivo CSV y la función read.table(). El archivo se puede descargar desde el sitio web del libro en GitHub (https://github.com/frareb/myRBook_SP/blob/master/myFiles/E05C13.csv ; clic derecho sobre el enlace y seleccionar “Guardar destino como”). bdd &lt;- read.table(&quot;myFiles/E05C13.csv&quot;, skip = 1, header = TRUE, sep = &quot;,&quot;, dec = &quot;.&quot;, stringsAsFactors = FALSE) colnames(bdd) &lt;- c(&quot;id&quot;, &quot;date&quot;, &quot;temp&quot;) head(bdd) ## id date temp ## 1 1 11/12/15 23:00:00 4.973 ## 2 2 11/12/15 23:30:00 4.766 ## 3 3 11/13/15 00:00:00 4.844 ## 4 4 11/13/15 00:30:00 4.844 ## 5 5 11/13/15 01:00:00 5.076 ## 6 6 11/13/15 01:30:00 5.282 tail(bdd) ## id date temp ## 32781 32781 09/25/17 21:00:00 7.091 ## 32782 32782 09/25/17 21:30:00 6.914 ## 32783 32783 09/25/17 22:00:00 6.813 ## 32784 32784 09/25/17 22:30:00 6.611 ## 32785 32785 09/25/17 23:00:00 6.331 ## 32786 32786 09/25/17 23:30:00 5.385 str(bdd) ## &#39;data.frame&#39;: 32786 obs. of 3 variables: ## $ id : int 1 2 3 4 5 6 7 8 9 10 ... ## $ date: chr &quot;11/12/15 23:00:00&quot; &quot;11/12/15 23:30:00&quot; &quot;11/13/15 00:00:00&quot; &quot;11/13/15 00:30:00&quot; ... ## $ temp: num 4.97 4.77 4.84 4.84 5.08 ... Podemos observar que la fecha esta al formato character, y que contiene la fecha con el mes, el día, y el año separados con /, un espacio, y la hora con horas de 0 a 24, minutos, y segundos, separados con : (ejemplo: 11/12/15 23:00:00 para el 12 de Noviembre de 2015 a las 11 de la noche). Vamos a separar la información en varios objetos. Primero vamos a separar la fecha de la hora. Para esto vamos a usar la función strsplit() usando como separador el espacio entre la fecha y la hora. strsplit(&quot;11/12/15 23:00:00&quot;, split = &quot; &quot;) ## [[1]] ## [1] &quot;11/12/15&quot; &quot;23:00:00&quot; Como indican los corchetes dobles, la función devuelve un objeto en el formato list. Nosotros queremos el vector que corresponde al primer elemento de la list entonces vamos a añadir [[1]]. strsplit(&quot;11/12/15 23:00:00&quot;, split = &quot; &quot;)[[1]] ## [1] &quot;11/12/15&quot; &quot;23:00:00&quot; El primer elemento del vector es la fecha. Para tener todas las fechas vamos a hacer un bucle con la función sapply(). bddDay &lt;- sapply(strsplit(bdd[, 2], split = &quot; &quot;), &quot;[[&quot;, 1) head(bddDay) ## [1] &quot;11/12/15&quot; &quot;11/12/15&quot; &quot;11/13/15&quot; &quot;11/13/15&quot; &quot;11/13/15&quot; &quot;11/13/15&quot; A continuación vamos a necesitar las fechas en el formato factor (función aggregate() para sacar la información por día). Entonces necesitamos transformar el objeto en el formato factor con la función as.factor(). bddDay &lt;- as.factor(sapply(strsplit(bdd[, 2], split = &quot; &quot;), &quot;[[&quot;, 1)) head(bddDay) ## [1] 11/12/15 11/12/15 11/13/15 11/13/15 11/13/15 11/13/15 ## 684 Levels: 01/01/16 01/01/17 01/02/16 01/02/17 01/03/16 ... 12/31/16 Haciendo la transformación hacia el formato factor, los niveles de nuestro objeto están en orden alfabético como si las fechas estuvieran texto. Nosotros querremos ordenar las fechas usando las fechas. Para esto vamos a hacer un vector con todas las fechas únicas con la función unique(), y después ordenar las fechas con la función sort.list() usando las fechas con la función as.POSIXct(). Vamos a usar el vector llamado lev para especificar como deben estar los niveles de factor de nuestras fechas. bddDay &lt;- as.factor(sapply(strsplit(bdd[, 2], split = &quot; &quot;), &quot;[[&quot;, 1)) udate &lt;- unique(bddDay) lev &lt;- udate[sort.list(as.POSIXct(strptime(udate, &quot;%m/%d/%y&quot;)))] bddDay &lt;- factor(bddDay, levels = lev) head(bddDay) ## [1] 11/12/15 11/12/15 11/13/15 11/13/15 11/13/15 11/13/15 ## 684 Levels: 11/12/15 11/13/15 11/14/15 11/15/15 11/16/15 ... 09/25/17 Ahora podemos añadir las fechas como nueva columna del objeto bdd y hacer lo mismo para las horas (no hay que reordenar los niveles de hora ya que el orden por defecto corresponde a lo que queremos). bdd$bddDay &lt;- bddDay bdd$bddHour &lt;- as.factor(sapply(strsplit(bdd[, 2], split = &quot; &quot;), &quot;[[&quot;, 2)) head(bdd) ## id date temp bddDay bddHour ## 1 1 11/12/15 23:00:00 4.973 11/12/15 23:00:00 ## 2 2 11/12/15 23:30:00 4.766 11/12/15 23:30:00 ## 3 3 11/13/15 00:00:00 4.844 11/13/15 00:00:00 ## 4 4 11/13/15 00:30:00 4.844 11/13/15 00:30:00 ## 5 5 11/13/15 01:00:00 5.076 11/13/15 01:00:00 ## 6 6 11/13/15 01:30:00 5.282 11/13/15 01:30:00 Podemos visualizar los datos con la función plot(), especificando el formato de las fechas con la función as.Date() plot(x = as.Date(bdd$bddDay, format = &quot;%m/%d/%y&quot;), y = bdd$temp, type = &#39;l&#39;, ylim = c(-15, 40), xlab = &quot;Fecha&quot;, ylab = &quot;Temperatura (°C)&quot;) Podemos simplificar la información calculando únicamente las temperaturas mínimas, promedias, y máximas con la función aggregate(). tempDayMean &lt;- aggregate(x = bdd[, 3], by = list(bdd[, 4]), FUN = mean) tempDayMin &lt;- aggregate(x = bdd[, 3], by = list(bdd[, 4]), FUN = min) tempDayMax &lt;- aggregate(x = bdd[, 3], by = list(bdd[, 4]), FUN = max) plot(x = as.Date(tempDayMean[, 1], format = &quot;%m/%d/%y&quot;), y = tempDayMean[, 2], type = &#39;l&#39;, ylim = c(-15, 40), xlab = &quot;Fecha&quot;, ylab = &quot;Temperatura (°C)&quot;) points(x = as.Date(tempDayMin[, 1], format = &quot;%m/%d/%y&quot;), y = tempDayMin[, 2], type = &#39;l&#39;, col = 4) points(x = as.Date(tempDayMax[, 1], format = &quot;%m/%d/%y&quot;), y = tempDayMax[, 2], type = &#39;l&#39;, col = 2) legend(&quot;topright&quot;, legend = c(&quot;min&quot;, &quot;max&quot;, &quot;promedio&quot;), lty = 1, lwd = 2, col = c(4, 2, 1)) También podemos calcular la diferencia entre la temperatura máxima y la temperatura mínima (variación de temperatura diurna). tempDayTR &lt;- tempDayMax[, 2] - tempDayMin[, 2] plot(x = as.Date(tempDayMean[, 1], format = &quot;%m/%d/%y&quot;), y = tempDayTR, type = &#39;l&#39;, ylim = c(5, 45), xlab = &quot;Fecha&quot;, ylab = &quot;Variación de temperatura diurna (°C)&quot;) Otra posibilidad es de agrupar los datos para tener la temperatura promedia de un día con la función aggregate(). tempHourMean &lt;- aggregate(x = bdd[, 3], by = list(bdd[, 5]), FUN = mean) tempHourMin &lt;- aggregate(x = bdd[, 3], by = list(bdd[, 5]), FUN = min) tempHourMax &lt;- aggregate(x = bdd[, 3], by = list(bdd[, 5]), FUN = max) hours &lt;- seq(from = 0, to = 23.5, by = 0.5) plot(x = hours, y = tempHourMean[, 2], type = &#39;l&#39;, ylim = c(-15, 40), xlab = &quot;&quot;, ylab = &quot;Temperatura (°C)&quot;, lwd = 2, xaxt = &quot;n&quot;, panel.first = { abline(v = hours, col = &quot;gray&quot;, lty = 2) abline(h = 0, lty = 2) }) axis(side = 1, at = hours, labels = tempHourMean[, 1], las = 2) points(x = hours, y = tempHourMin[, 2], type = &#39;l&#39;, col = 4, lwd = 2) points(x = hours, y = tempHourMax[, 2], type = &#39;l&#39;, col = 2, lwd = 2) Tambien podemos calcular las temperaturas de los dias para cada mes. meses &lt;- c(&quot;Enero&quot;, &quot;Febrero&quot;, &quot;Marzo&quot;, &quot;Abril&quot;, &quot;Mayo&quot;, &quot;Junio&quot;, &quot;Julio&quot;, &quot;Agosto&quot;, &quot;Septiembre&quot;, &quot;Octubre&quot;, &quot;Noviembre&quot;, &quot;Diciembre&quot;) hours &lt;- seq(from = 0, to = 23.5, by = 0.5) bddMonth &lt;- sapply(strsplit(as.character(bdd$bddDay), split = &quot;/&quot;), &quot;[[&quot;, 1) tempDayEachMonth &lt;- lapply(sort(unique(bddMonth)), function(myMonth){ bddX &lt;- bdd[bddMonth == myMonth, ] tempHourMean &lt;- aggregate(x = bddX[, 3], by = list(bddX[, 5]), FUN = mean) tempHourMin &lt;- aggregate(x = bddX[, 3], by = list(bddX[, 5]), FUN = min) tempHourMax &lt;- aggregate(x = bddX[, 3], by = list(bddX[, 5]), FUN = max) return(data.frame(tempHourMean, tempHourMin, tempHourMax)) }) for (i in seq_along(tempDayEachMonth)){ plot(x = hours, y = tempDayEachMonth[[i]][, 2], type = &#39;l&#39;, ylim = c(-15, 40), xlab = &quot;&quot;, ylab = &quot;Temperatura (°C)&quot;, lwd = 2, main = meses[i], xaxt = &quot;n&quot;, panel.first = { abline(v = hours, col = &quot;gray&quot;, lty = 2) abline(h = 0, lty = 2) }) axis(side = 1, at = hours, labels = tempHourMean[, 1], las = 2) points(x = hours, y = tempDayEachMonth[[i]][, 4], type = &#39;l&#39;, col = 4, lwd = 2) points(x = hours, y = tempDayEachMonth[[i]][, 6], type = &#39;l&#39;, col = 2, lwd = 2) } O todo en un mismo grafico, y la variación de temperatura diurna para cada mes. plot(x = hours, y = tempDayEachMonth[[1]][, 2], type = &#39;n&#39;, ylim = c(-10, 35), xlab = &quot;&quot;, ylab = &quot;Temperatura promedia (°C)&quot;, xaxt = &quot;n&quot;, panel.first = { abline(v = hours, col = &quot;gray&quot;, lty = 2) abline(h = 0, lty = 2) }) axis(side = 1, at = hours, labels = tempHourMean[, 1], las = 2) myColors &lt;- c(&quot;#A6CEE3&quot;, &quot;#1F78B4&quot;, &quot;#B2DF8A&quot;, &quot;#33A02C&quot;, &quot;#FB9A99&quot;, &quot;#E31A1C&quot;, &quot;#FDBF6F&quot;, &quot;#FF7F00&quot;, &quot;#CAB2D6&quot;, &quot;#6A3D9A&quot;, &quot;#FFFF99&quot;, &quot;#B15928&quot;) for (i in seq_along(tempDayEachMonth)){ points(x = hours, y = tempDayEachMonth[[i]][, 2], type = &#39;l&#39;, col = myColors[i], lwd = 2) } legend(&quot;topright&quot;, ncol = 4, legend = meses, col = myColors, lty = 1, lwd = 2, cex = 0.8) plot(x = hours, y = tempDayEachMonth[[1]][, 2], type = &#39;n&#39;, ylim = c(0, 30), xlab = &quot;&quot;, ylab = &quot;Variación de temperatura diurna (°C)&quot;, xaxt = &quot;n&quot;, panel.first = { abline(v = hours, col = &quot;gray&quot;, lty = 2) abline(h = 0, lty = 2) }) axis(side = 1, at = hours, labels = tempHourMean[, 1], las = 2) myColors &lt;- c(&quot;#A6CEE3&quot;, &quot;#1F78B4&quot;, &quot;#B2DF8A&quot;, &quot;#33A02C&quot;, &quot;#FB9A99&quot;, &quot;#E31A1C&quot;, &quot;#FDBF6F&quot;, &quot;#FF7F00&quot;, &quot;#CAB2D6&quot;, &quot;#6A3D9A&quot;, &quot;#FFFF99&quot;, &quot;#B15928&quot;) for (i in seq_along(tempDayEachMonth)){ points(x = hours, y = tempDayEachMonth[[i]][, 6] - tempDayEachMonth[[i]][, 4], type = &#39;l&#39;, col = myColors[i], lwd = 2) } legend(&quot;topright&quot;, ncol = 4, legend = meses, col = myColors, lty = 1, lwd = 2, cex = 0.8) "]
]
